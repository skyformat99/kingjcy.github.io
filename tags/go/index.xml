<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/go/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>从harbor入手beego框架</title>
      <link>http://kingjcy.github.io/blog/2017/06/12/%E4%BB%8Eharbor%E5%85%A5%E6%89%8Bbeego%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 12 Jun 2017 10:34:15 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/12/%E4%BB%8Eharbor%E5%85%A5%E6%89%8Bbeego%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;p&gt;beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;beego 是基于八大独立的模块构建的，是一个高度解耦的框架。当初设计 beego 的时候就是考虑功能模块化，用户即使不使用 beego 的 HTTP 逻辑，也依旧可以使用这些独立模块&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;bee 工具的安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/beego/bee
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在命令行输入 bee，可以看到如下的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bee is a tool for managing beego framework.

Usage:

    bee command [arguments]

The commands are:

    new         create an application base on beego framework
    run         run the app which can hot compile
    pack        compress an beego project
    api         create an api application base on beego framework
    bale        packs non-Go files to Go source files
    version     show the bee &amp;amp; beego version
    generate    source code generator
    migrate     run database migrations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详解&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;new 命令是新建一个 Web 项目，我们在命令行下执行 bee new &amp;lt;项目名&amp;gt; 就可以创建一个新的项目。但是注意该命令必须在 $GOPATH/src 下执行。最后会在 $GOPATH/src 相应目录下生成如下目录结构的项目：&lt;/p&gt;

&lt;p&gt;├── conf
│   └── app.conf
├── controllers
│   ├── admin
│   └── default.go
├── main.go
├── models
│   └── models.go
├── static
│   ├── css
│   ├── ico
│   ├── img
│   └── js
└── views
    ├── admin
    └── index.tpl&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面的目录结构我们可以看出来 M（models 目录）、V（views 目录）和 C（controllers 目录）的结构， main.go 是入口文件。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;很多用户使用 beego 来开发 API 应用。所以这个 api 命令就是用来创建 API 应用的&lt;/p&gt;

&lt;p&gt;apiproject
├── conf
│   └── app.conf
├── controllers
│   └── object.go
│   └── user.go
├── docs
│   └── doc.go
├── main.go
├── models
│   └── object.go
│   └── user.go
├── routers
│   └── router.go
└── tests
    └── default_test.go&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面的目录我们可以看到和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试的。&lt;/p&gt;

&lt;p&gt;同时，该命令还支持一些自定义参数自动连接数据库创建相关 model 和 controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bee api [appname] [-tables=“”] [-driver=mysql] [-conn=root:@tcp(127.0.0.1:3306)/test]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 conn 参数为空则创建一个示例项目，否则将基于链接信息链接数据库创建项目。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;bee run 命令是运行监控 beego 的项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pack 目录用来发布应用的时候打包，会把项目打包成 zip 包，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;beego的安装&lt;/p&gt;

&lt;p&gt;go get github.com/astaxie/beego&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;项目&#34;&gt;项目&lt;/h2&gt;

&lt;p&gt;一、入口main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    _ &amp;quot;quickstart/routers&amp;quot;
    &amp;quot;github.com/astaxie/beego&amp;quot;
)

func main() {
    beego.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先beego.Run()&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;解析配置文件&lt;/li&gt;
&lt;li&gt;监听服务端口&lt;/li&gt;
&lt;li&gt;执行用户的 hookfunc，是否开启 session，是否编译模板，是否开启文档功能，是否启动管理模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;路由router&lt;/p&gt;

&lt;p&gt;引入了一个包 _ &amp;ldquo;quickstart/routers&amp;rdquo;,这个包只引入执行了里面的 init 函数&lt;/p&gt;

&lt;p&gt;路由包里面我们看到执行了路由注册 beego.Router, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 /，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑&lt;/p&gt;

&lt;p&gt;二、 路由&lt;/p&gt;

&lt;p&gt;MVC 结构执行时，beego 存在三种方式的路由:固定路由、正则路由、自动路由&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础路由&lt;/p&gt;

&lt;p&gt;beego.Get(router, beego.FilterFunc)
beego.Post(router, beego.FilterFunc)
beego.Put(router, beego.FilterFunc)
beego.Head(router, beego.FilterFunc)
beego.Options(router, beego.FilterFunc)
beego.Delete(router, beego.FilterFunc)
beego.Any(router, beego.FilterFunc)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本 GET 路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Get(&amp;quot;/&amp;quot;,func(ctx *context.Context){
     ctx.Output.Body([]byte(&amp;quot;hello world&amp;quot;))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册一个可以响应任何 HTTP 的路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Any(&amp;quot;/foo&amp;quot;,func(ctx *context.Context){
     ctx.Output.Body([]byte(&amp;quot;bar&amp;quot;))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;支持自定义的 handler 实现&lt;/p&gt;

&lt;p&gt;有些时候我们已经实现了一些 rpc 的应用,但是想要集成到 beego 中,或者其他的 httpserver 应用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s := rpc.NewServer()
s.RegisterCodec(json.NewCodec(), &amp;quot;application/json&amp;quot;)
s.RegisterService(new(HelloService), &amp;quot;&amp;quot;)
beego.Handler(&amp;quot;/rpc&amp;quot;, s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beego.Handler(router, http.Handler) 这个函数是关键,第一个参数表示路由 URI, 第二个就是你自己实现的 http.Handler, 注册之后就会把所有 rpc 作为前缀的请求分发到 http.Handler 中进行处理.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;固定路由也就是全匹配的路由&lt;/p&gt;

&lt;p&gt;beego.Router(&amp;ldquo;/&amp;rdquo;, &amp;amp;controllers.MainController{})
beego.Router(&amp;ldquo;/admin&amp;rdquo;, &amp;amp;admin.UserController{})
beego.Router(&amp;ldquo;/admin/index&amp;rdquo;, &amp;amp;admin.ArticleController{})
beego.Router(&amp;ldquo;/admin/addpkg&amp;rdquo;, &amp;amp;admin.AddController{})&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如上所示的路由就是我们最常用的路由方式，一个固定的路由，一个控制器，然后根据用户请求方法不同请求控制器中对应的方法，典型的 RESTful 方式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;正则路由&lt;/p&gt;

&lt;p&gt;beego.Router(“/api/?:id”, &amp;amp;controllers.RController{})&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;匹配 /api/123   :id = 123   可以匹配 /api/ 这个URL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Router(“/api/:id”, &amp;amp;controllers.RController{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配 /api/123   :id = 123   不可以匹配 /api/ 这个URL&lt;/p&gt;

&lt;p&gt;这样可以通过this.Ctx.Input.Param(&amp;rdquo;:id&amp;rdquo;)在controller获取url中的值。&lt;/p&gt;

&lt;p&gt;HTTP Method&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;默认方法&lt;/p&gt;

&lt;p&gt;*: 包含以下所有的函数
get: GET 请求
post: POST 请求
put: PUT 请求
delete: DELETE 请求
patch: PATCH 请求
options: OPTIONS 请求
head: HEAD 请求&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自定义方法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;请求的 method 和函数名一致，例如 GET 请求执行 Get 函数，POST 请求执行 Post 函数），如果用户期望自定义函数名，那么可以使用如下方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Router(&amp;quot;/&amp;quot;,&amp;amp;IndexController{},&amp;quot;*:Index&amp;quot;)

*表示任意的 method 都执行该函数
使用 httpmethod:funcname 格式来展示
多个不同的格式使用 ; 分割
多个 method 对应同一个 funcname，method 之间通过 , 来分割
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动匹配&lt;/p&gt;

&lt;p&gt;路由的控制器注册到自动路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.AutoRouter(&amp;amp;controllers.ObjectController{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么 beego 就会通过反射获取该结构体中所有的实现方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/object/login   调用 ObjectController 中的 Login 方法
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了前缀两个 /:controller/:method 的匹配之外，剩下的 url beego 会帮你自动化解析为参数，保存在 this.Ctx.Input.Params 当中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/object/blog/2013/09/12  调用 ObjectController 中的 Blog 方法，参数如下：map[0:2013 1:09 2:12]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解路由&lt;/p&gt;

&lt;p&gt;从 beego 1.3 版本开始支持了注解路由，用户无需在 router 中注册路由，只需要 Include 相应地 controller，然后在 controller 的 method 方法上面写上 router 注释（// @router）就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CMS API
type CMSController struct {
    beego.Controller
}

func (c *CMSController) URLMapping() {
    c.Mapping(&amp;quot;StaticBlock&amp;quot;, c.StaticBlock)
    c.Mapping(&amp;quot;AllBlock&amp;quot;, c.AllBlock)
}


// @router /staticblock/:key [get]
func (this *CMSController) StaticBlock() {

}

// @router /all/:key [get]
func (this *CMSController) AllBlock() {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在 router.go 中通过如下方式注册路由&lt;/p&gt;

&lt;p&gt;beego.Include(&amp;amp;CMSController{})&lt;/p&gt;

&lt;p&gt;beego 自动会进行源码分析，注意只会在 dev 模式下进行生成，生成的路由放在 “/routers/commentsRouter.go” 文件中。&lt;/p&gt;

&lt;p&gt;这样上面的路由就支持了如下的路由：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /staticblock/:key
GET /all/:key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实效果和自己通过 Router 函数注册是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Router(&amp;quot;/staticblock/:key&amp;quot;, &amp;amp;CMSController{}, &amp;quot;get:StaticBlock&amp;quot;)
beego.Router(&amp;quot;/all/:key&amp;quot;, &amp;amp;CMSController{}, &amp;quot;get:AllBlock&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时大家注意到新版本里面增加了 URLMapping 这个函数，这是新增加的函数，用户如果没有进行注册，那么就会通过反射来执行对应的函数，如果注册了就会通过 interface 来进行执行函数，性能上面会提升很多。&lt;/p&gt;

&lt;p&gt;namespace增加命令空间也就是在url中加一层&lt;/p&gt;

&lt;p&gt;接口如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NewNamespace(prefix string, funcs …interface{})

初始化 namespace 对象,下面这些函数都是 namespace 对象的方法,但是强烈推荐使用 NS 开头的相应函数注册，因为这样更容易通过 gofmt 工具看的更清楚路由的级别关系
NSCond(cond namespaceCond)

支持满足条件的就执行该 namespace, 不满足就不执行
NSBefore(filiterList …FilterFunc)
NSAfter(filiterList …FilterFunc)

上面分别对应 beforeRouter 和 FinishRouter 两个过滤器，可以同时注册多个过滤器
NSInclude(cList …ControllerInterface)
NSRouter(rootpath string, c ControllerInterface, mappingMethods …string)
NSGet(rootpath string, f FilterFunc)
NSPost(rootpath string, f FilterFunc)
NSDelete(rootpath string, f FilterFunc)
NSPut(rootpath string, f FilterFunc)
NSHead(rootpath string, f FilterFunc)
NSOptions(rootpath string, f FilterFunc)
NSPatch(rootpath string, f FilterFunc)
NSAny(rootpath string, f FilterFunc)
NSHandler(rootpath string, h http.Handler)
NSAutoRouter(c ControllerInterface)
NSAutoPrefix(prefix string, c ControllerInterface)

上面这些都是设置路由的函数,详细的使用和上面 beego 的对应函数是一样的
NSNamespace(prefix string, params …innnerNamespace)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、 controller&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package controllers

import (
        &amp;quot;github.com/astaxie/beego&amp;quot;
)

type MainController struct {
        beego.Controller
}

func (this *MainController) Get() {
        this.Data[&amp;quot;Website&amp;quot;] = &amp;quot;beego.me&amp;quot;
        this.Data[&amp;quot;Email&amp;quot;] = &amp;quot;astaxie@gmail.com&amp;quot;
        this.TplName = &amp;quot;index.tpl&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们声明了一个控制器 MainController，这个控制器里面内嵌了 beego.Controller，这就是 Go 的嵌入方式，也就是 MainController 自动拥有了所有 beego.Controller 的方法。&lt;/p&gt;

&lt;p&gt;beego.Controller 拥有很多方法，其中包括 Init、Prepare、Post、Get、Delete、Head 等方法。我们可以通过重写的方式来实现这些方法，而我们上面的代码就是重写了 Get 方法，没有重写就调用beego的方法。&lt;/p&gt;

&lt;p&gt;我们根据上面的路由重restful的请求中路由到这个控制器，并且执行get方法。get方法就是对业务逻辑流程的处理。&lt;/p&gt;

&lt;p&gt;this.Data这是一个用来存储输出数据的 map，可以赋值任意类型的值。可以直接用 this.Ctx.WriteString 输出字符串。&lt;/p&gt;

&lt;p&gt;最后一个就是需要去渲染的模板，this.TplName 就是需要渲染的模板，这里指定了 index.tpl，如果用户不设置该参数，那么默认会去到模板目录的 Controller/&amp;lt;方法名&amp;gt;.tpl 查找，例如上面的方法会去 maincontroller/get.tpl (文件、文件夹必须小写)。&lt;/p&gt;

&lt;p&gt;用户设置了模板之后系统会自动的调用 Render 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;beego 目前支持 INI、XML、JSON、YAML 格式的配置文件解析，但是默认采用了 INI 格式解析，用户可以通过简单的配置就可以获得很大的灵活性。&lt;/p&gt;

&lt;p&gt;eego 默认会解析当前应用下的 conf/app.conf 文件。&lt;/p&gt;

&lt;p&gt;可以直接通过beego.BConfig.AppName=&amp;ldquo;beepkg&amp;rdquo;来设置。&lt;/p&gt;

&lt;p&gt;可以通过如下的方式获取设置的配置信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.AppConfig.String(&amp;quot;mysqluser&amp;quot;)
beego.AppConfig.String(&amp;quot;mysqlpass&amp;quot;)
beego.AppConfig.String(&amp;quot;mysqlurls&amp;quot;)
beego.AppConfig.String(&amp;quot;mysqldb&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AppConfig提供好多方法需要时查阅使用。&lt;/p&gt;

&lt;p&gt;配置文件里面支持 section&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;runmode =&amp;quot;dev&amp;quot;
[dev]
httpport = 8080
[prod]
httpport = 8088
[test]
httpport = 8888
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同的runmode启动的端口不一样。&lt;/p&gt;

&lt;p&gt;INI 格式配置支持 include 方式，引用多个配置文件&lt;/p&gt;

&lt;p&gt;配置文件解析支持从环境变量中获取配置项，配置项格式：${环境变量}。&lt;/p&gt;

&lt;p&gt;配置里面的所有参数使用时可以去beego中查看，很详细。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于 beego 的 Controller 设计，只需要匿名组合 beego.Controller 就可以了，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type xxxController struct {
    beego.Controller
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beego.Controller实现了基本的方法，可以对它进行重写。&lt;/p&gt;

&lt;p&gt;可以使用 StopRun 来终止执行逻辑，可以在任意的地方执行。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;跨站请求伪造(Cross-site request forgery)， 简称为 XSRF&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;beego 有内建的 XSRF 的防范机制，要使用此机制，你需要在应用配置文件中加上 enablexsrf 设定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enablexsrf = true
xsrfkey = 61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o
xsrfexpire = 3600
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接在 main 入口处这样设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.EnableXSRF = true
beego.XSRFKEY = &amp;quot;61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o&amp;quot;
beego.XSRFExpire = 3600  //过期时间，默认1小时
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果开启了 XSRF，那么 beego 的 Web 应用将对所有用户设置一个 _xsrf 的 cookie 值（默认过期 1 小时），如果 POST PUT DELET 请求中没有这个 cookie 值，那么这个请求会被直接拒绝。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取参数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们经常需要获取用户传递的数据，包括 Get、POST 等方式的请求，beego 里面会自动解析这些数据，你可以通过如下方式获取数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GetString(key string) string
GetStrings(key string) []string
GetInt(key string) (int64, error)
GetBool(key string) (bool, error)
GetFloat(key string) (float64, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *MainController) Post() {
    jsoninfo := this.GetString(&amp;quot;jsoninfo&amp;quot;)  ----这个jsoninfo是在post请求中body中发送的字符串，还是key/value格式，key就是jsoninfo
    if jsoninfo == &amp;quot;&amp;quot; {
        this.Ctx.WriteString(&amp;quot;jsoninfo is empty&amp;quot;)
        return
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要的数据可能是其他类型的，例如是 int 类型而不是 int64，那么你需要这样处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *MainController) Post() {
    id := this.Input().Get(&amp;quot;id&amp;quot;)
    intid, err := strconv.Atoi(id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多其他的 request 的信息，用户可以通过 this.Ctx.Request 获取请求信息&lt;/p&gt;

&lt;p&gt;如果要把表单里的内容赋值到一个 struct 里，除了用上面的方法一个一个获取再赋值外，beego 提供了通过另外一个更便捷的方式，就是通过 struct 的字段名或 tag 与表单字段对应直接解析到 struct。&lt;/p&gt;

&lt;p&gt;定义 struct：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type user struct {
    Id    int         `form:&amp;quot;-&amp;quot;`
    Name  interface{} `form:&amp;quot;username&amp;quot;`
    Age   int         `form:&amp;quot;age&amp;quot;`
    Email string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;user&amp;quot;&amp;gt;
    名字：&amp;lt;input name=&amp;quot;username&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
    年龄：&amp;lt;input name=&amp;quot;age&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
    邮箱：&amp;lt;input name=&amp;quot;Email&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Controller 里解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *MainController) Post() {
    u := user{}
    if err := this.ParseForm(&amp;amp;u); err != nil {
        //handle error
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取 Request Body 里的内容&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在配置文件里设置 copyrequestbody = true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 Controller 中&lt;/p&gt;

&lt;p&gt;func (this *ObjectController) Post() {
    var ob models.Object
    json.Unmarshal(this.Ctx.Input.RequestBody, &amp;amp;ob)
}&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unmarshal和marshal就是将json和[] byte进行互换。&lt;/p&gt;

&lt;p&gt;文件上传&lt;/p&gt;

&lt;p&gt;在你的 form 表单中增加这个属性 enctype=&amp;ldquo;multipart/form-data&amp;rdquo;，否则你的浏览器不会传输你的上传文件。&lt;/p&gt;

&lt;p&gt;Beego 提供了两个很方便的方法来处理文件上传：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GetFile(key string) (multipart.File, *multipart.FileHeader, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法主要用于用户读取表单中的文件名 the_file，然后返回相应的信息，用户根据这些变量来处理文件上传：过滤、保存文件等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SaveToFile(fromfile, tofile string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法是在 GetFile 的基础上实现了快速保存的功能&lt;/p&gt;

&lt;p&gt;数据绑定-这个使用于指定的数据&lt;/p&gt;

&lt;p&gt;支持从用户请求中直接数据 bind 到指定的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;URL：?id=123&amp;amp;isok=true&amp;amp;ft=1.2&amp;amp;ol[0]=1&amp;amp;ol[1]=2&amp;amp;ul[]=str&amp;amp;ul[]=array&amp;amp;user.Name=astaxie

var id int
this.Ctx.Input.Bind(&amp;amp;id, &amp;quot;id&amp;quot;)  //id ==123

var isok bool
this.Ctx.Input.Bind(&amp;amp;isok, &amp;quot;isok&amp;quot;)  //isok ==true

var ft float64
this.Ctx.Input.Bind(&amp;amp;ft, &amp;quot;ft&amp;quot;)  //ft ==1.2

ol := make([]int, 0, 2)
this.Ctx.Input.Bind(&amp;amp;ol, &amp;quot;ol&amp;quot;)  //ol ==[1 2]

ul := make([]string, 0, 2)
this.Ctx.Input.Bind(&amp;amp;ul, &amp;quot;ul&amp;quot;)  //ul ==[str array]

user struct{Name}
this.Ctx.Input.Bind(&amp;amp;user, &amp;quot;user&amp;quot;)  //user =={Name:&amp;quot;astaxie&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;session 控制&lt;/p&gt;

&lt;p&gt;session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。&lt;/p&gt;

&lt;p&gt;当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。&lt;/p&gt;

&lt;p&gt;保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID。&lt;/p&gt;

&lt;p&gt;beego 内置了 session 模块，目前 session 模块支持的后端引擎包括 memory、cookie、file、mysql、redis、couchbase、memcache、postgres，用户也可以根据相应的 interface 实现自己的引擎。&lt;/p&gt;

&lt;p&gt;beego 中使用 session 相当方便，只要在 main 入口函数中设置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.BConfig.WebConfig.Session.SessionOn = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者通过配置文件配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sessionon = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过滤器&lt;/p&gt;

&lt;p&gt;beego 支持自定义过滤中间件，例如安全验证，强制跳转等。&lt;/p&gt;

&lt;p&gt;过滤器函数如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.InsertFilter(pattern string, postion int, filter FilterFunc, params ...bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;InsertFilter 函数的三个必填参数，一个可选参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pattern 路由规则，可以根据一定的规则进行路由，如果你全匹配可以用 *
postion 执行 Filter 的地方，四个固定参数如下，分别表示不同的执行过程
BeforeStatic 静态地址之前
BeforeRouter 寻找路由之前
BeforeExec 找到路由之后，开始执行相应的 Controller 之前
AfterExec 执行完 Controller 逻辑之后执行的过滤器
FinishRouter 执行完逻辑之后执行的过滤器
filter filter 函数 type FilterFunc func(*context.Context)
params
设置 returnOnOutput 的值(默认 true), 是否允许如果有输出是否跳过其他 filters，默认只要有输出就不再执行其他 filters
是否重置 filters 的参数，默认是 false，因为在 filters 的 pattern 和本身的路由的 pattern 冲突的时候，可以把 filters 的参数重置，这样可以保证在后续的逻辑中获取到正确的参数，例如设置了 /api/* 的 filter，同时又设置了 /api/docs/* 的 router，那么在访问 /api/docs/swagger/abc.js 的时候，在执行 filters 的时候设置 :splat 参数为 docs/swagger/abc.js，但是如果不清楚 filter 的这个路由参数，就会在执行路由逻辑的时候保持 docs/swagger/abc.js，如果设置了 true，就会重置 :splat 参数.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flash数据在两个逻辑间传递临时数据。&lt;/p&gt;

&lt;p&gt;flash 对象有三个级别的设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Notice 提示信息
Warning 警告信息
Error 错误信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;URL&lt;/p&gt;

&lt;p&gt;beego中可以匹配url 也可以通过UrlFor() 函数就是用于获取指定函数的 URL 的&lt;/p&gt;

&lt;p&gt;各种数据模式的输出&lt;/p&gt;

&lt;p&gt;JSON 数据直接输出：&lt;/p&gt;

&lt;p&gt;func (this *AddController) Get() {
    mystruct := { &amp;hellip; }
    this.Data[&amp;ldquo;json&amp;rdquo;] = &amp;amp;mystruct
    this.ServeJSON()
}
调用 ServeJSON 之后，会设置 content-type 为 application/json，然后同时把数据进行 JSON 序列化输出。
XML 数据直接输出：&lt;/p&gt;

&lt;p&gt;func (this *AddController) Get() {
    mystruct := { &amp;hellip; }
    this.Data[&amp;ldquo;xml&amp;rdquo;]=&amp;amp;mystruct
    this.ServeXML()
}
调用 ServeXML 之后，会设置 content-type 为 application/xml，同时数据会进行 XML 序列化输出。
jsonp 调用&lt;/p&gt;

&lt;p&gt;func (this *AddController) Get() {
    mystruct := { &amp;hellip; }
    this.Data[&amp;ldquo;jsonp&amp;rdquo;] = &amp;amp;mystruct
    this.ServeJSONP()
}
调用 ServeJSONP 之后，会设置 content-type 为 application/javascript，然后同时把数据进行 JSON 序列化，然后根据请求的 callback 参数设置 jsonp 输出。&lt;/p&gt;

&lt;p&gt;validation表单验证&lt;/p&gt;

&lt;p&gt;获取包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/astaxie/beego/validation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常通过 StructTag 使用，也可以直接用对应函数使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type user struct {
    Id     int
    Name   string `valid:&amp;quot;Required;Match(/^Bee.*/)&amp;quot;` // Name 不能为空并且以 Bee 开头
    Age    int    `valid:&amp;quot;Range(1, 140)&amp;quot;` // 1 &amp;lt;= Age &amp;lt;= 140，超出此范围即为不合法
    Email  string `valid:&amp;quot;Email; MaxSize(100)&amp;quot;` // Email 字段需要符合邮箱格式，并且最大长度不能大于 100 个字符
    Mobile string `valid:&amp;quot;Mobile&amp;quot;` // Mobile 必须为正确的手机号
    IP     string `valid:&amp;quot;IP&amp;quot;` // IP 必须为一个正确的 IPv4 地址
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StructTag 可用的验证函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Required 不为空，即各个类型要求不为其零值
Min(min int) 最小值，有效类型：int，其他类型都将不能通过验证)
Max(max int) 最大值，有效类型：int，其他类型都将不能通过验证
Range(min, max int) 数值的范围，有效类型：int，他类型都将不能通过验证
MinSize(min int) 最小长度，有效类型：string slice，其他类型都将不能通过验证
MaxSize(max int) 最大长度，有效类型：string slice，其他类型都将不能通过验证
Length(length int) 指定长度，有效类型：string slice，其他类型都将不能通过验证
Alpha alpha字符，有效类型：string，其他类型都将不能通过验证
Numeric 数字，有效类型：string，其他类型都将不能通过验证
AlphaNumeric alpha 字符或数字，有效类型：string，其他类型都将不能通过验证
Match(pattern string) 正则匹配，有效类型：string，其他类型都将被转成字符串再匹配(fmt.Sprintf(“%v”, obj).Match)
AlphaDash alpha 字符或数字或横杠 -_，有效类型：string，其他类型都将不能通过验证
Email 邮箱格式，有效类型：string，其他类型都将不能通过验证
IP IP 格式，目前只支持 IPv4 格式验证，有效类型：string，其他类型都将不能通过验证
Base64 base64 编码，有效类型：string，其他类型都将不能通过验证
Mobile 手机号，有效类型：string，其他类型都将不能通过验证
Tel 固定电话号，有效类型：string，其他类型都将不能通过验证
Phone 手机号或固定电话号，有效类型：string，其他类型都将不能通过验证
ZipCode 邮政编码，有效类型：string，其他类型都将不能通过验证
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误处理&lt;/p&gt;

&lt;p&gt;跳转&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *AddController) Get() {
    this.Redirect(&amp;quot;/&amp;quot;, 302)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中止&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.Abort(&amp;quot;401&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beego 框架默认支持 401、403、404、500、503 这几种错误的处理。用户可以自定义相应的错误处理，例如下面重新定义 404 页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func page_not_found(rw http.ResponseWriter, r *http.Request){
    t,_:= template.New(&amp;quot;404.html&amp;quot;).ParseFiles(beego.ViewsPath+&amp;quot;/404.html&amp;quot;)
    data :=make(map[string]interface{})
    data[&amp;quot;content&amp;quot;] = &amp;quot;page not found&amp;quot;
    t.Execute(rw, data)
}

func main() {
    beego.ErrorHandler(&amp;quot;404&amp;quot;,page_not_found)
    beego.Router(&amp;quot;/&amp;quot;, &amp;amp;controllers.MainController{})
    beego.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 1.4.3 版本开始，支持 Controller 方式定义 Error 错误处理函数，这样就可以充分利用系统自带的模板处理，以及 context 等方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package controllers

import (
    &amp;quot;github.com/astaxie/beego&amp;quot;
)

type ErrorController struct {
    beego.Controller
}

func (c *ErrorController) Error404() {
    c.Data[&amp;quot;content&amp;quot;] = &amp;quot;page not found&amp;quot;
    c.TplName = &amp;quot;404.tpl&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的例子我们可以看到，所有的函数都是有一定规律的，都是 Error 开头，后面的名字就是我们调用 Abort 的名字，例如 Error404 函数其实调用对应的就是 Abort(&amp;ldquo;404&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;我们就只要在 beego.Run 之前采用 beego.ErrorController 注册这个错误处理函数就可以了&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import (
    _ &amp;quot;btest/routers&amp;quot;
    &amp;quot;btest/controllers&amp;quot;

    &amp;quot;github.com/astaxie/beego&amp;quot;
)

func main() {
    beego.ErrorController(&amp;amp;controllers.ErrorController{})
    beego.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;日志处理&lt;/p&gt;

&lt;p&gt;beego 的日志处理是基于 logs 模块搭建的，内置了一个变量 BeeLogger，默认已经是 logs.BeeLogger 类型，初始化了 console，也就是默认输出到 console。&lt;/p&gt;

&lt;p&gt;一般在程序中我们使用如下的方式进行输出：&lt;/p&gt;

&lt;p&gt;beego.Emergency(&amp;ldquo;this is emergency&amp;rdquo;)
beego.Alert(&amp;ldquo;this is alert&amp;rdquo;)
beego.Critical(&amp;ldquo;this is critical&amp;rdquo;)
beego.Error(&amp;ldquo;this is error&amp;rdquo;)
beego.Warning(&amp;ldquo;this is warning&amp;rdquo;)
beego.Notice(&amp;ldquo;this is notice&amp;rdquo;)
beego.Informational(&amp;ldquo;this is informational&amp;rdquo;)
beego.Debug(&amp;ldquo;this is debug&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;设置输出到文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.SetLogger(&amp;quot;file&amp;quot;, `{&amp;quot;filename&amp;quot;:&amp;quot;logs/test.log&amp;quot;}`)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个默认情况就会同时输出到两个地方，一个 console，一个 file，如果只想输出到文件，就需要调用删除操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.BeeLogger.DelLogger(&amp;quot;console&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过设置级别设置日志级别&lt;/p&gt;

&lt;p&gt;beego.SetLevel(beego.LevelInformational)&lt;/p&gt;

&lt;p&gt;日志的级别如上所示的代码这样分为八个级别：&lt;/p&gt;

&lt;p&gt;LevelEmergency
LevelAlert
LevelCritical
LevelError
LevelWarning
LevelNotice
LevelInformational
LevelDebug&lt;/p&gt;

&lt;p&gt;输出文件名和行号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.SetLogFuncCall(true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启传入参数 true, 关闭传入参数 false, 默认是关闭的.&lt;/p&gt;

&lt;p&gt;四、 Model&lt;/p&gt;

&lt;p&gt;Model 就是逐步抽象的过程，一般我们会在 Model 里面处理一些数据读取。在beego中主要是orm。&lt;/p&gt;

&lt;p&gt;ORM 使用方法&lt;/p&gt;

&lt;p&gt;目前 ORM 支持三种数据库，以下为测试过的 driver&lt;/p&gt;

&lt;p&gt;将你需要使用的 driver 加入 import 中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import (
    _ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
    _ &amp;quot;github.com/lib/pq&amp;quot;
    _ &amp;quot;github.com/mattn/go-sqlite3&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注册&lt;/p&gt;

&lt;p&gt;orm.RegisterDriver(&amp;ldquo;mysql&amp;rdquo;, orm.DRMySQL)&lt;/p&gt;

&lt;p&gt;// For version 1.6
orm.DRMySQL
orm.DRSqlite
orm.DRPostgres&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mysql / sqlite3 / postgres 这三种是默认已经注册过的，所以可以无需设置&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ORM 必须注册一个别名为 default 的数据库，作为默认使用。&lt;/p&gt;

&lt;p&gt;ORM 使用 golang 自己的连接池&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 参数1        数据库的别名，用来在 ORM 中切换数据库使用
// 参数2        driverName
// 参数3        对应的链接字符串
orm.RegisterDataBase(&amp;quot;default&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_test?charset=utf8&amp;quot;)

// 参数4(可选)  设置最大空闲连接
// 参数5(可选)  设置最大数据库连接 (go &amp;gt;= 1.2)
maxIdle := 30
maxConn := 30
orm.RegisterDataBase(&amp;quot;default&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_test?charset=utf8&amp;quot;, maxIdle, maxConn)


根据数据库的别名，设置数据库的最大空闲连接

orm.SetMaxIdleConns(&amp;quot;default&amp;quot;, 30)

根据数据库的别名，设置数据库的最大数据库连接 (go &amp;gt;= 1.2)

orm.SetMaxOpenConns(&amp;quot;default&amp;quot;, 30)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册模型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;orm.RegisterModel(new(User), new(Profile), new(Post))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将你定义的 Model 进行注册，最佳设计是有单独的 models.go 文件，在他的 init 函数中进行注册。&lt;/p&gt;

&lt;p&gt;使用表名前缀&lt;/p&gt;

&lt;p&gt;orm.RegisterModelWithPrefix(&amp;ldquo;prefix_&amp;ldquo;, new(User))
创建后的表名为 prefix_user&lt;/p&gt;

&lt;p&gt;从已注册的数据库返回 *sql.DB 对象，默认返回别名为 default 的数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db, err := orm.GetDB()
if err != nil {
    fmt.Println(&amp;quot;get default DataBase&amp;quot;)
}

db, err := orm.GetDB(&amp;quot;alias&amp;quot;)
if err != nil {
    fmt.Println(&amp;quot;get alias DataBase&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用&lt;/p&gt;

&lt;p&gt;var o Ormer
o = orm.NewOrm() // 创建一个 Ormer
// NewOrm 的同时会执行 orm.BootStrap (整个 app 只执行一次)，用以验证模型之间的定义并缓存。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;切换数据库，或者，进行事务处理，都会作用于这个 Ormer 对象，以及其进行的任何查询。&lt;/p&gt;

&lt;p&gt;ormer对象提供了封装好的操作方法&lt;/p&gt;

&lt;p&gt;QueryTable&lt;/p&gt;

&lt;p&gt;传入表名，或者 Model 对象，返回一个 QuerySeter&lt;/p&gt;

&lt;p&gt;o := orm.NewOrm()&lt;/p&gt;

&lt;p&gt;// 获取 QuerySeter 对象，user 为表名
qs := o.QueryTable(&amp;ldquo;user&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// 也可以直接使用对象作为表名
user := new(User)
qs = o.QueryTable(user) // 返回 QuerySeter&lt;/p&gt;

&lt;p&gt;Using&lt;/p&gt;

&lt;p&gt;切换为其他数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;orm.RegisterDataBase(&amp;quot;db1&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_db2?charset=utf8&amp;quot;)
orm.RegisterDataBase(&amp;quot;db2&amp;quot;, &amp;quot;sqlite3&amp;quot;, &amp;quot;data.db&amp;quot;)

o1 := orm.NewOrm()
o1.Using(&amp;quot;db1&amp;quot;)

o2 := orm.NewOrm()
o2.Using(&amp;quot;db2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认使用 default 数据库，无需调用 Using&lt;/p&gt;

&lt;p&gt;Raw&lt;/p&gt;

&lt;p&gt;使用 sql 语句直接进行操作&lt;/p&gt;

&lt;p&gt;Raw 函数，返回一个 RawSeter 用以对设置的 sql 语句和参数进行操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := NewOrm()
var r RawSeter
r = o.Raw(&amp;quot;UPDATE user SET name = ? WHERE name = ?&amp;quot;, &amp;quot;testing&amp;quot;, &amp;quot;slene&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Driver&lt;/p&gt;

&lt;p&gt;返回当前 ORM 使用的 db 信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Driver interface {
    Name() string
    Type() DriverType
}

orm.RegisterDataBase(&amp;quot;db1&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_db2?charset=utf8&amp;quot;)
orm.RegisterDataBase(&amp;quot;db2&amp;quot;, &amp;quot;sqlite3&amp;quot;, &amp;quot;data.db&amp;quot;)

o1 := orm.NewOrm()
o1.Using(&amp;quot;db1&amp;quot;)
dr := o1.Driver()
fmt.Println(dr.Name() == &amp;quot;db1&amp;quot;) // true
fmt.Println(dr.Type() == orm.DRMySQL) // true

o2 := orm.NewOrm()
o2.Using(&amp;quot;db2&amp;quot;)
dr = o2.Driver()
fmt.Println(dr.Name() == &amp;quot;db2&amp;quot;) // true
fmt.Println(dr.Type() == orm.DRSqlite) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调试模式打印查询语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;orm.Debug = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CRUD&lt;/p&gt;

&lt;p&gt;如果已知主键的值，那么可以使用这些方法进行 CRUD 操作&lt;/p&gt;

&lt;p&gt;Read&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := orm.NewOrm()
user := User{Id: 1}

err = o.Read(&amp;amp;user)

if err == orm.ErrNoRows {
    fmt.Println(&amp;quot;查询不到&amp;quot;)
} else if err == orm.ErrMissPK {
    fmt.Println(&amp;quot;找不到主键&amp;quot;)
} else {
    fmt.Println(user.Id, user.Name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read 默认通过查询主键赋值，可以使用指定的字段进行查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user := User{Name: &amp;quot;slene&amp;quot;}
err = o.Read(&amp;amp;user, &amp;quot;Name&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReadOrCreate&lt;/p&gt;

&lt;p&gt;尝试从数据库读取，不存在的话就创建一个&lt;/p&gt;

&lt;p&gt;Insert&lt;/p&gt;

&lt;p&gt;第一个返回值为自增健 Id 的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := orm.NewOrm()
var user User
user.Name = &amp;quot;slene&amp;quot;
user.IsActive = true

id, err := o.Insert(&amp;amp;user)
if err == nil {
    fmt.Println(id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建后会自动对 auto 的 field 赋值&lt;/p&gt;

&lt;p&gt;InsertMulti&lt;/p&gt;

&lt;p&gt;同时插入多个对象&lt;/p&gt;

&lt;p&gt;类似sql语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insert into table (name, age) values(&amp;quot;slene&amp;quot;, 28),(&amp;quot;astaxie&amp;quot;, 30),(&amp;quot;unknown&amp;quot;, 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数 bulk 为并列插入的数量，第二个为对象的slice&lt;/p&gt;

&lt;p&gt;返回值为成功插入的数量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;users := []User{
    {Name: &amp;quot;slene&amp;quot;},
    {Name: &amp;quot;astaxie&amp;quot;},
    {Name: &amp;quot;unknown&amp;quot;},
    ...
}
successNums, err := o.InsertMulti(100, users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bulk 为 1 时，将会顺序插入 slice 中的数据&lt;/p&gt;

&lt;p&gt;Update&lt;/p&gt;

&lt;p&gt;第一个返回值为影响的行数&lt;/p&gt;

&lt;p&gt;o := orm.NewOrm()
user := User{Id: 1}
if o.Read(&amp;amp;user) == nil {
    user.Name = &amp;ldquo;MyName&amp;rdquo;
    if num, err := o.Update(&amp;amp;user); err == nil {
        fmt.Println(num)
    }
}
Update 默认更新所有的字段，可以更新指定的字段：&lt;/p&gt;

&lt;p&gt;// 只更新 Name
o.Update(&amp;amp;user, &amp;ldquo;Name&amp;rdquo;)
// 指定多个字段
// o.Update(&amp;amp;user, &amp;ldquo;Field1&amp;rdquo;, &amp;ldquo;Field2&amp;rdquo;, &amp;hellip;)&lt;/p&gt;

&lt;p&gt;Delete&lt;/p&gt;

&lt;p&gt;第一个返回值为影响的行数&lt;/p&gt;

&lt;p&gt;o := orm.NewOrm()
if num, err := o.Delete(&amp;amp;User{Id: 1}); err == nil {
    fmt.Println(num)
}&lt;/p&gt;

&lt;p&gt;expr&lt;/p&gt;

&lt;p&gt;User 表查询对应的 Profile.Age 为条件，则使用 Profile__Age 注意，字段的分隔符号使用双下划线 &lt;strong&gt;，除了描述字段， expr 的尾部可以增加操作符以执行对应的 sql 操作。比如 Profile&lt;/strong&gt;Age__gt 代表 Profile.Age &amp;gt; 18 的条件查询。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;id&amp;quot;, 1) // WHERE id = 1
qs.Filter(&amp;quot;profile__age&amp;quot;, 18) // WHERE profile.age = 18
qs.Filter(&amp;quot;Profile__Age&amp;quot;, 18) // 使用字段名和 Field 名都是允许的
qs.Filter(&amp;quot;profile__age&amp;quot;, 18) // WHERE profile.age = 18
qs.Filter(&amp;quot;profile__age__gt&amp;quot;, 18) // WHERE profile.age &amp;gt; 18
qs.Filter(&amp;quot;profile__age__gte&amp;quot;, 18) // WHERE profile.age &amp;gt;= 18
qs.Filter(&amp;quot;profile__age__in&amp;quot;, 18, 20) // WHERE profile.age IN (18, 20)

qs.Filter(&amp;quot;profile__age__in&amp;quot;, 18, 20).Exclude(&amp;quot;profile__lt&amp;quot;, 1000)
// WHERE profile.age IN (18, 20) AND NOT profile_id &amp;lt; 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operators&lt;/p&gt;

&lt;p&gt;exact&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name&amp;quot;, &amp;quot;slene&amp;quot;) // WHERE name = &#39;slene&#39;
qs.Filter(&amp;quot;name__exact&amp;quot;, &amp;quot;slene&amp;quot;) // WHERE name = &#39;slene&#39;

// 使用 = 匹配，大小写是否敏感取决于数据表使用的 collation

qs.Filter(&amp;quot;profile_id&amp;quot;, nil) // WHERE profile_id IS NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iexact&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__iexact&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;slene&#39;
// 大小写不敏感，匹配任意 &#39;Slene&#39; &#39;sLENE&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contains&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__contains&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE BINARY &#39;%slene%&#39;
// 大小写敏感, 匹配包含 slene 的字符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;icontains&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__icontains&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;%slene%&#39;
// 大小写不敏感, 匹配任意 &#39;im Slene&#39;, &#39;im sLENE&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__age__in&amp;quot;, 17, 18, 19, 20)
// WHERE profile.age IN (17, 18, 19, 20)


ids:=[]int{17,18,19,20}
qs.Filter(&amp;quot;profile__age__in&amp;quot;, ids)
// WHERE profile.age IN (17, 18, 19, 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gt / gte&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__age__gt&amp;quot;, 17)
// WHERE profile.age &amp;gt; 17

qs.Filter(&amp;quot;profile__age__gte&amp;quot;, 18)
// WHERE profile.age &amp;gt;= 18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lt / lte&lt;/p&gt;

&lt;p&gt;qs.Filter(&amp;ldquo;profile&lt;strong&gt;age&lt;/strong&gt;lt&amp;rdquo;, 17)
    // WHERE profile.age &amp;lt; 17&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__age__lte&amp;quot;, 18)
// WHERE profile.age &amp;lt;= 18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;startswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__startswith&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE BINARY &#39;slene%&#39;
// 大小写敏感, 匹配以 &#39;slene&#39; 起始的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;istartswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__istartswith&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;slene%&#39;
// 大小写不敏感, 匹配任意以 &#39;slene&#39;, &#39;Slene&#39; 起始的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;endswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__endswith&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE BINARY &#39;%slene&#39;
// 大小写敏感, 匹配以 &#39;slene&#39; 结束的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iendswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__iendswithi&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;%slene&#39;
// 大小写不敏感, 匹配任意以 &#39;slene&#39;, &#39;Slene&#39; 结束的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isnull&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__isnull&amp;quot;, true)
qs.Filter(&amp;quot;profile_id__isnull&amp;quot;, true)
// WHERE profile_id IS NULL

qs.Filter(&amp;quot;profile__isnull&amp;quot;, false)
// WHERE profile_id IS NOT NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QuerySeter高级查询接口&lt;/p&gt;

&lt;p&gt;Filter&lt;/p&gt;

&lt;p&gt;用来过滤查询结果，起到 包含条件 的作用&lt;/p&gt;

&lt;p&gt;多个 Filter 之间使用 AND 连接&lt;/p&gt;

&lt;p&gt;qs.Filter(&amp;ldquo;profile__isnull&amp;rdquo;, true).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;)
// WHERE profile_id IS NULL AND name = &amp;lsquo;slene&amp;rsquo;
Exclude&lt;/p&gt;

&lt;p&gt;用来过滤查询结果，起到 排除条件 的作用&lt;/p&gt;

&lt;p&gt;使用 NOT 排除条件&lt;/p&gt;

&lt;p&gt;多个 Exclude 之间使用 AND 连接&lt;/p&gt;

&lt;p&gt;qs.Exclude(&amp;ldquo;profile__isnull&amp;rdquo;, true).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;)
// WHERE NOT profile_id IS NULL AND name = &amp;lsquo;slene&amp;rsquo;
SetCond&lt;/p&gt;

&lt;p&gt;自定义条件表达式&lt;/p&gt;

&lt;p&gt;cond := orm.NewCondition()
cond1 := cond.And(&amp;ldquo;profile&lt;strong&gt;isnull&amp;rdquo;, false).AndNot(&amp;ldquo;status&lt;/strong&gt;in&amp;rdquo;, 1).Or(&amp;ldquo;profile&lt;strong&gt;age&lt;/strong&gt;gt&amp;rdquo;, 2000)&lt;/p&gt;

&lt;p&gt;qs := orm.QueryTable(&amp;ldquo;user&amp;rdquo;)
qs = qs.SetCond(cond1)
// WHERE &amp;hellip; AND &amp;hellip; AND NOT &amp;hellip; OR &amp;hellip;&lt;/p&gt;

&lt;p&gt;cond2 := cond.AndCond(cond1).OrCond(cond.And(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;))
qs = qs.SetCond(cond2).Count()
// WHERE (&amp;hellip; AND &amp;hellip; AND NOT &amp;hellip; OR &amp;hellip;) OR ( &amp;hellip; )
Limit&lt;/p&gt;

&lt;p&gt;限制最大返回数据行数，第二个参数可以设置 Offset&lt;/p&gt;

&lt;p&gt;var DefaultRowsLimit = 1000 // ORM 默认的 limit 值为 1000&lt;/p&gt;

&lt;p&gt;// 默认情况下 select 查询的最大行数为 1000
// LIMIT 1000&lt;/p&gt;

&lt;p&gt;qs.Limit(10)
// LIMIT 10&lt;/p&gt;

&lt;p&gt;qs.Limit(10, 20)
// LIMIT 10 OFFSET 20 注意跟 SQL 反过来的&lt;/p&gt;

&lt;p&gt;qs.Limit(-1)
// no limit&lt;/p&gt;

&lt;p&gt;qs.Limit(-1, 100)
// LIMIT 18446744073709551615 OFFSET 100
// 18446744073709551615 是 1&amp;lt;&amp;lt;64 - 1 用来指定无 limit 限制 但有 offset 偏移的情况
Offset&lt;/p&gt;

&lt;p&gt;设置 偏移行数&lt;/p&gt;

&lt;p&gt;qs.Offset(20)
// LIMIT 1000 OFFSET 20
GroupBy&lt;/p&gt;

&lt;p&gt;qs.GroupBy(&amp;ldquo;id&amp;rdquo;, &amp;ldquo;age&amp;rdquo;)
// GROUP BY id,age
OrderBy&lt;/p&gt;

&lt;p&gt;参数使用 expr&lt;/p&gt;

&lt;p&gt;在 expr 前使用减号 - 表示 DESC 的排列&lt;/p&gt;

&lt;p&gt;qs.OrderBy(&amp;ldquo;id&amp;rdquo;, &amp;ldquo;-profile__age&amp;rdquo;)
// ORDER BY id ASC, profile.age DESC&lt;/p&gt;

&lt;p&gt;qs.OrderBy(&amp;ldquo;-profile__age&amp;rdquo;, &amp;ldquo;profile&amp;rdquo;)
// ORDER BY profile.age DESC, profile_id ASC
Distinct&lt;/p&gt;

&lt;p&gt;对应 sql 的 distinct 语句, 返回不重复的值.&lt;/p&gt;

&lt;p&gt;qs.Distinct()
// SELECT DISTINCT
RelatedSel&lt;/p&gt;

&lt;p&gt;关系查询，参数使用 expr&lt;/p&gt;

&lt;p&gt;var DefaultRelsDepth = 5 // 默认情况下直接调用 RelatedSel 将进行最大 5 层的关系查询&lt;/p&gt;

&lt;p&gt;qs := o.QueryTable(&amp;ldquo;post&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;qs.RelatedSel()
// INNER JOIN user &amp;hellip; LEFT OUTER JOIN profile &amp;hellip;&lt;/p&gt;

&lt;p&gt;qs.RelatedSel(&amp;ldquo;user&amp;rdquo;)
// INNER JOIN user &amp;hellip;
// 设置 expr 只对设置的字段进行关系查询&lt;/p&gt;

&lt;p&gt;// 对设置 null 属性的 Field 将使用 LEFT OUTER JOIN
Count&lt;/p&gt;

&lt;p&gt;依据当前的查询条件，返回结果行数&lt;/p&gt;

&lt;p&gt;cnt, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Count() // SELECT COUNT(*) FROM USER
fmt.Printf(&amp;ldquo;Count Num: %s, %s&amp;rdquo;, cnt, err)
Exist&lt;/p&gt;

&lt;p&gt;exist := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;UserName&amp;rdquo;, &amp;ldquo;Name&amp;rdquo;).Exist()
fmt.Printf(&amp;ldquo;Is Exist: %s&amp;rdquo;, exist)
Update&lt;/p&gt;

&lt;p&gt;依据当前查询条件，进行批量更新操作&lt;/p&gt;

&lt;p&gt;num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).Update(orm.Params{
    &amp;ldquo;name&amp;rdquo;: &amp;ldquo;astaxie&amp;rdquo;,
})
fmt.Printf(&amp;ldquo;Affected Num: %s, %s&amp;rdquo;, num, err)
// SET name = &amp;ldquo;astaixe&amp;rdquo; WHERE name = &amp;ldquo;slene&amp;rdquo;
原子操作增加字段值&lt;/p&gt;

&lt;p&gt;// 假设 user struct 里有一个 nums int 字段
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Update(orm.Params{
    &amp;ldquo;nums&amp;rdquo;: orm.ColValue(orm.ColAdd, 100),
})
// SET nums = nums + 100
orm.ColValue 支持以下操作&lt;/p&gt;

&lt;p&gt;ColAdd      // 加
ColMinus    // 减
ColMultiply // 乘
ColExcept   // 除
Delete&lt;/p&gt;

&lt;p&gt;依据当前查询条件，进行批量删除操作&lt;/p&gt;

&lt;p&gt;num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).Delete()
fmt.Printf(&amp;ldquo;Affected Num: %s, %s&amp;rdquo;, num, err)
// DELETE FROM user WHERE name = &amp;ldquo;slene&amp;rdquo;
PrepareInsert&lt;/p&gt;

&lt;p&gt;用于一次 prepare 多次 insert 插入，以提高批量插入的速度。&lt;/p&gt;

&lt;p&gt;var users []*User
&amp;hellip;
qs := o.QueryTable(&amp;ldquo;user&amp;rdquo;)
i, _ := qs.PrepareInsert()
for _, user := range users {
    id, err := i.Insert(user)
    if err == nil {
        &amp;hellip;
    }
}
// PREPARE INSERT INTO user (&lt;code&gt;name&lt;/code&gt;, &amp;hellip;) VALUES (?, &amp;hellip;)
// EXECUTE INSERT INTO user (&lt;code&gt;name&lt;/code&gt;, &amp;hellip;) VALUES (&amp;ldquo;slene&amp;rdquo;, &amp;hellip;)
// EXECUTE &amp;hellip;
// &amp;hellip;
i.Close() // 别忘记关闭 statement
All&lt;/p&gt;

&lt;p&gt;返回对应的结果集对象&lt;/p&gt;

&lt;p&gt;All 的参数支持 *[]Type 和 *[]*Type 两种形式的 slice&lt;/p&gt;

&lt;p&gt;var users []*User
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).All(&amp;amp;users)
fmt.Printf(&amp;ldquo;Returned Rows Num: %s, %s&amp;rdquo;, num, err)
All / Values / ValuesList / ValuesFlat 受到 Limit 的限制，默认最大行数为 1000&lt;/p&gt;

&lt;p&gt;可以指定返回的字段：&lt;/p&gt;

&lt;p&gt;type Post struct {
    Id      int
    Title   string
    Content string
    Status  int
}&lt;/p&gt;

&lt;p&gt;// 只返回 Id 和 Title
var posts []Post
o.QueryTable(&amp;ldquo;post&amp;rdquo;).Filter(&amp;ldquo;Status&amp;rdquo;, 1).All(&amp;amp;posts, &amp;ldquo;Id&amp;rdquo;, &amp;ldquo;Title&amp;rdquo;)
对象的其他字段值将会是对应类型的默认值&lt;/p&gt;

&lt;p&gt;One&lt;/p&gt;

&lt;p&gt;尝试返回单条记录&lt;/p&gt;

&lt;p&gt;var user User
err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).One(&amp;amp;user)
if err == orm.ErrMultiRows {
    // 多条的时候报错
    fmt.Printf(&amp;ldquo;Returned Multi Rows Not One&amp;rdquo;)
}
if err == orm.ErrNoRows {
    // 没有找到记录
    fmt.Printf(&amp;ldquo;Not row found&amp;rdquo;)
}
可以指定返回的字段：&lt;/p&gt;

&lt;p&gt;// 只返回 Id 和 Title
var post Post
o.QueryTable(&amp;ldquo;post&amp;rdquo;).Filter(&amp;ldquo;Content__istartswith&amp;rdquo;, &amp;ldquo;prefix string&amp;rdquo;).One(&amp;amp;post, &amp;ldquo;Id&amp;rdquo;, &amp;ldquo;Title&amp;rdquo;)
对象的其他字段值将会是对应类型的默认值&lt;/p&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;p&gt;返回结果集的 key =&amp;gt; value 值&lt;/p&gt;

&lt;p&gt;key 为 Model 里的 Field name，value 的值 以 string 保存&lt;/p&gt;

&lt;p&gt;var maps []orm.Params
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Values(&amp;amp;maps)
if err == nil {
    fmt.Printf(&amp;ldquo;Result Nums: %d\n&amp;rdquo;, num)
    for _, m := range maps {
        fmt.Println(m[&amp;ldquo;Id&amp;rdquo;], m[&amp;ldquo;Name&amp;rdquo;])
    }
}
返回指定的 Field 数据&lt;/p&gt;

&lt;p&gt;TODO: 暂不支持级联查询 RelatedSel 直接返回 Values&lt;/p&gt;

&lt;p&gt;但可以直接指定 expr 级联返回需要的数据&lt;/p&gt;

&lt;p&gt;var maps []orm.Params
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Values(&amp;amp;maps, &amp;ldquo;id&amp;rdquo;, &amp;ldquo;name&amp;rdquo;, &amp;ldquo;profile&amp;rdquo;, &amp;ldquo;profile&lt;strong&gt;age&amp;rdquo;)
if err == nil {
    fmt.Printf(&amp;ldquo;Result Nums: %d\n&amp;rdquo;, num)
    for _, m := range maps {
        fmt.Println(m[&amp;ldquo;Id&amp;rdquo;], m[&amp;ldquo;Name&amp;rdquo;], m[&amp;ldquo;Profile&amp;rdquo;], m[&amp;ldquo;Profile&lt;/strong&gt;Age&amp;rdquo;])
        // map 中的数据都是展开的，没有复杂的嵌套
    }
}&lt;/p&gt;

&lt;p&gt;ValuesList&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;顾名思义，返回的结果集以slice存储

结果的排列与 Model 中定义的 Field 顺序一致

返回的每个元素值以 string 保存

var lists []orm.ParamsList
num, err := o.QueryTable(&amp;quot;user&amp;quot;).ValuesList(&amp;amp;lists)
if err == nil {
    fmt.Printf(&amp;quot;Result Nums: %d\n&amp;quot;, num)
    for _, row := range lists {
        fmt.Println(row)
    }
}
当然也可以指定 expr 返回指定的 Field

var lists []orm.ParamsList
num, err := o.QueryTable(&amp;quot;user&amp;quot;).ValuesList(&amp;amp;lists, &amp;quot;name&amp;quot;, &amp;quot;profile__age&amp;quot;)
if err == nil {
    fmt.Printf(&amp;quot;Result Nums: %d\n&amp;quot;, num)
    for _, row := range lists {
        fmt.Printf(&amp;quot;Name: %s, Age: %s\m&amp;quot;, row[0], row[1])
    }
}
ValuesFlat

只返回特定的 Field 值，将结果集展开到单个 slice 里

var list orm.ParamsList
num, err := o.QueryTable(&amp;quot;user&amp;quot;).ValuesFlat(&amp;amp;list, &amp;quot;name&amp;quot;)
if err == nil {
    fmt.Printf(&amp;quot;Result Nums: %d\n&amp;quot;, num)
    fmt.Printf(&amp;quot;All User Names: %s&amp;quot;, strings.Join(list, &amp;quot;, &amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关联查询&lt;/p&gt;

&lt;p&gt;使用具体的sql语句查询&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 Raw SQL 查询，无需使用 ORM 表定义&lt;/li&gt;
&lt;li&gt;多数据库，都可直接使用占位符号 ?，自动转换&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查询时的参数，支持使用 Model Struct 和 Slice, Array&lt;/p&gt;

&lt;p&gt;ids := []int{1, 2, 3}
p.Raw(&amp;ldquo;SELECT name FROM user WHERE id IN (?, ?, ?)&amp;rdquo;, ids)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;返回一个 RawSeter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := orm.NewOrm()
var r RawSeter
r = o.Raw(&amp;quot;UPDATE user SET name = ? WHERE name = ?&amp;quot;, &amp;quot;testing&amp;quot;, &amp;quot;slene&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exec&lt;/p&gt;

&lt;p&gt;执行 sql 语句，返回 sql.Result 对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res, err := o.Raw(&amp;quot;UPDATE user SET name = ?&amp;quot;, &amp;quot;your&amp;quot;).Exec()
if err == nil {
    num, _ := res.RowsAffected()
    fmt.Println(&amp;quot;mysql row affected nums: &amp;quot;, num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QueryRow&lt;/p&gt;

&lt;p&gt;QueryRow 和 QueryRows 提供高级 sql mapper 功能&lt;/p&gt;

&lt;p&gt;支持 struct&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
    Id       int
    UserName string
}

var user User
err := o.Raw(&amp;quot;SELECT id, user_name FROM user WHERE id = ?&amp;quot;, 1).QueryRow(&amp;amp;user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;from beego 1.1.0 取消了多个对象支持&lt;/p&gt;

&lt;p&gt;QueryRows&lt;/p&gt;

&lt;p&gt;QueryRows 支持的对象还有 map 规则是和 QueryRow 一样的，但都是 slice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
    Id       int
    UserName string
}

var users []User
num, err := o.Raw(&amp;quot;SELECT id, user_name FROM user WHERE id = ?&amp;quot;, 1).QueryRows(&amp;amp;users)
if err == nil {
    fmt.Println(&amp;quot;user nums: &amp;quot;, num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;from beego 1.1.0 取消了多个对象支持&lt;/p&gt;

&lt;p&gt;SetArgs&lt;/p&gt;

&lt;p&gt;改变 Raw(sql, args…) 中的 args 参数，返回一个新的 RawSeter&lt;/p&gt;

&lt;p&gt;用于单条 sql 语句，重复利用，替换参数然后执行。&lt;/p&gt;

&lt;p&gt;res, err := r.SetArgs(&amp;ldquo;arg1&amp;rdquo;, &amp;ldquo;arg2&amp;rdquo;).Exec()
res, err := r.SetArgs(&amp;ldquo;arg1&amp;rdquo;, &amp;ldquo;arg2&amp;rdquo;).Exec()&lt;/p&gt;

&lt;p&gt;Values / ValuesList / ValuesFlat&lt;/p&gt;

&lt;p&gt;Raw SQL 查询获得的结果集 Value 为 string 类型，NULL 字段的值为空 ``&lt;/p&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;p&gt;返回结果集的 key =&amp;gt; value 值&lt;/p&gt;

&lt;p&gt;var maps []orm.Params
num, err = o.Raw(&amp;ldquo;SELECT user_name FROM user WHERE status = ?&amp;ldquo;, 1).Values(&amp;amp;maps)
if err == nil &amp;amp;&amp;amp; num &amp;gt; 0 {
    fmt.Println(maps[0][&amp;ldquo;user_name&amp;rdquo;]) // slene
}&lt;/p&gt;

&lt;p&gt;ValuesList&lt;/p&gt;

&lt;p&gt;返回结果集 slice&lt;/p&gt;

&lt;p&gt;var lists []orm.ParamsList
num, err = o.Raw(&amp;ldquo;SELECT user_name FROM user WHERE status = ?&amp;ldquo;, 1).ValuesList(&amp;amp;lists)
if err == nil &amp;amp;&amp;amp; num &amp;gt; 0 {
    fmt.Println(lists[0][0]) // slene
}&lt;/p&gt;

&lt;p&gt;ValuesFlat&lt;/p&gt;

&lt;p&gt;返回单一字段的平铺 slice 数据&lt;/p&gt;

&lt;p&gt;var list orm.ParamsList
num, err = o.Raw(&amp;ldquo;SELECT id FROM user WHERE id &amp;lt; ?&amp;ldquo;, 10).ValuesFlat(&amp;amp;list)
if err == nil &amp;amp;&amp;amp; num &amp;gt; 0 {
    fmt.Println(list) // []{&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;hellip;}
}&lt;/p&gt;

&lt;p&gt;RowsToMap&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res := make(orm.Params)
nums, err := o.Raw(&amp;quot;SELECT name, value FROM options_table&amp;quot;).RowsToMap(&amp;amp;res, &amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
// res is a map[string]interface{}{
//  &amp;quot;total&amp;quot;: 100,
//  &amp;quot;found&amp;quot;: 200,
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RowsToStruct&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Options struct {
    Total int
    Found int
}

res := new(Options)
nums, err := o.Raw(&amp;quot;SELECT name, value FROM options_table&amp;quot;).RowsToStruct(res, &amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
fmt.Println(res.Total) // 100
fmt.Println(res.Found) // 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare&lt;/p&gt;

&lt;p&gt;用于一次 prepare 多次 exec，以提高批量执行的速度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p, err := o.Raw(&amp;quot;UPDATE user SET name = ? WHERE name = ?&amp;quot;).Prepare()
res, err := p.Exec(&amp;quot;testing&amp;quot;, &amp;quot;slene&amp;quot;)
res, err  = p.Exec(&amp;quot;testing&amp;quot;, &amp;quot;astaxie&amp;quot;)
...
...
p.Close() // 别忘记关闭 statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造查询&lt;/p&gt;

&lt;p&gt;QueryBuilder 提供了一个简便，流畅的 SQL 查询构造器。在不影响代码可读性的前提下用来快速的建立 SQL 语句。&lt;/p&gt;

&lt;p&gt;QueryBuilder 在功能上与 ORM 重合， 但是各有利弊。ORM 更适用于简单的 CRUD 操作，而 QueryBuilder 则更适用于复杂的查询，例如查询中包含子查询和多重联结。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// User 包装了下面的查询结果
type User struct {
    Name string
    Age  int
}
var users []User

// 获取 QueryBuilder 对象. 需要指定数据库驱动参数。
// 第二个返回值是错误对象，在这里略过
qb, _ := orm.NewQueryBuilder(&amp;quot;mysql&amp;quot;)

// 构建查询对象
qb.Select(&amp;quot;user.name&amp;quot;,
    &amp;quot;profile.age&amp;quot;).
    From(&amp;quot;user&amp;quot;).
    InnerJoin(&amp;quot;profile&amp;quot;).On(&amp;quot;user.id_user = profile.fk_user&amp;quot;).
    Where(&amp;quot;age &amp;gt; ?&amp;quot;).
    OrderBy(&amp;quot;name&amp;quot;).Desc().
    Limit(10).Offset(0)

// 导出 SQL 语句
sql := qb.String()

// 执行 SQL 语句
o := orm.NewOrm()
o.Raw(sql, 20).QueryRows(&amp;amp;users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整 API 接口:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type QueryBuilder interface {
    Select(fields ...string) QueryBuilder
    From(tables ...string) QueryBuilder
    InnerJoin(table string) QueryBuilder
    LeftJoin(table string) QueryBuilder
    RightJoin(table string) QueryBuilder
    On(cond string) QueryBuilder
    Where(cond string) QueryBuilder
    And(cond string) QueryBuilder
    Or(cond string) QueryBuilder
    In(vals ...string) QueryBuilder
    OrderBy(fields ...string) QueryBuilder
    Asc() QueryBuilder
    Desc() QueryBuilder
    Limit(limit int) QueryBuilder
    Offset(offset int) QueryBuilder
    GroupBy(fields ...string) QueryBuilder
    Having(cond string) QueryBuilder
    Subquery(sub string, alias string) string
    String() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务处理&lt;/p&gt;

&lt;p&gt;ORM 可以简单的进行事务操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := NewOrm()
err := o.Begin()
// 事务处理过程
...
...
// 此过程中的所有使用 o Ormer 对象的查询都在事务处理范围内
if SomeError {
    err = o.Rollback()
} else {
    err = o.Commit()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模型定义&lt;/p&gt;

&lt;p&gt;复杂的模型定义不是必须的，此功能用作数据库数据转换和自动建表，在数据库操作中是重要&lt;/p&gt;

&lt;p&gt;默认的表名规则，使用驼峰转蛇形：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AuthUser -&amp;gt; auth_user
Auth_User -&amp;gt; auth__user
DB_AuthUser -&amp;gt; d_b__auth_user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了开头的大写字母以外，遇到大写会增加 _，原名称中的下划线保留。&lt;/p&gt;

&lt;p&gt;还可以自定义，设置参数，具体使用时到官方文档查询。&lt;/p&gt;

&lt;p&gt;五、 view&lt;/p&gt;

&lt;p&gt;在前面编写 Controller 的时候，我们在 Get 里面写过这样的语句 this.TplName = &amp;ldquo;index.tpl&amp;rdquo;，设置显示的模板文件，默认支持 tpl 和 html 的后缀名，如果想设置其他后缀你可以调用 beego.AddTemplateExt 接口设置&lt;/p&gt;

&lt;p&gt;主要是模版语言语法，先去了解然后查阅文档使用。&lt;/p&gt;

&lt;p&gt;beego 的模块设计&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session 模块
grace 模块
cache 模块
logs 模块
httplib 模块
context 模块
toolbox 模块
config 模块
i18n 模块
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些模块都可以单独import使用，在beego也有相应的封装，具体使用查看文档。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go积累</title>
      <link>http://kingjcy.github.io/blog/2017/05/23/go%E7%A7%AF%E7%B4%AF/</link>
      <pubDate>Tue, 23 May 2017 14:54:09 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/05/23/go%E7%A7%AF%E7%B4%AF/</guid>
      <description>&lt;p&gt;学习使用go语言已经有一段时间了，积累了很多的经验，这边进行整理并持续积累，也便于后期的备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;每个 Go 程序都是由包组成的。&lt;/p&gt;

&lt;p&gt;程序运行的入口是包 &lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;go自己的设计哲学：
1、不得包含源代码文件中没有用到的包
2、函数的左括号{位置
3、函数名大小写规则
4、不一定要用分号结束语句
package的名称必须和目录名保持一致&lt;/p&gt;

&lt;p&gt;Go语言的工作空间结构：
Go语言的工作空间其实就是一个文件目录，目录中必须包含src、pkg、bin三个目录。&lt;/p&gt;

&lt;p&gt;其中src目录用于存放Go源代码，pkg目录用于package对象，bin目录用于存放可执行对象
&amp;ndash;对应的环境变量的搭建&amp;ndash;
go命名行用到了GOPATH环境变量，在这个目录下收索
export GOPATH=你的工作空间路径
export PATH=$PATH:$GOPATH/bin&amp;mdash;-安装用这个路劲&lt;/p&gt;

&lt;p&gt;编译：build&lt;/p&gt;

&lt;p&gt;安装：
1、只要进入对应的应用包目录，然后执行go install，就可以安装了&lt;/p&gt;

&lt;p&gt;2、在任意的目录执行如下代码go install mymath&lt;/p&gt;

&lt;p&gt;go命令行工具
run:&lt;/p&gt;

&lt;p&gt;build:
1.如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install了。&lt;/p&gt;

&lt;p&gt;2.如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。&lt;/p&gt;

&lt;p&gt;3.如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。&lt;/p&gt;

&lt;p&gt;clean:
清除编译文件&lt;/p&gt;

&lt;p&gt;fmt：
格式化文件&lt;/p&gt;

&lt;p&gt;get：
动态获取远程代码包&lt;/p&gt;

&lt;p&gt;install：
这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin&lt;/p&gt;

&lt;p&gt;test：
自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件&lt;/p&gt;

&lt;p&gt;go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1
 go version 查看go当前的版本
go env 查看当前go的环境变量
go list 列出当前全部安装的package
 go run 编译并运行Go程序&lt;/p&gt;

&lt;p&gt;标准库：
bufio   带缓冲的io&lt;/p&gt;

&lt;p&gt;io&lt;/p&gt;

&lt;p&gt;fmt   基本输出输入&lt;/p&gt;

&lt;p&gt;Net/http.    http包提供了HTTP客户端和服务端的实现。&lt;/p&gt;

&lt;p&gt;strconv 类型转换 Itoa  Atoi&lt;/p&gt;

&lt;p&gt;time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//返回现在时间  
tNow := time.Now()  
//时间转化为string，layout必须为 &amp;quot;2006-01-02 15:04:05&amp;quot;  
timeNow := tNow.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)  
fmt.Println(&amp;quot;tNow(time format):&amp;quot;, tNow)  
fmt.Println(&amp;quot;tNow(string format):&amp;quot;, timeNow)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;make（）
make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。
//创建一个初始元素个数为5的数组切片，元素初始值为0
 a := make([]int, 5)  // len(a)=5&lt;/p&gt;

&lt;p&gt;1、变量
用关键字var来声明&lt;/p&gt;

&lt;p&gt;可以直接用:=这个服务声明初始化，但必须不是声明过的。
a := 10类似于var i int
        i = 10；
&lt;code&gt;:=&lt;/code&gt; 结构不能使用在函数外。&lt;/p&gt;

&lt;p&gt;支持多重赋值
i，j = j，i这样就完成了交换。&lt;/p&gt;

&lt;p&gt;支持匿名变量
func getname（）（firstname,lastname,nickname）{
}
&amp;mdash;&amp;gt;&lt;em&gt;,&lt;/em&gt;,nickname := getname();可以这样玩&lt;/p&gt;

&lt;p&gt;2、常量：
iota 一个特殊的常量，出现一次自动加一，当出现const的时候会自动置零
常量不能使用 := 语法定义&lt;/p&gt;

&lt;p&gt;枚举类型不需要enum
正常定义
const（
    Sunday = iota
    monday
)
其中的大写字母开头的在包外可用，小写字母开头的包内私有&lt;/p&gt;

&lt;p&gt;3、数组
1、主要是值类型，每次传参都是一个副本，要传址，需要用数组切片
2、遍历数组元素，除了用下标，也可以用关键字range，有两个返回值，一个是下标，一个是value,在对strings进行遍历的时候一个是下表，一个是ASII&lt;/p&gt;

&lt;p&gt;var a [10]int&lt;/p&gt;

&lt;p&gt;var a = [10]int{0,1,2,3,4,5,6,7,8,9}&lt;br /&gt;
var a = [&amp;hellip;]int{0,1,2,3,4,5,6,7,8,9}&lt;/p&gt;

&lt;p&gt;var a = [2][2]int{[2]int{1,1}, [2]int{2,2}}&lt;br /&gt;
var a = [2][2]int{{1,1}, {2,2}}&lt;/p&gt;

&lt;p&gt;数组切片
创建：1、在一个数组的基础上用[:]来创建
    2、直接用make函数创建
创建一个初始元素个数为5的数组切片，元素初始值为0：
mySlice1 := make([] int, 5)
创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：
mySlice2 := make([] int, 5, 10)
直接创建并初始化包含5个元素的数组切片：
mySlice3 := [] int{1, 2, 3, 4, 5}&lt;/p&gt;

&lt;p&gt;cap():分配的空间
len()：所占的元素
copy()：复制，以小的为准&lt;/p&gt;

&lt;p&gt;优点：可以动态增减元素，原始数组增减数据是要重新分配内存，然后将数据搬过去，这样比较消耗性能，但是数据切片则可以用cap（）知道分配的空间，然后充分利用，而后在内存不够会自动扩大内存。&lt;/p&gt;

&lt;p&gt;map[key] = value
定义 var a map[string]value&lt;/p&gt;

&lt;p&gt;4、控制语句：
顺序if条件中初始化的变量可以在else中使用，选择，循环(支持for，不支持while和do_while)，goto语句&amp;mdash;》跳到标志位&lt;/p&gt;

&lt;p&gt;5、函数：
关键字func、函数名、参数列表、返回值、函数体和返回语句。
func Add(a int, b int) (ret int, err error) {
}&lt;/p&gt;

&lt;p&gt;函数调用：
因此需要先牢记这样的规则：小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用。
n, err := Foo(0)
if err != nil {
 // 错误处理
} else {
 // 使用返回值n
}&lt;/p&gt;

&lt;p&gt;不定参数：传入参数的数量不变
语法糖：&amp;hellip;type
func myfunc(args &amp;hellip; int) {
}
如果是不同的类型则用interface{}
func myfunc(args &amp;hellip; interface{}) {
}&lt;/p&gt;

&lt;p&gt;如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice&amp;hellip;)。
nums := []int{1, 2, 3, 4}
myfunc(noms…)&lt;/p&gt;

&lt;p&gt;多返回值
支持匿名函数&amp;mdash;闭包？？？&lt;/p&gt;

&lt;p&gt;6、错误处理
error接口
关键字defer
defer 语句会延迟函数的执行直到上层函数返回。
两个函数panic，recover&lt;/p&gt;

&lt;p&gt;面向对象：&amp;mdash;很直接，没有隐藏this指针
func (a Integer) Less(b Integer) bool { // 面向对象
return a &amp;lt; b
}
func Integer_Less(a Integer, b Integer) bool { // 面向过程
return a &amp;lt; b
}
a.Less(2) // 面向对象的用法
Integer_Less(a, 2) // 面向过程的用法&lt;/p&gt;

&lt;p&gt;STRUCT基本和c差不多，也有继承采取了组合的文法&amp;ndash;通过结构体继承，没有private，public关键字来保护，而是通过字母大小写来，
初始化常用方法：
rect1 := new(Rect)
rect2 := &amp;amp;Rect{}
rect3 := &amp;amp;Rect{0, 0, 100, 200}
rect4 := &amp;amp;Rect{width: 100, height: 200}&lt;/p&gt;

&lt;p&gt;未显式初始化的都是对应的零值
构造函数用一个全局函数NEWXXXX来表示
func NewRect(x, y, width, height float64) *Rect {
 return &amp;amp;Rect{x, y, width, height}
}&lt;/p&gt;

&lt;p&gt;最重要的就是接口interface（是any类型）的改造-非侵入式的.&amp;mdash;可以完成包与包之间的调用，或者同一个包内部的调用
interface是一组method的组合，我们通过interface来定义对象的一组行为。实现interface中的所有方法的类就是实现了这个接口，可以调用这个接口以及这个接口中的方法。interface中的方法不能重载。
空的interface可以存储任意类型的值。&lt;/p&gt;

&lt;p&gt;并发：不要通过共享内存来通信，而应该通过通信来共享内存。
多进程&amp;mdash;&amp;mdash;-开销太大，都是基于内核的调用
多线程&amp;mdash;&amp;mdash;-相对开销小，但是远远达不到需求，最多并发1万这样
基于回调的非阻塞/异步io&amp;mdash;-共享内存式的同步异步，导致编程相当复杂
协程&amp;mdash;-轻量级线程，轻松达到100w的并发&lt;/p&gt;

&lt;p&gt;所以在协程的基础上，go支持在语言上实现协程并发goroutine，goroutine类似于进程，各个协程之间互不干涉，通过channel通信控制，这样减少了很多的复杂问题，所以goroutine重点：
关键字go&amp;mdash;&amp;ndash;只要在执行体前加上关键字go就能实现协程并发
消息通信channel&amp;mdash;&amp;ndash;不同的协程之间，通过消息channel通信&lt;/p&gt;

&lt;p&gt;channel：关键字chan
声明var ch chan int
var m map[ string] chan bool
ch := make( chan int)
c := make( chan int, 1024)&amp;ndash;带缓冲的channel，后面的参数是缓冲大小
c := make( []chan int, 1024)&amp;ndash;这个是是数组&lt;/p&gt;

&lt;p&gt;写 ch &amp;lt;- 1     向channel写入数据通常会导致程序阻塞，直到有其他goroutine从这个channel中读取数据
读 value := &amp;lt;-ch    如果channel之前没有写入数据，那么从channel中读取数据也会导致程序阻塞，直到channel中被写入数据为止——这两点可以用于数据同步。&lt;/p&gt;

&lt;p&gt;select {
 case &amp;lt;-chan1:
 // 如果chan1成功读到数据，则进行该case处理语句
 case chan2 &amp;lt;- 1:
 // 如果成功向chan2写入数据，则进行该case处理语句
default:
 // 如果上面都没有成功，则进入default处理流程
}&amp;mdash;-超时机制也是用select来实现的&lt;/p&gt;

&lt;p&gt;单向channel：
var ch1 chan int // ch1是一个正常的 channel，不是单向的
var ch2 chan&amp;lt;- float64// ch2是单向channel，只用于写float64数据
var ch3 &amp;lt;-chan int // ch3 是单向channel，只用于读取int数据&lt;/p&gt;

&lt;p&gt;ch4 := make( chan int)
ch5 := &amp;lt;-chan int(ch4) // ch5就是一个单向的读取channel
ch6 := chan&amp;lt;- int(ch4) // ch6 是一个单向的写入channel&lt;/p&gt;

&lt;p&gt;关闭close（）&amp;mdash;-x, ok := &amp;lt;-ch，可以通过ok来判断channel是否关闭，一个非空的通道也是可以关闭的，但是通道中剩下的值仍然可以被接收到。&lt;/p&gt;

&lt;p&gt;go并发也提供锁机制Mutex和RWMutex
var l sync.Mutex
func foo() {
 l.Lock()
 defer l.Unlock()
 //&amp;hellip;
}&lt;/p&gt;

&lt;p&gt;全局唯一性操作
var once sync.Once&lt;/p&gt;

&lt;p&gt;time&lt;/p&gt;

&lt;p&gt;time.Duration（时长，耗时）
time.Time（时间点）
time.C（放时间点的管道）[ Time.C:=make(chan time.Time) ]&lt;/p&gt;

&lt;p&gt;方法
定时器time—sleep，after（time.Duration）多长时间后执行，一个阻塞一个非阻塞
打点器tick（time.Duration）每隔多长时间执行一次
time.Now()当前时间
可以哟过sub，add加减
定时器和打点器可以实现速率控制&lt;/p&gt;

&lt;p&gt;排序：sort包
常用方法：
排序字符串sort.Strings()
排序int。sort.Ints()
是否排序好。sort.IntsAreSorted(ints）
可以自定义排序实现sort.Interface中的方法，然后可以用sort方法自定义排序。&lt;/p&gt;

&lt;p&gt;Panic处理意外的错误。&lt;/p&gt;

&lt;p&gt;golang中包的理解
定义：
关键字 package XXXX&lt;/p&gt;

&lt;p&gt;我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。&lt;/p&gt;

&lt;p&gt;Go标准库中的包对应的源码部分路径在：$GOROOT/src，而标准库中包编译后的.a文件路径在$GOROOT/pkg/darwin_amd64下。&lt;/p&gt;

&lt;p&gt;执行go install libproj1/foo，Go编译器编译foo包，并将foo.a安装到$GOPATH/pkg/darwin_amd64/libproj1下&amp;mdash;不用先go build然后在go install&lt;/p&gt;

&lt;p&gt;因此我们要依赖第三方包，就必须搞到第三方包的源码，这也是Golang包管理的一个特点&lt;/p&gt;

&lt;p&gt;编译main包时，编译器到底用的是.a还是源码？&amp;mdash;-在使用第三方包的时候，当源码和.a均已安装的情况下，编译器链接的是源码。
最根本的是链接的是链接了以该最新源码编译的临时目录下的.a文件，而不是pkg下面的.a文件。&amp;mdash;如果想依赖pkg下面的.a文件，那只能分布编译了，把6l链接时的-L $WORK 去掉，才会找到pkg下面（具体参考-X -V参数的编译原理）&lt;/p&gt;

&lt;p&gt;标志库也是依赖源码编译产生的临时目录下的.a文件，但是当标准库的源码发生变化时，编译器不会尝试重新编译&amp;ndash;但是第三方库发生变化时，会重新编译生成临时文件，然后连接&lt;/p&gt;

&lt;p&gt;临时文件不是一直存在的，只是在编译的时候产生&lt;/p&gt;

&lt;p&gt;import后面的是路劲名还是包名？&amp;mdash;&amp;ndash;import后面的最后一个元素应该是路径，就是目录，并非包名。&amp;ndash;而调用的函数的那个是包名&amp;mdash;所以源码路劲一定要存在，不然就can not find&lt;/p&gt;

&lt;p&gt;引用包
import 文件所在的目录路劲（除去$GOPATH/src）
同一个目录下不能定义不同的package&lt;/p&gt;

&lt;p&gt;import m &amp;ldquo;lib/math&amp;rdquo;import语句用m替代lib/math  m指代的是lib/math路径下唯一的那个包&amp;ndash;一定是唯一，不然报错&lt;/p&gt;

&lt;p&gt;第三方语言包管理插件godep安装：
我这边找了一个现成的exe文件放到对应的目录下：&lt;a href=&#34;https://github.com/kr/heroku-buildpack-go/raw/master/linux-amd64/bin/godep&#34;&gt;https://github.com/kr/heroku-buildpack-go/raw/master/linux-amd64/bin/godep&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;go环境变量：
GOROOT ：go的安装目录&lt;/p&gt;

&lt;p&gt;GOPATH ：你自己开发go语言代码的目录，目录结构为bin,pkg,src，如果你有多个目录，那么使用分号分隔。&lt;/p&gt;

&lt;p&gt;网络编程：
    func Dial(net, addr string) (Conn, error)&lt;/p&gt;

&lt;p&gt;其中net参数是网络协议的名字， addr参数是IP地址或域名，而端口号以“:”的形式跟随在地址
或域名的后面，端口号可选。如果连接成功，返回连接对象，否则返回error。&lt;/p&gt;

&lt;p&gt;Dial() 函数支持如下几种网络协议： &amp;ldquo;tcp&amp;rdquo; 、 &amp;ldquo;tcp4&amp;rdquo; （仅限IPv4）、 &amp;ldquo;tcp6&amp;rdquo; （仅限
IPv6）、 &amp;ldquo;udp&amp;rdquo; 、 &amp;ldquo;udp4&amp;rdquo;（仅限IPv4）、 &amp;ldquo;udp6&amp;rdquo;（仅限IPv6）、 &amp;ldquo;ip&amp;rdquo; 、 &amp;ldquo;ip4&amp;rdquo;（仅限IPv4）和&amp;rdquo;ip6&amp;rdquo;
（仅限IPv6）。&lt;/p&gt;

&lt;p&gt;func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error)
func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error)
func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)
func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err error)&lt;/p&gt;

&lt;p&gt;与之前使用Dail() 的例子相比，这里有两个不同:
net.ResolveTCPAddr() ，用于解析地址和端口号；
net.DialTCP() ，用于建立链接。
这两个函数在Dial() 中都得到了封装。/Applications/QQ.app&lt;/p&gt;

&lt;p&gt;我们给 fmt.Println 一个短名字的别名
var p = fmt.Println&lt;/p&gt;

&lt;p&gt;随机数rand&lt;/p&gt;

&lt;p&gt;Rand. Intn(n)。int代表整数，后面的n代表范围，其他类型类似&lt;/p&gt;

&lt;p&gt;((rand.Float64() * 5) + 5)这个技巧可以用来生成其他范围的随机浮点数，例如5.0 &amp;lt;= f &amp;lt;= 10.0&lt;/p&gt;

&lt;p&gt;种子
s1 := rand.NewSource(time.Now().UnixNano())
    r1 := rand.New(s1)&lt;/p&gt;

&lt;p&gt;相同的种子产生的随机数是一样的。&lt;/p&gt;

&lt;p&gt;数字解析包strconv
Url解析包url
SHA1散列就是通过一个算法计算散列值，使用Go 在多个 crypto/* 包中实现了一系列散列函数。
Base64编码—加密解密&lt;/p&gt;

&lt;p&gt;命令行参数
os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。&lt;/p&gt;

&lt;p&gt;命令行标志解析flag包
环境变量设置在os包&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;go提供了安装包，直接下载解压设置/etc/profile环境变量就可以使用go了，简单便捷&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOROOT=/home/test/Go/go—-源码安装路径

export PATH=$GOROOT/bin:$PATH——声明应用

export GOPATH=/home/test/Go/go-project—你的项目路劲
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;最常用的一种形式&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;./test&amp;rdquo;导入同一目录下test包中的内容&lt;/p&gt;

&lt;p&gt;import f &amp;ldquo;fmt&amp;rdquo;导入fmt，并给他启别名ｆ&lt;/p&gt;

&lt;p&gt;import . &amp;ldquo;fmt&amp;rdquo;，将fmt启用别名&amp;rdquo;.&amp;ldquo;，这样就可以直接使用其内容，而不用再添加ｆｍｔ，如fmt.Println可以直接写成Println&lt;/p&gt;

&lt;p&gt;import  _ &amp;ldquo;fmt&amp;rdquo; 表示不使用该包，而是只是使用该包的init函数，并不显示的使用该包的其他内容。注意：这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;struct&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type person struct {
    name string
    age int
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;    var P person  // P现在就是person类型的变量了
    P.name = &amp;quot;Astaxie&amp;quot;  // 赋值&amp;quot;Astaxie&amp;quot;给P的name属性.
    P.age = 25  // 赋值&amp;quot;25&amp;quot;给变量P的age属性type person struct {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按照顺序提供初始化值&lt;/p&gt;

&lt;p&gt;P := person{&amp;ldquo;Tom&amp;rdquo;, 25}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过field:value的方式初始化，这样可以任意顺序&lt;/p&gt;

&lt;p&gt;P := person{age:24, name:&amp;ldquo;Tom&amp;rdquo;}&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;4。 interface&lt;/p&gt;

&lt;p&gt;Go语言引入了一种新类型—Interface，它在效果上实现了类似于C++的“多态”概念。&lt;/p&gt;

&lt;p&gt;从语法上看，Interface定义了一个或一组method(s)，这些method只有函数签名，没有具体的实现代码（有没有联想起C++中的虚函数？）。若某个数据类型实现了Interface中定义的那些被称为&amp;rdquo;methods&amp;rdquo;的函数，则称这些数据类型实现（implement）了interface。&lt;/p&gt;

&lt;p&gt;Interface类型的更通用定义可归纳如下：
type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    &amp;hellip;
}&lt;/p&gt;

&lt;p&gt;以fmt包的Printf()函数为例，其函数签名格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Printf(format string, a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数在实现底层的打印行为时，要求传入的可变长参数实现了fmt包中定义的Stringer接口，这个接口类型定义及描述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Stringer interface {
    String() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一段简单的打印代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

func main() {
    addrs := map[string]IPAddr{
        &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
        &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
    }
}

loopback: [127 0 0 1]
googleDNS: [8 8 8 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要求按规定的格式打印：IPAddr{1, 2, 3, 4}应该输出为&amp;rdquo;1.2.3.4&amp;rdquo;的格式，所以IPAddr这个自定义类型需要实现Stringer接口，实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

// TODO: Add a &amp;quot;String() string&amp;quot; method to IPAddr.
func (ip IPAddr) String() string {    
    return fmt.Sprintf(&amp;quot;%v.%v.%v.%v&amp;quot;, ip[0], ip[1], ip[2], ip[3])
}

func main() {
    addrs := map[string]IPAddr{
        &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
        &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
    }
}

googleDNS: 8.8.8.8
loopback: 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;go tool&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;go build&lt;/p&gt;

&lt;p&gt;go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。&lt;/p&gt;

&lt;p&gt;如果是普通包，当你执行go build命令后，不会产生任何文件。&lt;/p&gt;

&lt;p&gt;如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin木下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/a.exe。&lt;/p&gt;

&lt;p&gt;如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。&lt;/p&gt;

&lt;p&gt;你也可以指定编译输出的文件名。比如，我们可以指定go build -o myapp.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。&lt;/p&gt;

&lt;p&gt;go build 会忽略目录下以”_”或者”.”开头的go文件。&lt;/p&gt;

&lt;p&gt;go build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。&lt;/p&gt;

&lt;p&gt;go clean&lt;/p&gt;

&lt;p&gt;go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括&lt;/p&gt;

&lt;p&gt;_obj/ 旧的object目录，由Makefiles遗留
_test/ 旧的test目录，由Makefiles遗留
_testmain.go 旧的gotest文件，由Makefiles遗留
test.out 旧的test记录，由Makefiles遗留
build.out 旧的test记录，由Makefiles遗留
*.[568ao] object文件，由Makefiles遗留
DIR(.exe) 由 go build 产生
DIR.test(.exe) 由 go test -c 产生
MAINFILE(.exe) 由 go build MAINFILE.go产生&lt;/p&gt;

&lt;p&gt;go fmt&lt;/p&gt;

&lt;p&gt;go fmt 命令主要是用来帮你格式化所写好的代码文件。&lt;/p&gt;

&lt;p&gt;比如我们写了一个格式很糟糕的test.go文件，我们只需要使用fmt命令，就可以让go帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了 go fmt 命令而已。&lt;/p&gt;

&lt;p&gt;使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w src，可以格式化整个项目。&lt;/p&gt;

&lt;p&gt;go get&lt;/p&gt;

&lt;p&gt;go get 命令主要是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具.&lt;/p&gt;

&lt;p&gt;所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。&lt;/p&gt;

&lt;p&gt;go get 命令本质上可以理解为：首先通过源码工具clone代码到src目录，然后执行go install。&lt;/p&gt;

&lt;p&gt;如果需要更新所有的依赖库，增加 -u 参数&lt;/p&gt;

&lt;p&gt;go install&lt;/p&gt;

&lt;p&gt;go install 命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。&lt;/p&gt;

&lt;p&gt;.exe文件： 一般是 go install 带main函数的go文件产生的，有函数入口，所有可以直接运行。&lt;/p&gt;

&lt;p&gt;.a应用包： 一般是 go install 不包含main函数的go文件产生的，没有函数入口，只能被调用。&lt;/p&gt;

&lt;p&gt;go test&lt;/p&gt;

&lt;p&gt;go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似&lt;/p&gt;

&lt;p&gt;ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
&amp;hellip;
默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag&lt;/p&gt;

&lt;p&gt;go doc&lt;/p&gt;

&lt;p&gt;go doc 命令其实就是一个很强大的文档工具。&lt;/p&gt;

&lt;p&gt;如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net/http；查看某一个包里面的函数，那么执行godoc fmt Printf；也可以查看相应的代码，执行godoc -src fmt Printf；&lt;/p&gt;

&lt;p&gt;通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。&lt;/p&gt;

&lt;p&gt;其他命令&lt;/p&gt;

&lt;p&gt;Go语言还提供了其它有用的工具，例如下面的这些工具&lt;/p&gt;

&lt;p&gt;go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1&lt;/p&gt;

&lt;p&gt;go version 查看go当前的版本&lt;/p&gt;

&lt;p&gt;go env 查看当前go的环境变量&lt;/p&gt;

&lt;p&gt;go list 列出当前全部安装的package&lt;/p&gt;

&lt;p&gt;go run 编译并运行Go程序&lt;/p&gt;

&lt;h2 id=&#34;开发工具&#34;&gt;开发工具&lt;/h2&gt;

&lt;p&gt;尝试了liteide和sublime text，感觉还是sublime text比较好，它支持源码的查看的跳转，编译执行，而liteide在跳转上有点问题，不能跳转到自定义的函数，不知道是不是我配置的问题（基本上就是在查看选项设定了go环境变量），所以自己开发的时候决定用sublime&lt;/p&gt;

&lt;p&gt;sublime text go环境搭建&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在mac上安装go并设置好环境变量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装一个Package Control，这个应该是一个插件管理工具，用于安装很多其他插件的，只要用ctrl+ ` 打开命令行输入执行命令&lt;/p&gt;

&lt;p&gt;import urllib.request,os,hashlib; h = &amp;lsquo;7183a2d3e96f11eeadd761d777e62404&amp;rsquo; + &amp;lsquo;e330c659d4bb41d3bdf022e94cab3cd0&amp;rsquo;; pf = &amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &amp;lsquo;&lt;a href=&#34;http://sublime.wbond.Net/&#39;&#34;&gt;http://sublime.wbond.Net/&#39;&lt;/a&gt; + pf.replace(&amp;rsquo; &amp;lsquo;, &amp;lsquo;%20&amp;rsquo;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&amp;lsquo;Error validating download (got %s instead of %s), please try manual install&amp;rsquo; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &amp;lsquo;wb&amp;rsquo; ).write(by)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装好后可以在preferences中找到这个插件。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装go插件gosublime&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们点击Package Control插件或者用shift+ctrl+p来打开，输入pcip（Package Control:Install Package的缩写）也就是安装插件的意思。然后输入gosublime就会自动安装了，安装好了依旧可以在preferences下找到这个gosublime插件。&lt;/p&gt;

&lt;p&gt;4.然后就可以在gopath下建src，src下建对应的项目，使用sublime进行编码，查看，按command+b进入到shell模式进行编译执行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go项目--frp</title>
      <link>http://kingjcy.github.io/blog/2016/06/17/go%E9%A1%B9%E7%9B%AE--frp/</link>
      <pubDate>Fri, 17 Jun 2016 09:54:42 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/06/17/go%E9%A1%B9%E7%9B%AE--frp/</guid>
      <description>&lt;p&gt;frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, udp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;首先需要安装go语言环境，然后可以直接使用go工具来下载安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/fatedier/frp
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会在对应的bin文件中产生可执行文件，在对应的conf下有对应的配置文件&lt;/p&gt;

&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;

&lt;h3 id=&#34;ssh内网穿透&#34;&gt;ssh内网穿透&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改 frps.ini 文件，配置一个名为 ssh 的反向代理：&lt;/p&gt;

&lt;h1 id=&#34;frps-ini&#34;&gt;frps.ini&lt;/h1&gt;

&lt;p&gt;[common]
bind_port = 7000&lt;/p&gt;

&lt;p&gt;[ssh]
listen_port = 6000
auth_token = 123&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动 frps：&lt;/p&gt;

&lt;p&gt;./frps -c ./frps.ini&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改 frpc.ini 文件，设置 frps 所在服务器的 IP 为 x.x.x.x；&lt;/p&gt;

&lt;p&gt;#frpc.ini
[common]
server_addr = x.x.x.x
server_port = 7000
auth_token = 123&lt;/p&gt;

&lt;p&gt;[ssh]
local_ip = 127.0.0.1
local_port = 22&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动 frpc：&lt;/p&gt;

&lt;p&gt;./frpc -c ./frpc.ini&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过 ssh 访问内网机器，假设用户名为 test：&lt;/p&gt;

&lt;p&gt;ssh -oPort=6000 test@x.x.x.x&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有很多应用参考 &lt;a href=&#34;https://github.com/fatedier/frp/blob/master/README_zh.md&#34;&gt;https://github.com/fatedier/frp/blob/master/README_zh.md&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;godep&#34;&gt;godep&lt;/h2&gt;

&lt;p&gt;godep是go的包管理工具，便于编码中对第三方依赖包对管理。&lt;/p&gt;

&lt;h3 id=&#34;安装-1&#34;&gt;安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;确保已经有go语言的环境并且设置好了 GOPATH 环境变量。&lt;/li&gt;
&lt;li&gt;使用 go get -u github.com/tools/godep 下载 godep 包并自动安装。&lt;/li&gt;
&lt;li&gt;godep 可执行程序会放在 $GOPATH/bin 目录下。所以想直接用 godep 执行命令的话需要将该路径加入到全局的环境变量 PATH 中，可以将export PATH=&amp;ldquo;$PATH:$GOPATH/bin&amp;rdquo;加入到系统启动脚本中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;基本使用-1&#34;&gt;基本使用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;构建项目&lt;/p&gt;

&lt;p&gt;godep save 或者 godep save ./&amp;hellip; 后者会递归查找所有引用的第三方包。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个命令做了以下几件事：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 查找项目中所用到的所有的第三方包
2. 在项目目录下创建 Godeps 目录，Godeps/Godeps.json 是依赖文件，包括了go的版本，用到的第三包的引入路径，版本号等信息，json文件需要一并加入到版本控制里。
3. 所有依赖的第三包的代码会被拷贝到 Godeps/_workspace/src 下，并且移除了 .git 这样的版本控制信息。Godeps/_workspace 里的内容如果加到版本控制里，别人下载代码后可以直接编译，不需要另外再下依赖包，但是项目大小会变大。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载第三方源码&lt;/p&gt;

&lt;p&gt;godep restore&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个命令是根据 Godeps/Godeps.json 文件把项目的依赖包下载到 $GOPATH 目录下，需要注意这个命令是会修改 $GOPATH 下依赖包的状态的，所以最好还是将 Godeps/_workspace 里的内容直接加到自己项目的版本控制里。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;其他命令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他的 go 命令基本上都可以通过 godep 执行，godep 封装的 go 命令其实就是将 Godeps/_workspace 加入到 GOPATH 中，这样编译的时候就会去 Godeps/_workspace 中寻找第三方包。&lt;/p&gt;

&lt;h2 id=&#34;源码解析&#34;&gt;源码解析&lt;/h2&gt;</description>
    </item>
    
  </channel>
</rss>