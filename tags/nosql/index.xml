<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/nosql/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/nosql/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>redis tutorial</title>
      <link>http://kingjcy.github.io/blog/2016/05/28/redis-tutorial/</link>
      <pubDate>Sat, 28 May 2016 09:56:46 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/05/28/redis-tutorial/</guid>
      <description>&lt;p&gt;redis是一款高性能的key-value型数据库，目前受到了强烈的欢迎和广泛的使用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;入门&#34;&gt;入门&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;基本数据类型操作使用&#34;&gt;基本数据类型操作使用&lt;/h2&gt;

&lt;h4 id=&#34;strings&#34;&gt;strings&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set key value

get key &amp;gt; value
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;计数器&#34;&gt;计数器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set connections 10

INCR connections &amp;gt; 11

INCR connections &amp;gt; 12

DEL  connections

INCR connections &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INCR放在redis服务里面避免了多个客户端同时修改一个key导致最终的结果的错误。&lt;/p&gt;

&lt;h4 id=&#34;将一对键值对保留一段时间&#34;&gt;将一对键值对保留一段时间&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set key value

EXPIRE key 120

TTL key &amp;gt; 113

(after 113s)

TTL key &amp;gt; -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-2就代表这个键值对不存在了，如果中途对key重新设置，则TTL会被reset为-1&lt;/p&gt;

&lt;h4 id=&#34;list列表操作&#34;&gt;list列表操作&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;LPUSH，RPUSH 入表（入栈更加好理解一点）

LLEN         表的长度

LPOP,RPOP    出表（出栈）

LRANGE       显示列表一段内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;set和sorted-sets&#34;&gt;set和sorted sets&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sadd key value 向集合里面新增内容

srem key value 重集合中删除

simember key value  判断是否在集合内

smembers key   展示集合的内容

sunion key1 key2    联合集合


zadd sets key value 向有序集合set中新增键值对

zrange key1 展示key1集合对一段内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;hashes&#34;&gt;hashes&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;hset struct key value  设置哈希结构的键值对

hgetall struct          获取哈希结构体的内容

hmset struct key1 value1 key2 value2...  

hget struct key     获取哈希结构体的单个键值对
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;hash计数器&#34;&gt;hash计数器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;hset struct key 10

hincrby struct key 1 &amp;gt; 11

hincrby struct key 10 &amp;gt; 21

hdel struct key 

hincrby struct key 1 &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;linux下redis的安装和使用&#34;&gt;linux下redis的安装和使用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载解压包 tar -zxf redis-3.0.7.tar.gz 到安装目录解压&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make install&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用 redis-server 配置文件 启动&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用redis-cli客户端来连接-p表示端口，还有一些测试工具可以使用也可以用代码进行操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;specifications&#34;&gt;Specifications&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;redis-protocol&#34;&gt;redis protocol&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;网络&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis在tcp的6379端口来监听到来的连接，创建连接后来传输数据和命令，都是\r\n结尾的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;统一的请求协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*number of arguments CR LF&lt;/p&gt;

&lt;p&gt;$number of bytes of argument 1 CR LF&lt;/p&gt;

&lt;p&gt;argument data CR LF&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;$number of bytes of argument N CR LF&lt;/p&gt;

&lt;p&gt;&lt;argument data&gt; CR LF&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回复&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从第一个字节来校验回复的类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用单行回复，回复的第一个字节将是“+”&lt;/li&gt;
&lt;li&gt;错误消息，回复的第一个字节将是“-”&lt;/li&gt;
&lt;li&gt;整型数字，回复的第一个字节将是“:”&lt;/li&gt;
&lt;li&gt;批量回复，回复的第一个字节将是“$”  bulk strings 在$后面表示返回字符的长度，字符不存在则返回-1&lt;/li&gt;
&lt;li&gt;多个批量回复，回复的第一个字节将是“*”  Arrays 在*后面表示返回的批量数，请求键不存在则返回0，请求超时或者键丢失返回-1。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些同样可以使用与请求协议中&lt;/p&gt;

&lt;h2 id=&#34;redis内部机制&#34;&gt;redis内部机制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;redis动态字符串&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct sdshdr {
    long len;
    long free;
    char buf[];
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个结构体，代表这字符串的长度和内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef char *sds;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一种char*类型的type：sds&lt;/p&gt;

&lt;p&gt;利用如下的结构进行字符串存储&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct sdshdr *sh;

-----------
|5|0|redis|
-----------
^   ^
sh  sh-&amp;gt;buf

所以sh = zmalloc(sizeof(struct sdshdr)+initlen+1); 分配空间
    sh = (void*) (s-(sizeof(struct sdshdr))); 指针首位置，这边结构体是只会占用两个long的字节。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Redis虚拟内存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis虚拟内存就是指swap出用disk磁盘上的空间来存储，key是必须存放在内存的，value经常使用的放在内存中，不经常使用的可以swap到disk上。具体应用还是要看场景是否适用，并不是用来就好。&lt;/p&gt;

&lt;p&gt;配置后就可以使用了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm-enabled yes
vm-pages 用于配置swap文件中页的总数
vm-page-size 用于配置页的字节数

# The default vm-max-threads configuration 线程式虚拟内存 阻塞式虚拟内存
vm-max-threads 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于实现原理这块还没有搞明白，鉴于这个功能目前实用性不大，之后研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Redis事件库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事件库就是用来监听端口，进行连接，接受数据，并进行各种操作的代码库。&lt;/p&gt;

&lt;p&gt;redis事件库是基于epoll上实现的事件循环，在redis事件库中定义的读写事件和定时事件，先遍历当前时间最近的定时事件，计算出时间差作为对读写事件遍历的超时时间，避免了epoll超时影响定时事件的执行，遍历当前非定时事件，遇到需要处理的事件，就放入到已就绪的fired队列中，然后遍历这个队列进行fd事件的处理。直到定时事件的发生。依次循环完成了redis事件库的驱动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;管道(pipelining)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。就是可以同时处理多个命令，最后一起读取结果。减少了每一次连接的时间。不管这个连接是RTT（连接慢）还是loopback（连接较快）。开启管道后效率可以提升五倍这样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pub/sub&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发布订阅是一种消息通信的模式，主要是为了解耦消息发布者和消息订阅者的耦合关系，类似于观察者模式。
redis的pub/sub是通过中间通道chaannel来实现的，其实就是key，然后通过subscribe／unsbuscribe/publish来对channel其实也就是key进行操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过期&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;访问这个key时，发现其过期，进行删除操作&lt;/li&gt;
&lt;li&gt;每隔10S，随机抽取20个key，删除过期的key，如果删除的大于25%，重复此操作&lt;/li&gt;
&lt;li&gt;在复制aof文件期间，发现过期key就会将del操作一起合并到aof文件中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;回收机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis在内存达到设置的最大值时采取近似LUR(近期最少使用)算法回收，有对应的回收策略。所以正常是需要设置maxmemory的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redis主从复制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis的slave在第一次连接或者重新连接master的时候，会发送一个同步命令，然后master会收集出所有对数据修改的命令，然后向slave发送数据文件，给slave加载到内存中去，master接着发送所有收集的命令，完成主从的同步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;持久化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis的持久化有两种，一种是rdb快照模式的数据备份，另外一种就是aof的命令备份模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;rdb
rdb就是通过fork出一个子进程来将现有的内存数据写入到一个rdb结尾的文件中，比如每五分钟进行一次数据备份，但是如果突然发送故障，会导致数据五分钟里面的数据丢失，所以需要aof的持久化方式。但是rdb在恢复数据的时候是比aof要快的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;aof
aof就是将redis执行的命令存储到一个结尾为aof的文件中，这个可以安排每秒进行一次备份操作，这样最多丢失一秒的数据。就具有很强的持久化能力了。而且aof会对文件进行重写，使得aof文件不易变的那么庞大。并且命令集便于分析查看。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;信号与连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SIGTERM 设置一个定时任务SHUTDOWNredis实例。&lt;/p&gt;

&lt;p&gt;SIGSEGV
SIGBUS
SIGFPE
SIGILL
直接终止。&lt;/p&gt;

&lt;p&gt;redis连接也是基于socket，默认最大10000个客户端连接，可配置maxclients，可对客户端连接设置超时装置。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;redis使用&#34;&gt;redis使用&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;内存优化&#34;&gt;内存优化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用特殊编码&lt;/li&gt;
&lt;li&gt;使用32位实例内存要控制在4G内&lt;/li&gt;
&lt;li&gt;使用bit级和byte级操作&lt;/li&gt;
&lt;li&gt;尽可能的使用hashes&lt;/li&gt;
&lt;li&gt;注意内存分配&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;redis事务&#34;&gt;redis事务&lt;/h3&gt;

&lt;p&gt;开启一个事务 MULTI 后面跟着操作，在执行EXEC前是不会被执行的，直到执行命令EXEC&lt;/p&gt;

&lt;p&gt;在redis事务中有错误是不会回滚的，会返回错误继续执行下去，因为没有回滚的必要，必然是编码问题导致的。&lt;/p&gt;

&lt;p&gt;放弃事务 DISCARD&lt;/p&gt;

&lt;p&gt;乐观锁 WATCH 就是对key保持观察，在key发生变化期间不能完成当前对事务对操作。&lt;/p&gt;

&lt;h3 id=&#34;大量数据的插入&#34;&gt;大量数据的插入&lt;/h3&gt;

&lt;p&gt;使用redis客户端的pipe模式，原理同管道。&lt;/p&gt;

&lt;p&gt;也可以重文件导入大量的数据，将命令写在txt文档里面，最好是文档进行转码，在server里面导入，结合上面的pipe模式比较实用。&lt;/p&gt;

&lt;h3 id=&#34;redis配置&#34;&gt;redis配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以通过客户端&amp;ndash;命令行配置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以通过服务config命令行实现运行时配置修改。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置有空格用双引号。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;redis持久化&#34;&gt;redis持久化&lt;/h3&gt;

&lt;p&gt;数据备份&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。&lt;/li&gt;
&lt;li&gt;确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。&lt;/li&gt;
&lt;li&gt;至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;容灾备份&lt;/p&gt;

&lt;p&gt;Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。例如Amazon S3以及其他类型的S3，或者VPS来保存数据文件。&lt;/p&gt;

&lt;p&gt;rdb文件：默认情况下，redis数据库快照是保存在dump.rdb文件中，可以手动设置，在配置文件中save/bgsave&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAVE 60 1000   在60秒里有1000个键的改动。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aof文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;appendonly yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redis会执行BGRWEWRITEAOF来进行数据的重写操作，如果aof文件损坏，可以使用redis-check-aof来修复。&lt;/p&gt;

&lt;p&gt;正常建议同时使用rdb和aof持久化。&lt;/p&gt;

&lt;h3 id=&#34;redis-安全&#34;&gt;redis 安全&lt;/h3&gt;

&lt;p&gt;redis在安全方面并没有做太多的优化，只是支持密码的校验，通过AUTH来设置，还有只是对一些命令对禁用，使用配置文件中rename-command.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>