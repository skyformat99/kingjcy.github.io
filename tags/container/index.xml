<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/container/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/container/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>docker入门与实践</title>
      <link>http://kingjcy.github.io/blog/2016/11/25/docker%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Fri, 25 Nov 2016 10:57:16 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/11/25/docker%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;p&gt;docker是一种应用容器化的技术，就是一个容器，类似于logo中的集装箱运行在操作系统这只大鲸鱼上。&lt;/p&gt;

&lt;p&gt;docker容器化，类似于虚拟机，但是相对于虚拟机：运行速度快，占用资源少，通过git获取方便，通过dockerfile配置灵活，也不一定不安全,而且docker可以快速交付部署，减少环境问题，轻松迁移扩展，简单管理。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;docker安装&#34;&gt;docker安装&lt;/h2&gt;

&lt;p&gt;在安装之前需要确保linux的内核版本在3.10.X以上，没有话需要升级内核，我在我的虚拟机的上升级内核了可以参考《centos内核升级》&lt;/p&gt;

&lt;p&gt;docker是以linux容器化技术为基础的，所以在linux上体验最好，通常使用root用户安装&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;docker放在epel镜像源中，所以需要先添加镜像源yum install -y &lt;a href=&#34;http://mirrors.yun-idc.com/epel/6/x86_64/epel-release-6-8.noarch.rpm&#34;&gt;http://mirrors.yun-idc.com/epel/6/x86_64/epel-release-6-8.noarch.rpm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加载完需要修改源文件，将baseurl放开，将mirrorlist注释掉才能链接上。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;docker与一个系统自带的程序重名，所以修改为docker-io&lt;/p&gt;

&lt;p&gt;sudo yum install -y docker-io&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动
service docker start  或者docker -d&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加入开机启动项：chkconfig docker on&lt;/p&gt;

&lt;p&gt;过程中可能有一个device-mapper-libs需要升级，这边用yum源直接升级 yum upgrade device-mapper-libs没有用，需要现在最新的安装包进行安装&lt;/p&gt;

&lt;p&gt;2017.2.13在centos 7上使用无法链接到对应到镜像，重官网上获取新到docker源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-config-manager --add-repo https://docs.docker.com/engine/installation/linux/repo_files/centos/docker.repo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用yum makecache加载后重新安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在次过程中，有一个组件需要升级，rpm包需要手动下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -e selinux-policy-targeted-3.13.1-60.el7_2.9.noarch
rpm -ivh selinux-policy-targeted-3.13.1-190.fc24.noarch.rpm --nodeps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systmctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到此docker就安装好了，启动docker服务就可以对docker进行操作了。&lt;/p&gt;

&lt;p&gt;2017.3.21 docker重3.1之后开始改变命名，分为ce和ee企业班。这边安装更新&lt;/p&gt;

&lt;p&gt;OS requirements&lt;/p&gt;

&lt;p&gt;To install Docker, you need the 64-bit version of CentOS 7.&lt;/p&gt;

&lt;p&gt;Uninstall old versions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum remove docker \
                docker-common \
                container-selinux \
                docker-selinux \
                docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install yum-utils, which provides the yum-config-manager utility:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum install -y yum-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;add repo并且生效加载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum-config-manager \
    --add-repo \
        https://download.docker.com/linux/centos/docker-ce.repo

$ sudo yum-config-manager --disable docker-ce-edge

$ sudo yum makecache fast
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install docker-ce

$ sudo systemctl start docker
$ sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新版的也有对应的rpm可以安装。&lt;/p&gt;

&lt;p&gt;所以可以重官网下载rpm来安装，我们通过官网提供的yum源来下载rpm包，然后安装&lt;/p&gt;

&lt;h2 id=&#34;docker使用&#34;&gt;docker使用&lt;/h2&gt;

&lt;p&gt;docker容器三大核心：镜像，容器和仓库&lt;/p&gt;

&lt;p&gt;镜像是docker引擎只读的一块模版，包含文件系统，容器是基于镜像创建的一个实例，在镜像上加了一个可写层，实现了对镜像对起停等各种操作，镜像本事是不变的。起停等各种&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;镜像&#34;&gt;镜像&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;镜像：是docker的基础，包含app所需要的lib以及app&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载：docker pull name[:tag]  不指定tag默认取最新版本。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建容器：docker run -t -i 镜像版本 /bin/bash（可执行文件）&amp;mdash;-启动一个bash终端，-t表示一个伪终端并绑定在容器的标准输入中，-i则让容器标准输入保持打开  守护态运行 -d  -p  XX:XXX 为映射端口，将docker容器端口XX映射到宿主机的xxX端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看镜像信息：docker images&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为镜像新增标签：docker tag 镜像名 标签名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取镜像的详细信息：docker inspect images-id   同一个镜像的image-id是一样的 返回一个json格式的信息，具体到那一类信息用-f参数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;搜索镜像：docker search      -s n n星以上的镜像   关键字&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除镜像：docker rmi 标签/image-id    当该镜像创建容器正在运行，则无法删除，当然可以使用-f 强制删除，但是不建议使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建镜像：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于已有镜像创建   docker commit    [option] container [repository[:tag]]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;option:-a 作者信息  -m 提交信息  -p 提交时暂停容器运行
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：docker commit -a &amp;ldquo;jcy&amp;rdquo; -m &amp;ldquo;redisconfigload&amp;rdquo; 01758f83ddb2 redisconfigload&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基于本地模板的导出导入 docker export/import&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; docker export 7691a814370e &amp;gt; ubuntu.tar.gz
cat ubuntu.tar.gz | docker import - ubuntu:14.04
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基于dockerfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dockerfile一种文本格式的配置文件，由一行行命名组成,支持#开头的注释，主要组成如下：

基础镜像信息 FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;  第一条必须是这个命令，可以基于多个镜像，也可以基于空镜像scratch

维护者信息   MAINTAINER &amp;lt;name&amp;gt;

镜像操作指令  RUN &amp;lt;command&amp;gt; 类似于/bin/sh -c  RUN [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;] 使用exec来执行

容器启动时执行的指令
CMD [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]使用exec来执行,运行一个可执行的文件并提供参数
CMD command param1 param2   也可以是一个shell脚本，者就是一个带参数执行的命令bin/sh中执行，提供给需要交互的用户
CMD [&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]  给ENTRYPOINT提供默认参数          
CMD命令只执行一次，多条也会被覆盖，只执行最后一条，而且会被docker run指定的运行命令所覆盖。

EXPOSE 让docker容器暴露出端口来

ENV key value 指定环境变量

ADD COPY都是复制,ADD会对tar包进行解压，COPY不会,COPY可以自动创建不存在的目录。

ENTRYPOINT [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]使用exec来执行
ENTRYPOINT command param1 param2  shell执行，一样是容器启动后执行的，不会被cmd覆盖，同样只有一条生效。多条的情况下最后一条有效。

VOLUME [&amp;quot;/data&amp;quot;] 创造挂载点

WORKDIR  指定容器的工作目录。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后用docker build 来创建镜像 -t指定镜像的标签信息 -f dockerfile的路径 .&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t fabric8-console:2.2.199 -f /root/f8/f8-console/fabric8-console-2.2.199/Dockerfile .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一步都会生成一个块，对应的有一个唯一哈希值标志，下一次再进行打包的时候可以直接用这个缓存的块，可见镜像是由块组成的，dockerfile步骤越多块越多，镜像就越大，所以最后是基于空镜像，将文件系统的相关环境设置好打成tar包，然后用ADD加入，减少后面run执行的步骤，减小镜像的大小。
上面的哈希是根据大小来生成的，如果大小一样，哈希值会一样，不过这个很少出现，如果出现可以加上参数&amp;ndash;no-cache=true不使用缓存。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;存储镜像：docker save 将镜像存储为本地的文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;载入镜像：docker load 将本地镜像文件加载为本地镜像库的镜像&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上传镜像：docker push   name[:tag]&lt;/p&gt;

&lt;p&gt;先用docker tag打标签，然后这个标签上传到默认的dockerhub中，当然也可以上传到私有仓库。例如：&lt;/p&gt;

&lt;p&gt;在dockerhub上注册了user&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker tag test:latest user/test:latest
docker push user/test:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私有库的搭建以及上传管理在下面详细讲解。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;容器：在镜像上加一个隔离层，相当于一个个运行的实例，可以用docker ps -a 来查看当前所有的启停实例&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建:docker create&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动：docker start/stop &amp;mdash;&amp;mdash;合二为一 docker run&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建容器：docker run -t -i .. /bin/bash&amp;mdash;-启动一个bash终端，-t表示一个伪终端并绑定在容器的标准输入中，-i则让容器标准输入保持打开 守护态运行-d,退出用exit或者ctrl+d,-v挂载卷，-e传递环境变量，-p映射端口，是通过iptables实现的，可以用iptables-save查看。当然还可以通过参数对资源进行限制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;也可以使用docker run centos /bin/echo &amp;lsquo;hello world&amp;rsquo;,这样就类似在本地执行echo &amp;lsquo;hello world&amp;rsquo;&lt;/li&gt;
&lt;li&gt;docker run 主要查看本地是否有镜像，没有则去dockerhub上下载&lt;/li&gt;
&lt;li&gt;利用镜像创建并启动一个容器&lt;/li&gt;
&lt;li&gt;分配一个文件系统，给只读的镜像外层加一个可写层&lt;/li&gt;
&lt;li&gt;从宿主机的网桥接口中桥接一个虚拟接口到容器&lt;/li&gt;
&lt;li&gt;配置一个ip&lt;/li&gt;
&lt;li&gt;执行用户制定的程序&lt;/li&gt;
&lt;li&gt;执行完终止容器
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入容器：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker attach  name 这个是docker自带的命令，但是在多个终端一起链接到该容器的时候，他们是同步的，当其中一个出现问题时，其他的也会一样出现该问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker exec -ti   id /bin/bash 这个也是docker自带的，在docker1.3之后，它在容器中启动来一个bash,但是并不是所有的容器都是在linux系统上建立起来的，并不一定能启动bash&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以用工具nsenter，是一个需要安装的工具。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;容器资源限制参数 dockerfile的路径&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-m 1024m &amp;ndash;memory-swap=1024m  # 限制内存最大使用（bug：超过后进程被杀死）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;cpuset-cpus=&amp;ldquo;0,1&amp;rdquo;           # 限制容器使用CPU&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker容器随系统自启参数&lt;/p&gt;

&lt;p&gt;docker run &amp;ndash;restart=always redis&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;no – 默认值，如果容器挂掉不自动重启&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;on-failure – 当容器以非 0 码退出时重启容器 同时可接受一个可选的最大重启次数参数 (e.g. on-failure:5).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;always – 不管退出码是多少都要重启&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除：docker rm&lt;br /&gt;
-f 强制删除  -l 删除链接  -v删除挂载卷&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入和导出：docker export/import  将容器导出为tar文件，将文件导入为镜像，docker load差不多&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker logs id 记录容器内的操作，  * docker logs id&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker容器和主机进行拷贝&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重docker容器内拷贝到主机上&lt;/p&gt;

&lt;p&gt;[root@oegw1 soft]# docker ps
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS               NAMES
8d418a7b6021        postgres            &amp;ldquo;/docker-entrypoint.   7 hours ago         Up 7 hours                              test1&lt;br /&gt;
[root@oegw1 soft]# docker exec -t -i 8d418a7b6021 /bin/bash
root@oegw1:/var/lib/postgresql# pwd
/var/lib/postgresql
root@oegw1:/var/lib/postgresql# ls
data
root@oegw1:/var/lib/postgresql# exit
exit
[root@oegw1 soft]# docker cp 8d418a7b6021:/var/lib/postgresql/data /opt/soft/
完成拷贝&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重主机拷贝到docker容器中&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;挂载，也即是主机和docker容器共享一个目录&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在创建容器到时候用 -v XXX：XXX 来挂载&lt;/p&gt;

&lt;p&gt;[root@pdapp18 etc]# docker run -it -v /opt/inkscope/etc:/mnt centos /bin/bash
[root@bd91c6b79e87 mnt]# ll
total 4
-rw-r&amp;ndash;r&amp;ndash;. 1 root root 1323 May 23  2016 inkscope.conf
[root@bd91c6b79e87 mnt]# exit
[root@pdapp18 etc]# pwd
/opt/inkscope/etc
[root@pdapp18 etc]# l
总用量 4
-rw-r&amp;ndash;r&amp;ndash;. 1 root root 1323 5月  23 2016 inkscope.conf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;动态挂载
后续完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker还提供来一个数据卷的高级用法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;数据卷：“其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的”。感觉像是由一个容器定义的一个数据挂载信息。其他的容器启动可以直接挂载数据卷容器中定义的挂载信息。&lt;/p&gt;

&lt;p&gt;看示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -v /root:/root  --name test centos /bin/bash
创建一个普通的容器。用--name给他指定了一个名（不指定的话会生成一个随机的名子）。

然后其他容器就可以使用--volumes-from来引用这个数据卷，就可以让当前容器中的/root目录和本机的/root的进行共享
docker run -it --volumes-from test centos /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首先查看这个容器的id&lt;/p&gt;

&lt;p&gt;docker inspect -f &amp;lsquo;{{.Id}}&amp;rsquo; container-id返回容器的id
实际上本机的/var/lib/docker/container/contianer-id/和docker容器的根目录/是一致的，所以可以直接操作这个目录相当于操作容器的根目录，实现共享。但是我试验没有实现，等有时间再看看什么原因。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;仓库&#34;&gt;仓库&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;仓库：存放镜像文件的&lt;/p&gt;

&lt;p&gt;最大docker官方公共仓库：docker hub&lt;/p&gt;

&lt;p&gt;国内：docker pool&lt;/p&gt;

&lt;p&gt;官方的仓库镜像一般就是基础镜像，单个单词命名，而username/镜像名这个一般是某个用户上传的镜像&lt;/p&gt;

&lt;p&gt;默认是重docker hub上下载，如果需要重其他的镜像仓库下载则需要加前缀。&lt;/p&gt;

&lt;p&gt;当然也可以创建私有仓库。主要是通过docker registry这个python开源项目进行创建，registry2之后已经重构用go来开发，目前的registry的版本是2.6，但是有着很多的问题，现在已经有对应的容器镜像了，当然也可以通过源码进行安装。&lt;/p&gt;

&lt;p&gt;搭建私有库：&lt;/p&gt;

&lt;p&gt;首先下载官方提供的的镜像并且创建一个容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 5000:5000 --restart=always --name registry registry:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以docker ps看一下镜像已经启动，可以使用crul &lt;a href=&#34;http://ip:5000看看网络是否通，本地机器和容器之间的通信也需要iptables，iptables-services来进行通信。&#34;&gt;http://ip:5000看看网络是否通，本地机器和容器之间的通信也需要iptables，iptables-services来进行通信。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp20 ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
98de3ec23d75        registry:2          &amp;quot;/entrypoint.sh /e...&amp;quot;   16 hours ago        Up 16 hours         0.0.0.0:5000-&amp;gt;5000/tcp   registry&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过iptables-save来保存现有的规则同时也能查看，不过这个只需要安装好iptables,iptables-services并启动着就可以自动加入通信的规则。然后检查容器与主机之间是否是通的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态
SELinux status:                 enabled
2、getenforce                 ##也可以用这个命令检查
关闭SELinux：
1、临时关闭（不用重启机器）：
setenforce 0                  ##设置SELinux 成为permissive模式
                              ##setenforce 1 设置SELinux 成为enforcing模式
2、修改配置文件需要重启机器：
    修改/etc/selinux/config 文件
    将SELINUX=enforcing改为SELINUX=disabled
    重启机器即可
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候网络应该是通的了，然后我们tag一个自己的镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker pull ubuntu &amp;amp;&amp;amp; docker tag ubuntu localhost:5000/ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后上传&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker push localhost:5000/ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过&lt;a href=&#34;http://localhost:5000/v2/_catalog（在v1版本的时候是v1/search,现在在v2版本中已经不使用）来查看私有仓库的镜像,并到每一个镜像中去查看该镜像的具体信息。&#34;&gt;http://localhost:5000/v2/_catalog（在v1版本的时候是v1/search,现在在v2版本中已经不使用）来查看私有仓库的镜像,并到每一个镜像中去查看该镜像的具体信息。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp20 ~]# curl http://localhost:5000/v2/_catalog
{&amp;quot;repositories&amp;quot;:[&amp;quot;hello-world&amp;quot;,&amp;quot;ubuntu&amp;quot;]}
[root@pdapp20 ~]# curl http://localhost:5000/v2/tags/list
404 page not found
[root@pdapp20 ~]# curl http://localhost:5000/v2/ubuntu/tags/list
{&amp;quot;name&amp;quot;:&amp;quot;ubuntu&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;latest&amp;quot;]}
[root@pdapp20 ~]# curl http://localhost:5000/v2/hello-world/tags/list
{&amp;quot;name&amp;quot;:&amp;quot;hello-world&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;latest&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们删除本地的镜像，重自己的私有库来下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp20 ~]# docker rmi localhost:5000/hello-world
Untagged: localhost:5000/hello-world:latest
Untagged: localhost:5000/hello-world@sha256:2075ac87b043415d35bb6351b4a59df19b8ad154e578f7048335feeb02d0f759
[root@pdapp20 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
registry            2                   047218491f8c        2 weeks ago         33.2 MB
ubuntu              latest              0ef2e08ed3fa        3 weeks ago         130 MB
hello-world         latest              48b5124b2768        2 months ago        1.84 kB
centos              latest              67591570dd29        3 months ago        192 MB
[root@pdapp20 ~]# docker pull localhost:5000/hello-world
Using default tag: latest
latest: Pulling from hello-world
Digest: sha256:2075ac87b043415d35bb6351b4a59df19b8ad154e578f7048335feeb02d0f759
Status: Downloaded newer image for localhost:5000/hello-world:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然私有仓库可以进行加密认证，这个后续更新。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;数据和网络&#34;&gt;数据和网络&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据：数据卷和数据卷容器&amp;ndash;主要是几个参数-v&lt;/p&gt;

&lt;p&gt;数据卷和数据卷容器在上面主机和容器之间的复都有解释，这边直接讲一个数据卷用于数据的迁移：&lt;/p&gt;

&lt;p&gt;备份：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -volumes-from data -v $(pwd):/backup  ubuntu
tar -zcvf /backup/buckup.tar.gz /data

这样可以将容器数据卷data打包成backup.tar.gz，然后放到容器的backup目录下和本地主机的当前目录共享。实现备份。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据恢复就是将压缩包解压到共享目录，然后放到数据卷的容器中去。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络：端口-p和-P&lt;/p&gt;

&lt;p&gt;容器到主机：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;端口的映射可以制定主机端口，可以多次制定，可以指定所有的，可以通过docker port来查看当前容器的端口。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容器到容器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;通过--link来在容器之间建立一个安全到通道，避免暴露在外

    docker run --rm -it --name web2 --link db:db training/webapp /bin/bash

    root@5845d10a2bf5:/opt/webapp# cat /etc/hosts
    127.0.0.1    localhost
    ::1    localhost ip6-localhost ip6-loopback
    fe00::0    ip6-localnet
    ff00::0    ip6-mcastprefix
    ff02::1    ip6-allnodes
    ff02::2    ip6-allrouters
    172.17.0.3    db c6cd414f08d4   -------这边在web的容器里面有db的容器的主机配置
    172.17.0.5    5845d10a2bf5
    root@5845d10a2bf5:/opt/webapp# apt-get install -yqq inetutils-ping
    E: Failed to fetch http://archive.ubuntu.com/ubuntu/pool/universe/i/inetutils/inetutils-ping_1.9.2-1_amd64.deb  Could not resolve &#39;archive.ubuntu.com&#39;

    E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
    root@5845d10a2bf5:/opt/webapp# ping db
    PING db (172.17.0.3) 56(84) bytes of data.
    64 bytes from db (172.17.0.3): icmp_seq=1 ttl=64 time=0.204 ms
    64 bytes from db (172.17.0.3): icmp_seq=2 ttl=64 time=0.106 ms
    64 bytes from db (172.17.0.3): icmp_seq=3 ttl=64 time=0.097 ms
    64 bytes from db (172.17.0.3): icmp_seq=4 ttl=64 time=0.102 ms

    ----网络是通的，说明两个容器之间建立来一个安全的通道。

Docker集群通信：1。自定义网桥2.使用adbasssdor容器—目前已经有实现的容器集群管理方案，例如k8s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边可以根据书的内容了解各种语言对应的流行的框架：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. php

Cakephp,zend framework, symfony,phalconphp（这个是c扩展的，具有高性能低资源占用的框架）

2. python。动态脚本语言。perl 解释型脚本语言

flask，django（都是web框架）

3. ruby  动态脚本语言

jruby，Runy on rails,sinatra

4. javascript

node.js就是javascript的主力技术方案，express 最稳定的web开发框架，angularjs

5. go

beego，revel，martini
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;docker架构：&lt;/p&gt;

&lt;p&gt;c/s基本架构。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;docker实践&#34;&gt;docker实践&lt;/h2&gt;

&lt;h3 id=&#34;busybox&#34;&gt;busybox&lt;/h3&gt;

&lt;p&gt;busybox是一个集成一百多个常用的linux命令的工具箱，经常使用的echo，cat，mount，grep等等都在这个里面，是linux系统的瑞士军刀。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker pull busybox
docker run -it busybox
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以在这个镜像中使用各个命令了。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-centos&#34;&gt;ubuntu/centos&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;docker pull centos
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;coreos&#34;&gt;CoreOS&lt;/h3&gt;

&lt;p&gt;CoreOS是基于docker发行的linux的版本&lt;/p&gt;

&lt;h3 id=&#34;支持ssh的镜像&#34;&gt;支持ssh的镜像&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;首先下载镜像并创建容器，在容器中安装openssh-server，并启动该服务，然后在根目录下写一个脚本run.sh，来启动ssh，然后用docker commit来打包一个新的镜像。

然后可以用这个镜像创建容器启动服务就可以通过ssh来链接这个容器了

docker run -p 10022:22 -d sshd:centos /run.sh

ssh 宿主机 -p 10022 就可以登录到容器内
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;docker原理&#34;&gt;docker原理&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;docker在版本0.9之前是以lxc（linux container）为基础的，0.9以后又引入了自己开发的libcontainer，试图设计出更加通用的容器化技术。&lt;/p&gt;

&lt;p&gt;docker采用c/s架构，服务端默认在后台运行，进行容器的创建等相关操作，客户端就是我们调用的命令行操作.每次客户端运行完就会退出等待再次调用，客户端和服务端是通过socket进行通信的，默认是unix:///var/run/docker.sock,可以通过-H参数修改端口。&lt;/p&gt;

&lt;p&gt;docker都是独立的系统，是对操作系统的一种虚拟化。所以需要对其内核，文件系统，网络，PID，UID，IPC，内存，硬盘，cpu进行限制隔离，我们就是通过命名空间namespace，控制组cgroup，联合文件系统UFS，虚拟网络来完成的隔离独立运行。&lt;/p&gt;

&lt;p&gt;docker是一种轻量级的操作系统虚拟化方案，基于LXC，相对于传统的vm，它只虚拟来操作系统而没有虚拟内核，基于docker engine共享内核，即虚拟出运行库即可运行app，而传统的vm都是虚拟出完整的内核和运行库文件的操作系统。即虚拟出运行库即可运行app，而传统的vm都是虚拟出完整的内核和运行库文件的操作系统。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;docker-compose&#34;&gt;docker Compose&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;Compose，你可以在一个文件中定义一个多容器应用，然后使用一条命令来启动你的应用，完成一切准备工作。&lt;/p&gt;

&lt;p&gt;使用Docker Compose，不再需要使用shell脚本来启动容器。在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build 构建或重建服务
help 命令帮助
kill 杀掉容器
logs 显示容器的输出内容
port 打印绑定的开放端口
ps 显示容器
pull 拉取服务镜像
restart 重启服务
rm 删除停止的容器
run 运行一个一次性命令
scale 设置服务的容器数目
start 开启服务
stop 停止服务
up 创建并启动容器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;p&gt;在线下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -L https://github.com/docker/compose/releases/download/1.4.2/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose
chmod  x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;离线github上有对应的二进制包。&lt;/p&gt;

&lt;p&gt;通过配置yml文件来部署。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>