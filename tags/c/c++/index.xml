<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/c/c&#43;&#43;/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/c/c&#43;&#43;/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux下ccpp</title>
      <link>http://kingjcy.github.io/blog/2015/03/14/linux%E4%B8%8Bccpp/</link>
      <pubDate>Sat, 14 Mar 2015 15:14:28 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2015/03/14/linux%E4%B8%8Bccpp/</guid>
      <description>&lt;p&gt;这里主要是一些平时linux c/c++下编程时遇到的一些注意点，记录下来便于学习和备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;c-c-库&#34;&gt;c/c++库&lt;/h2&gt;

&lt;p&gt;在我们编程过程中经常需要用到别人封装好的库（库是一种用于快速开发，迅速上手，不必重复造轮子，任何一个产品都需要一个库文件提供api，让我们接入使用），在调用的时候，分为静态库和动态库。&lt;/p&gt;

&lt;p&gt;linux下静态库和共享库：库文件名必须以lib开头&lt;/p&gt;

&lt;p&gt;静态库是.a文件，编译时会包含在可执行文件中，可执行文件运行时是不需要该静态库的，这样会使可执行文件变大，占用内存和磁盘空间，ar rcs 库名 。o文件名&lt;/p&gt;

&lt;p&gt;动态库是.so .sa文件，这个是在可执行文件中保存一个地址列表，程序运行时用到才会去调用，不然加载到内存中共享，节省资源，现在比较实用的方法   gcc -shared -fPIC.o文件名 库名.so&lt;/p&gt;

&lt;p&gt;编译搜索路径：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;-L,-I指定的路劲下&lt;/li&gt;
&lt;li&gt;环境变量下指定路劲，libarypath ,LD_LIBRARY_PATH&lt;/li&gt;
&lt;li&gt;系统指定的路劲，usr/include,usr/lib,usr/local/inlude,usr/local/lib&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动态库的优先级高于静态库&lt;/p&gt;

&lt;p&gt;在一个程序运行时是不需要静态库的，但是需要链接动态库，所以一个可执行文件运行环境改变时，需要将其对应的动态库一并复制到新环境中，这些动态库是可以共享的&lt;/p&gt;

&lt;p&gt;我们可以使用ldd 可执行文件名，来查看对应的动态库是否找到了&lt;/p&gt;

&lt;p&gt;如果没有找到，则需要增加对应的动态库：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf文件的，但是添加完后需要调用下ldconfig，不然添加的library会找不到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果添加的library不在/lib和/usr/lib里面的话，就一定要修改/etc/ld.so.conf文件，往该文件追加library所在的路径，然后也需要重新调用下ldconfig命令。比如在安装MySQL的时候，其库文件/usr/local/mysql/lib，就需要追加到/etc/ld.so.conf文件中。命令如下：&lt;/p&gt;

&lt;p&gt;$echo &amp;ldquo;/usr/local/mysql/lib&amp;rdquo; &amp;gt;&amp;gt; /etc/ld.so.conf
$ldconfig&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果添加的library不在/lib或/usr/lib下，但是却没有权限操作写/etc/ld.so.conf文件的话，这时就需要往export里写一个全局变量LD_LIBRARY_PATH，就可以了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ace&#34;&gt;ACE&lt;/h3&gt;

&lt;p&gt;ACE可以说是在网络编程中比较著名的了，自适配通信环境（ADAPTIVE Communication Environment）是一个比较重量级的家伙，有大约二十万行代码，一堆的设计模式，很多架构，支持跨平台。ACE提供了一组丰富的可复用C++ Wrapper Facade（包装外观）和框架组件，可跨越多种平台完成通用的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。ACE的目标用户是高性能和实时通信服务和应用的开发者。它简化了使用进程间通信、事件多路分离、显式动态链接和并发的OO网络应用和服务的开发。此外，通过服务在运行时与应用的动态链接，ACE还使系统的配置和重配置得以自动化&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;ACE_DLL&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ACE_DLL封装了操作系统对dll(动态链接库Dynamic Link Library)的操作，因为Windows和*nix对dll操作的接口不一致，如Windows使用LoadLibrary/GetProcAddress/FreeLibrary这三个函数来显示地加载dll，从dll中找到函数地址以及关闭dll，而Linux则使用dlopen/dlsym/dlclose做同样的事情，ACE要使得程序具有良好的跨平台特性就需要屏蔽这些平台的差异性，而向上呈现出统一的接口。&lt;/p&gt;

&lt;p&gt;下面这个例子展示了如何使用ACE_DLL类来操作dll。&lt;/p&gt;

&lt;p&gt;dll_impl.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

//向外暴露这个接口，使用&amp;quot; extern &amp;quot;C&amp;quot; &amp;quot;来声明之，否则待会儿调用symbol来获取本函数的地址时就必须填全名
extern &amp;quot;C&amp;quot; person create_person(const string&amp;amp; name, unsigned int age);

class person
{

public:
    person(const string&amp;amp; name, unsigned int age);

    ~person();

    string get_person_name() const;

    private:
        string m_name;
        unsigned int m_age;
};
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dll_impl.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`
#include &amp;quot;dll_impl.h&amp;quot;

person::person(const string&amp;amp; name, unsigned int age) : m_name(name), m_age(age)
{
    cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;quot; say hello!&amp;quot; &amp;lt;&amp;lt; endl;
}

person::~person() 
{
    cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;quot; say byebye!&amp;quot; &amp;lt;&amp;lt; endl;
}

string person::get_person_name() const {
    return m_name;
}

person create_person(const string&amp;amp; name, unsigned int age){
    return person(name, age);
}
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dll_test.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`
#include &amp;quot;ace/Log_Msg.h&amp;quot;
#include &amp;quot;ace/DLL.h&amp;quot; 
#include &amp;quot;ace/ACE.h&amp;quot;

#include &amp;quot;dll_impl.h&amp;quot;

int main()
{
    ACE_DLL dll;

    int retval = dll.open(&amp;quot;libperson.so&amp;quot;, ACE_DEFAULT_SHLIB_MODE, 1);  

    if (retval != 0) {
        return -1;
    }else{
        ACE_DEBUG((LM_DEBUG, &amp;quot;open the dll successfully!!!\n&amp;quot;));
    }

    //声明一个函数指针类型
    typedef person (*person_factory)(const string&amp;amp; name, unsigned int age);

    person_factory fac=(person_factory)dll.symbol(&amp;quot;create_person&amp;quot;);

    if(fac == NULL)
    {
        cout &amp;lt;&amp;lt; &amp;quot;get symbol failed!&amp;quot; &amp;lt;&amp;lt; endl;
        return -1;
    }

    person per = fac(&amp;quot;ecy&amp;quot;, 24);

    cout &amp;lt;&amp;lt; per.get_person_name() &amp;lt;&amp;lt; endl;

    dll.close();

    return 0;
 }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译过程如下：&lt;/p&gt;

&lt;p&gt;1、首先生成动态链接库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -shared -o libperson.so dll_impl.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、生成测试程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -g -o dll_test dll_test.cpp -L. -lperson -lACE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、设置LD_LIBRARY_PATH&lt;/p&gt;

&lt;p&gt;测试程序运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ecy@ecy-geek:~/ACE/ace_dll$ ./dll_test 
open the dll successfully!!!
ecy say hello!
ecy
ecy say byebye!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对象编程和结构编程&#34;&gt;对象编程和结构编程&lt;/h2&gt;

&lt;p&gt;面向结构（c）就好比一个游戏中的怪物，我把这个怪物的各个方面分解成许多小的代码实现相应的动作最后共同实现，至此只这一个怪物，如果想要生成多个怪物，只需要重复编写相同的代码.&lt;/p&gt;

&lt;p&gt;面向对象（c++）就好比我把这个怪物封装为一个模型，然后生成多个对象，只对此对象进行在操作，这样每个对象的状态都可以是不一样的&lt;/p&gt;

&lt;p&gt;我觉得这个是对对象编程和结构编程一种比较好对描述。所以在很多过程中把c/c++结合起来实用比较好。&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;c++&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;private类成员不能在类以外直接访问，可以通过类的public方法来访问，当然类本身也可以访问&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类对象 是 在内存栈中使用构造函数开辟的一块内存空间&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-复制则将内存中的数据复制过去，但是本身对象地址不会改变&lt;/p&gt;

&lt;p&gt;类指针 是 在内存堆中使用new开辟出来的一个内存地址（nwe都是在内存堆上）,但是指针本身存储在栈上&amp;mdash;&amp;mdash;&amp;ndash;复制则将改变了指针的地址，那么就都不一样了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义指针时，包括上面的类指针，一定要new（malloc（size））出一片内存空间来给这个指针赋值，这个时候才能调用构造函数来初始化这个类，才使得类的内存空间初始化完成，后才能调用内部的成员变量和成员函数，但是定义对象时会自动调用构造函数，完成类的空间分配。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;顺序容器vector   类模板 (list, deque)
声明：vector&amp;lt;int&amp;gt; ivec;
初始化：vector&amp;lt;T&amp;gt; v1/v2(v1)/v1(n,i)/v1(n)值初始化
操作：empty(),size()--&amp;gt;size_type,push_back(),begin(),end()，c[n]=c.at(n),push_front(),front(),back()，push_insert()，删除erase(),clear() pop_back()，pop_front() ，swap()交换,assign()重置，capacity()容量，reserve（）剩余存储空间                        
下标：从0开始
迭代器iterator：--&amp;gt;const_iterator 只读不写,迭代器循环一直到最后一个位置的下一位
      for(vector&amp;lt;int&amp;gt;::iterator iter=iter.begin()，iter!=iter.end(),++iter) 
      *iter=0;
类型：size_type,iterator,const_iterator....
string： 
操作：substr()---&amp;gt;s.substr(pos,n)   返回s中从下标pos开始的n个字符,replace()，append()追加,find(),compare(),getline().
容器适配器：
    stack:empty(),top(),pop(),size(),push()---&amp;gt;FILO
    queue:empty(),front(),back(),push(),size(),pop()
    priority_queue:push(),top()




关联容器
类型：
pair:声明            初始化                                   成员
操作:pair&amp;lt;t1,t2&amp;gt;p1,pair&amp;lt;t1,t2&amp;gt;p1(v1,v2)--&amp;gt;make_pair(v1,v2) p.first,p.second
map :
map&amp;lt;k,v&amp;gt;m;     m.instert(make_pair(v1,v2)),m.insert(map(string,int)::value_type(v1,v2))----&amp;gt;value_type与pair&amp;lt;const k,v&amp;gt;是一样的

map[key] = value的两种插入存储代码：
        1、mapReconFtpCfg[key] = v_RecondCfgList[i];


        2、mapProductCumulateCfg.insert( make_pair( g_ProductCumulateCfg[i].m_nPRODUCT_CODE, g_ProductCumulateCfg[i] ) );

count(),find(),erase()       
set 
multimap的find，equal_range查找，find返回的是一直指向第一个key（value）的指针，equal_range返回是一对指针（pair），first指向的是第一个key（value），second指向的是最后一个key（value）的下一个位置，如果要用其中的数据，就可以遍历，用迭代器，前面的指针就是迭代器，只要++（被重载过，就相当于指针指向下一个）就可以一个个数据遍历然后就可以用了还可以用count()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string的find&lt;/p&gt;

&lt;p&gt;////find函数返回类型 size_type&lt;br /&gt;
 string s(&amp;ldquo;1a2b3c4d5e6f7g8h9i1a2b3c4d5e6f7g8ha9i&amp;rdquo;);&lt;br /&gt;
 string flag;&lt;br /&gt;
 string::size_type position;&lt;/p&gt;

&lt;p&gt;//find 函数 返回jk 在s 中的下标位置&lt;br /&gt;
 position = s.find(&amp;ldquo;jk&amp;rdquo;);&lt;br /&gt;
 if (position != s.npos)  //如果没找到，返回一个特别的标志c++中用npos表示，我这里npos取值是4294967295,它表示string结束的地方，相当于char*中的\0
     {&lt;br /&gt;
       cout &amp;lt;&amp;lt; &amp;ldquo;position is : &amp;ldquo; &amp;lt;&amp;lt; position &amp;lt;&amp;lt; endl;&lt;br /&gt;
     }&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据转换&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(long)-1  直接转化-1为long&lt;/p&gt;

&lt;p&gt;nvl(pool_id，0) 如果pool_id值不存在就为0，这个是在sql中实用&lt;/p&gt;

&lt;p&gt;lexical_cast&lt;/p&gt;

&lt;p&gt;XXXX_cast&amp;lt;类型&amp;gt;（数据）&amp;mdash;&amp;mdash;&amp;mdash;-数据本身类型不变，产生一个临时数据&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;fork&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;fork,创建子进程，重fork向下是父进程和子进程同时执行，调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1）在父进程中，fork返回新创建子进程的进程ID；也就是说大于0的是父进程

2）在子进程中，fork返回0；等于0的是子进程

3）如果出现错误，fork返回一个负值；小于0出错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.extern&lt;/p&gt;

&lt;p&gt;在源文件A里定义的函数，在其它源文件里是看不见的（即不能访问）。为了在源文件B里能调用这个函数，应该在B的头部加上一个外部声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; extern   函数原型；   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，在源文件B里也可以调用那个函数了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;启动参数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;argc表示启动参数的个数，argv代表启动参数的值 ，argv[0] 进程名，argv[1]第一个参数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;makefile基础&lt;/p&gt;

&lt;p&gt;MakeFile:
tt:tt.o
    g++ -o tt tt.o&lt;/p&gt;

&lt;p&gt;tt.o:tt.cpp
    g++ -c -o tt.o tt.cpp&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;typedef int nnn 别名，用nnn代表int&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;include&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;include 只是一个占位符，是把对应的文件都替代过来，到最后的一个大文件里是没有include的；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;传参&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;string 是一个类：一般使用引用，减少资源利用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const string &amp;amp;cValueStr 这个对同一块内存空间进行了const修饰，所以这块内存空间是不会变化的

string &amp;amp;cValueStr  既是传入的一般还要有相应的返回，引用和原来变量是公用的同一块内存，当cValueStr  变化了，原来的变量也就变化了

string cValueStr  直接把变量赋给了cValueStr  ，开辟了两块空间内存，如果变量较大改用引用就不浪费资源了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;long是基本类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一般不要使用引用。但是需要改变值就要引用

对于返回参数来说，必须要引用，不然是值传递，不能起到传递的作用，要用long &amp;amp;n  就是想第二种说的string &amp;amp;cValueStr  既是传入的一般还要有相应的返回，改变的是变量的指针，即指向的地址



#include 
using namespace std;
void swap(int &amp;amp;a,int &amp;amp;b)   //引用传递
{
int temp;
temp =a;
a = b;
b = temp;
}
void swap(int *a,int *b)  //地址传递      指针变量存放地址---指针
{
int temp;
temp = *a;
*a = *b;
*b =temp;
}
void swap1(int p,int q) //值传递 
{
int temp = p;
p = q;
q = temp;
}
int main()
{
int x =20;
int y =24;
int m =10;
int n =11;
swap(&amp;amp;x,&amp;amp;y);   /*地址传递*/
swap(m,n);     /*引用传递*/
int i =20;
int j =24;
swap1(i,j);    /*只改变栈中的值，主程序中的值并未改变*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家发现没有，值传递和引用传递函数内部几乎都是一样的，引用传递相对值传递和地址传递的好处在于在不需要另外开辟一块内存空间，而地址传递和值传递都需要另外开辟空间，从效率上来讲，引用传递的效率比另外两个都要高，对于值传递，它只改变栈内的值，主程序中的值其实并未改变，大家使用的的时候要多加小心。&lt;/p&gt;

&lt;p&gt;&amp;amp;a 取地址&lt;/p&gt;

&lt;p&gt;*a 取内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i = 2,*p=&amp;amp;i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这中定义的方式很经典的概括了*和&amp;amp;，这边是定义指针p为int*，并且初始化为i的地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *p  ======char p[]--------------------这个就是动态数组，需要在堆上开辟内存
char p[10]--------------这个是固定大小的数组，也不等价于*p
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;运算符重载：实际上就相当于一个运算符就是一个函数，根据参数来识别，未重载之前是基本符号，相当于一个汇编指令&lt;/p&gt;

&lt;p&gt;重载就是为了重复使用相同函数名的函数，符号也一样。是类和运算结合的产物。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;模版&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数模板：&amp;mdash;-第一个参数推演出类型template &lt;class T&gt;  函数类型  函数名{}&lt;/p&gt;

&lt;p&gt;类模板：&amp;mdash;&amp;ndash;需要对象声明类型&amp;mdash;temolate &lt;class T&gt; class A {}；   A&lt;int&gt; a;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;演化成什么类型就是什么类型，后面直接替代就好，都是在全局声明。&lt;/p&gt;

&lt;p&gt;模板类是不能单独写成cpp文件的，那样编译器无法识别模板是什么类型，就便不过去，如果不是模板类则可以的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;c_str()函数是指转为c风格的字符串c-string，在编程中减少for循环的实用可以提高性能&lt;/p&gt;

&lt;p&gt;m_nCityId = atol(s_cityId.c_str());
c_str()是c_string就是转化为C语言的string类型也就是char *，string是在c++中被封装成类的。&lt;/p&gt;

&lt;p&gt;m_NowDate.getSysDate();
LOG_DEBUG(g_logger, &amp;ldquo;m_NowDate:&amp;rdquo; &amp;lt;&amp;lt; m_NowDate.str());
.str（）是指把对象m_NowDate中的成员变量显示出来string&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类对象实例化成员和容器中的成员：&lt;/p&gt;

&lt;p&gt;CNGReconBankCtrlDT dt;
dt.m_nCITY_ID = v_RecondCfgList[i].m_nCITY_ID;
这个是成员变量，可以直接赋值&lt;/p&gt;

&lt;p&gt;vector&lt;CNGReconBankCtrlDT&gt; dtlist;
dtlist[0].m_nCITY_ID 这个可以当常量使用，但是不可以赋值改变&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;纯虚函数 virtual void 函数名（） = 0;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;含纯虚函数 的是抽象类，抽象类只有用指针或者引用，不允许有对象&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;标准库抛出的异常，都可以用exception类，里面有一个what（）函数，可以显示异常信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一般传入参数是数组字符的没有说明元素个数的，都会以null结尾的&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、返回指针函数，正常返回一个非空指针，出错返回NULL；&lt;/p&gt;

&lt;p&gt;2、返回整数函数，正常返回非负整数，一般是0，出错返回一个负数，一般为-1&lt;/p&gt;

&lt;p&gt;3、xxx_t   整数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;时间系统：
内核&amp;mdash;&amp;mdash;-time（NULL）&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;time_t t&amp;mdash;&amp;mdash;&amp;ndash;localtime（&amp;amp;t）&amp;mdash;&amp;ndash;&amp;gt;tm *P&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;strftime（地址。。。）&amp;mdash;&amp;mdash;-char buf[]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exec系列函数，用新函数覆盖子进程函数&amp;mdash;&amp;mdash;&amp;mdash;-execvp（进程名，argv）execlp（进程名，数组）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;精灵进程（守护进程，后台进程）：daemon   1、fork父进程结束  2、函数setsid（）3、函数umask（）4、close（fd）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件描述符&lt;/p&gt;

&lt;p&gt;0  标准输入stdin
1  标准输出stdout
2  标准出错输出stderr
这些都是文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;signal&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;信号捕捉函数singal，当产生SIGTERM信号时触发函数cGiSigHandler&lt;/p&gt;

&lt;p&gt;信号捕获：函数signal（）    信号传递kill -信号名  pid&lt;/p&gt;

&lt;p&gt;signal()函数理解&lt;/p&gt;

&lt;p&gt;在&lt;signal.h&gt; 这个头文件中。&lt;/p&gt;

&lt;p&gt;signal（参数1，参数2）；&lt;/p&gt;

&lt;p&gt;参数1：我们要进行处理的信号。系统的信号我们可以再终端键入 kill -l查看(共64个)。其实这些信号时系统定义的宏。&lt;/p&gt;

&lt;p&gt;参数2：我们处理的方式（是系统默认还是忽略还是捕获）。&lt;/p&gt;

&lt;p&gt;一般有3中方式进行操作。&lt;/p&gt;

&lt;p&gt;(1)eg: signal(SIGINT ,SIG_ING );&lt;/p&gt;

&lt;p&gt;SIG_ING 代表忽略SIGINT信号，SIGINT信号代表由InterruptKey产生，通常是CTRL +C 或者是DELETE 。发送给所有ForeGround Group的进程。&lt;/p&gt;

&lt;p&gt;(2)eg: signal(SIGINT ,SIG_DFL );&lt;/p&gt;

&lt;p&gt;SIG_DFL代表执行系统默认操作，其实对于大多数信号的系统默认动作时终止该进程。这与不写此处理函数是一样的。&lt;/p&gt;

&lt;p&gt;(3)void ( &lt;em&gt;signal( int sig, void (&lt;/em&gt; handler)( int )))( int );&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int (*p)();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个函数指针, p所指向的函数是一个不带任何参数, 并且返回值为int的一个函数.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int (*fun())();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个式子与上面式子的区别在于用fun()代替了p,而fun()是一个函数,所以说就可以看成是fun()这个函数执行之后,它的返回值是一个函数指针,这个函数指针(其实就是上面的p)所指向的函数是一个不带任何参数,并且返回值为int的一个函数.&lt;/p&gt;

&lt;p&gt;void (*signal(int signo, void (*handler)(int)))(int);就可以看成是signal()函数(它自己是带两个参数,一个为整型,一个为函数指针的函数),而这个signal()函数的返回值也为一个函数指针,这个函数指针指向一个带一个整型参数,并且返回值为void的一个函数.&lt;/p&gt;

&lt;p&gt;在写信号处理函数时对于信号处理的函数也是void sig_fun(int signo);这种类型,恰好与上面signal()函数所返回的函数指针所指向的函数是一样的.void ( *signal() )( int );&lt;/p&gt;

&lt;p&gt;signal是一个函数, 它返回一个函数指针, 后者所指向的函数接受一个整型参数 且没有返回值, 仔细看, 是不是siganal( int signo, void (*handler)(int) )的第2个参数了,对了,其实他所返回的就是 signal的第2个信号处理函数,指向信号处理函数,就可以执行函数了( signal内部时, signal把信号做为参数传递给handler信号处理函数,接着 signal函数返回指针, 并且又指向信号处理函数, 就开始执行它)&lt;/p&gt;

&lt;p&gt;那么，signal函数的参数又是如何呢？signal函数接受两个参数：一个整型的信号编号，以及一个指向用户定义的信号处理函数的指针。我们此前已经定义了指向用户定义的信号处理函数的指针sfp：&lt;/p&gt;

&lt;p&gt;void (*sfp)(int);&lt;/p&gt;

&lt;p&gt;sfp 的类型可以通过将上面的声明中的sfp去掉而得到，即void (*)(int)。此外，signal函数的返回值是一个指向调用前的用户定义信号处理函数的指针，这个指针的类型与sfp指针类型一致。因此，我们可以如下声明signal函数：&lt;/p&gt;

&lt;p&gt;void (&lt;em&gt;signal(int, void(&lt;/em&gt;)(int)))(int);&lt;/p&gt;

&lt;p&gt;同样地，使用typedef可以简化上面的函数声明：&lt;/p&gt;

&lt;p&gt;typedef void (*HANDLER)(int);
HANDLER signal(int, HANDLER);&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;include&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自定义下的头文件只能用双引号去include&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;26&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>