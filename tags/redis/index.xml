<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/redis/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>redis源码解析</title>
      <link>http://kingjcy.github.io/blog/2016/07/28/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 28 Jul 2016 15:39:45 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/07/28/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;redis项目的源码一直是备受赞扬的，其规模小而功能强大以及一些巧妙的技巧，都注定了它是一个值得学习的项目，今天起，我开始阅读redis源码，redis是用c写成的，对于我来说还是比较适合的。但是对于一百多个文件，怎么下手比较好，上网参考了别人的源码解析，最终决定按以下模块顺序阅读：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;struct:（结构体）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;adlist.c 用于对list的定义，它是个双向链表结构&lt;/li&gt;
&lt;li&gt;dict.c 主要对于内存中的hash进行管理&lt;/li&gt;
&lt;li&gt;sds.c 用于对字符串的定义&lt;/li&gt;
&lt;li&gt;sparkline.c 一个拥有sample列表的序列&lt;/li&gt;
&lt;li&gt;t_hash.c hash在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_list.c list在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_set.c  set在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_string.c string在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_zset.c zset在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;ziplist.c  ziplist是一个类似于list的存储对象。它的原理类似于zipmap。&lt;/li&gt;
&lt;li&gt;zipmap.c  zipmap是一个类似于hash的存储对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;data:（数据操作）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;aof.c 全称为append only file，作用就是记录每次的写操作,在遇到断电等问题时可以用它来恢复数据库状态。&lt;/li&gt;
&lt;li&gt;config.c 用于将配置文件redis.conf文件中的配置读取出来的属性通过程序放到server对象中。&lt;/li&gt;
&lt;li&gt;db.c对于Redis内存数据库的相关操作。&lt;/li&gt;
&lt;li&gt;multi.c用于事务处理操作。&lt;/li&gt;
&lt;li&gt;rdb.c  对于Redis本地数据库的相关操作，默认文件是dump.rdb（通过配置文件获得），包括的操作包括保存，移除，查询等等。&lt;/li&gt;
&lt;li&gt;replication.c 用于主从数据库的复制操作的实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tool:（工具）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;bitops.c 位操作相关类&lt;/li&gt;
&lt;li&gt;debug.c 用于调试时使用&lt;/li&gt;
&lt;li&gt;endianconv.c 高低位转换，不同系统，高低位顺序不同&lt;/li&gt;
&lt;li&gt;help.h  辅助于命令的提示信息&lt;/li&gt;
&lt;li&gt;lzf_c.c 压缩算法系列&lt;/li&gt;
&lt;li&gt;lzf_d.c  压缩算法系列&lt;/li&gt;
&lt;li&gt;rand.c 用于产生随机数&lt;/li&gt;
&lt;li&gt;release.c 用于发步时使用&lt;/li&gt;
&lt;li&gt;sha1.c sha加密算法的实现&lt;/li&gt;
&lt;li&gt;util.c  通用工具方法&lt;/li&gt;
&lt;li&gt;crc64.c 循环冗余校验&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;event:（事件）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ae.c 用于Redis的事件处理，包括句柄事件和超时事件。&lt;/li&gt;
&lt;li&gt;ae_epoll.c 实现了epoll系统调用的接口&lt;/li&gt;
&lt;li&gt;ae_evport.c 实现了evport系统调用的接口&lt;/li&gt;
&lt;li&gt;ae_kqueue.c 实现了kqueuex系统调用的接口&lt;/li&gt;
&lt;li&gt;ae_select.c 实现了select系统调用的接口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;baseinfo:（基本信息）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;asciilogo,c redis的logo显示&lt;/li&gt;
&lt;li&gt;version.h定有Redis的版本号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;compatible:（兼容）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;fmacros.h 兼容Mac系统下的问题&lt;/li&gt;
&lt;li&gt;solarisfixes.h 兼容solary下的问题&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;main:（主程序）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;redis.c redis服务端程序&lt;/li&gt;
&lt;li&gt;redis_cli.c redis客户端程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;net:（网络）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;anet.c 作为Server/Client通信的基础封装&lt;/li&gt;
&lt;li&gt;networking.c 网络协议传输方法定义相关的都放在这个文件里面了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;wrapper:（封装类）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;bio.c background I/O的意思，开启后台线程用的&lt;/li&gt;
&lt;li&gt;hyperloglog.c 一种日志类型的&lt;/li&gt;
&lt;li&gt;intset.c  整数范围内的使用set，并包含相关set操作。&lt;/li&gt;
&lt;li&gt;latency.c 延迟类&lt;/li&gt;
&lt;li&gt;migrate.c 命令迁移类，包括命令的还原迁移等&lt;/li&gt;
&lt;li&gt;notify.c 通知类&lt;/li&gt;
&lt;li&gt;object.c  用于创建和释放redisObject对象&lt;/li&gt;
&lt;li&gt;pqsort.c  排序算法类&lt;/li&gt;
&lt;li&gt;pubsub.c 用于订阅模式的实现，有点类似于Client广播发送的方式。&lt;/li&gt;
&lt;li&gt;rio.c redis定义的一个I/O类&lt;/li&gt;
&lt;li&gt;slowlog.c 一种日志类型的，与hyperloglog.c类似&lt;/li&gt;
&lt;li&gt;sort.c 排序算法类，与pqsort.c使用的场景不同&lt;/li&gt;
&lt;li&gt;syncio.c 用于同步Socket和文件I/O操作。&lt;/li&gt;
&lt;li&gt;zmalloc.c 关于Redis的内存分配的封装实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;others:（存放了一些我暂时还不是很清楚的类,所以没有解释了）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;scripting.c&lt;/li&gt;
&lt;li&gt;sentinel.c&lt;/li&gt;
&lt;li&gt;setproctitle.c&lt;/li&gt;
&lt;li&gt;valgrind.sh&lt;/li&gt;
&lt;li&gt;redisassert.h&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;test:（测试）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;memtest.c 内存检测&lt;/li&gt;
&lt;li&gt;redis_benchmark.c 用于redis性能测试的实现。&lt;/li&gt;
&lt;li&gt;redis_check_aof.c 用于更新日志检查的实现。&lt;/li&gt;
&lt;li&gt;redis_check_dump.c 用于本地数据库检查的实现。&lt;/li&gt;
&lt;li&gt;testhelp.c 一个C风格的小型测试框架。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些都是参考网上人家的阅读经验来的，去阅读吧！后续的源码解析直接放在我的github上[&lt;a href=&#34;https://github.com/kingjcy&#34;&gt;https://github.com/kingjcy&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;先看无关逻辑的结构体实现&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;链表adlist.c adlist.h&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;哈希dict.c dict.h&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串sds.c sds.h&lt;/p&gt;

&lt;p&gt;先定义字符串sds 其实就是char * 然后通过结构体sdshdr来完成对字符串的各种操作，其实就是string类型的c实现模式，其中的结构体成员就是对应的string的属性。其中用到goto清理内存，以及动态分配内存，指针的各种使用方法对应的c基础库函数的使用都值得学习。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>redis cluster</title>
      <link>http://kingjcy.github.io/blog/2016/07/21/redis-cluster/</link>
      <pubDate>Thu, 21 Jul 2016 17:12:36 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/07/21/redis-cluster/</guid>
      <description>&lt;p&gt;自从研究了redis的监控工具之后，对于redis的集群实现方案又回头做了一个系统的研究。
首先，先说一下redis，是一个高性能的key-value类型的NoSQL数据库，支持较为丰富的数据类型，
可以满足一般公司的需求，所以使用比较多，但是随着数据的越来越多，也迫切需求支持分布式集群。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;redis集群&#34;&gt;&lt;strong&gt;redis集群&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;目前redis集群已经有了较大的应用，包括官方也推出的redis3.0版本的集群部署方案。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis集群解决的问题&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;redis单线程特性，集群可以并发处理，更高效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单机内存有限&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单点问题，缺乏高可用性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不能动态扩容&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;分片的实现&#34;&gt;分片的实现&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;范围分区：将固定范围的数据key放到对应的实例中。这个方案不是太好，需要维护映射关系。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hash分区（一致性分区）：用哈希函数（例如crc32）将key转化为一个数字，然后取模来分配到不同的实例中。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;codis分区和redis3.0分区都是分了N个slot，先对key到slot进行hash分区再对slot进行范围分区或者hash分区。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;目前集群主要有四种部署方案&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端分片&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理分片：twenproxy代理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;codis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;redis cluster&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;四种部署方案&#34;&gt;&lt;strong&gt;四种部署方案&lt;/strong&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;客户端分片&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就是通过客户端来实现到不同的主机上的redis实例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-client.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;客户端分片是不用经过中间件，但是缺点太多了,所有的逻辑都在客户端，这样就导致了可运维性很差，首先，客户端存在着语言的差异，还有逻辑过分依赖于客户端，升级应用和扩展业务都依赖于客户端的开发，还存在着客户端版本和故障问题难以排查的问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;代理分片&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这边主要介绍的是曾被广泛使用的twenproxy作为中心代理的集群部署方案（twemproxy是twitter开源的一个redis和memcache代理服务器，只用于作为简单的代理中间件，目前twitter内部已经不再使用）。&lt;/p&gt;

&lt;p&gt;该集群主要是通过中间件twenproxy来实现，客户端只要通过中间件twenproxy提供的api和端口来进行操作，然后twenproxy提供路由能力（所有的key通过一致性哈希算法分布到集群中所有的redis实例中）到后台redis集群中的不同实例中，实现分布式集群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-twenproxy.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;twenproxy还提供了一些其他保障集群稳定的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;支持无效Redis实例的自动删除&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理与每个redis实例维持长连接，减少客户端和redis实例的连接数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理是无状态的，可以任意部署多套，避免单点问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认启用pipeline，连接复用，提高效率，性能损失在 10% - 20%&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这套部署方案，采用组件分离，升级容易，但是这个部署方案有一个很大的缺陷：无法动态扩容，不能平缓的增减redis实例，而且中间件也会消耗性能，在并发上，要求代理数量和实例一致甚至更多才能更好的发挥并发能力。造成运维工作量很大。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;codis&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;codis是豌豆荚开源一款分布式集群的方案，它是在redis2.8.21的基础上使用go和c改出来的，其实也是类似于twenproxy的代理模式，但是它可以实现平滑的新增实例，也就是动态扩容。&lt;/p&gt;

&lt;p&gt;Codis中采用预分片的形式，启动的时候就创建了1024个slot，1个slot相当于1个箱子，每个箱子有固定的编号，范围是1~1024。slot这个箱子用作存放Key，至于Key存放到哪个箱子，可以通过算法“crc32(key)%1024”获得一个数字，这个数字的范围一定是1~1024之间，Key就放到这个数字对应的slot。例如，如果某个Key通过算法“crc32(key)%1024”得到的数字是5，就放到编码为5的slot（箱子）。1个slot只能放1个Redis Server Group，不能把1个slot放到多个Redis Server Group中。1个Redis Server Group最少可以存放1个slot，最大可以存放1024个slot。因此，Codis中最多可以指定1024个Redis Server Group。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-codis.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这边对codis四大组成部分&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;codis-proxy 是客户端连接的 Redis 代理服务, codis-proxy 本身实现了 Redis 协议, 表现得和一个原生的 Redis 没什么区别 (就像 Twemproxy), 对于一个业务来说, 可以用Keepalived等负载均衡软件部署多个 codis-proxy实现高可用, codis-proxy 本身是无状态的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;codis-config 是 Codis 的管理工具, 支持包括, 添加/删除 Redis 节点, 添加/删除 Proxy 节点, 发起数据迁移等操作. codis-config 本身还自带了一个 http server, 会启动一个 dashboard, 用户可以直接在浏览器上观察 Codis 集群的运行状态，可以完善运维。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;codis-server 是 Codis 项目维护的一个 Redis 分支, 基于 2.8.21 开发, 加入了 slot 的支持和原子的数据迁移指令. Codis 上层的 codis-proxy 和 codis-config 只能和这个版本的 Redis 交互才能正常运行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ZooKeeper：Codis依赖于ZooKeeper存储数据路由表的信息和Codis Proxy节点的元信息。另外，Codisconfig发起的命令都会通过ZooKeeper同步到CodisProxy的节点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依然有中间件的性能消耗问题，但是解决了动态扩容问题。这个思路是目前大多数公司在用的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis3.0&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;redis3.0集群部署方案是官方在发布redis3.0版本的时候提供的，它采用了p2p模式，完全去中心化。依然采用预分片的模式，Redis把所有的Key分成了16384个slot，每个Redis实例负责其中一部分slot。slot 和 server 的映射关系存储每一个 server 的路由表中，集群中的所有信息（节点、端口、slot等），都通过节点之间定期的数据交换而更新。Redis客户端在任意一个Redis实例发出请求，如果所需数据不在该实例中，通过重定向命令引导客户端访问所需的实例。在存储时，根据 CRC16(key) mod 16384 的值，决定将一个key放到哪一个slot中。当数据迁移时就是调整 slot 的分布。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-3.0.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无中心化结构，每个节点都保存数据和整个集群的状态。&lt;/li&gt;
&lt;li&gt;采用 gossip 协议传播信息以及发现新节点（最终一致性）。gossip协议要求每个节点和其他节点保持连接，会利用PING/PONG来发送节点相关的数据，更新节点的路由表，如果设置的时间较短或者节点较多的话，还是比较客观的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而且目前官方只提供了一个ruby程序 redis-trib 完成集群的所有操作，缺乏监控管理工具，很难清楚目前集群的状态。目前并没有得到大规模的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>redis tutorial</title>
      <link>http://kingjcy.github.io/blog/2016/05/28/redis-tutorial/</link>
      <pubDate>Sat, 28 May 2016 09:56:46 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/05/28/redis-tutorial/</guid>
      <description>&lt;p&gt;redis是一款高性能的key-value型数据库，目前受到了强烈的欢迎和广泛的使用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;入门&#34;&gt;入门&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;基本数据类型操作使用&#34;&gt;基本数据类型操作使用&lt;/h2&gt;

&lt;h4 id=&#34;strings&#34;&gt;strings&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set key value

get key &amp;gt; value
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;计数器&#34;&gt;计数器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set connections 10

INCR connections &amp;gt; 11

INCR connections &amp;gt; 12

DEL  connections

INCR connections &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INCR放在redis服务里面避免了多个客户端同时修改一个key导致最终的结果的错误。&lt;/p&gt;

&lt;h4 id=&#34;将一对键值对保留一段时间&#34;&gt;将一对键值对保留一段时间&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set key value

EXPIRE key 120

TTL key &amp;gt; 113

(after 113s)

TTL key &amp;gt; -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-2就代表这个键值对不存在了，如果中途对key重新设置，则TTL会被reset为-1&lt;/p&gt;

&lt;h4 id=&#34;list列表操作&#34;&gt;list列表操作&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;LPUSH，RPUSH 入表（入栈更加好理解一点）

LLEN         表的长度

LPOP,RPOP    出表（出栈）

LRANGE       显示列表一段内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;set和sorted-sets&#34;&gt;set和sorted sets&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sadd key value 向集合里面新增内容

srem key value 重集合中删除

simember key value  判断是否在集合内

smembers key   展示集合的内容

sunion key1 key2    联合集合


zadd sets key value 向有序集合set中新增键值对

zrange key1 展示key1集合对一段内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;hashes&#34;&gt;hashes&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;hset struct key value  设置哈希结构的键值对

hgetall struct          获取哈希结构体的内容

hmset struct key1 value1 key2 value2...  

hget struct key     获取哈希结构体的单个键值对
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;hash计数器&#34;&gt;hash计数器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;hset struct key 10

hincrby struct key 1 &amp;gt; 11

hincrby struct key 10 &amp;gt; 21

hdel struct key 

hincrby struct key 1 &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;linux下redis的安装和使用&#34;&gt;linux下redis的安装和使用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载解压包 tar -zxf redis-3.0.7.tar.gz 到安装目录解压&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make install&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用 redis-server 配置文件 启动&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用redis-cli客户端来连接-p表示端口，还有一些测试工具可以使用也可以用代码进行操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;specifications&#34;&gt;Specifications&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;redis-protocol&#34;&gt;redis protocol&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;网络&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis在tcp的6379端口来监听到来的连接，创建连接后来传输数据和命令，都是\r\n结尾的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;统一的请求协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*number of arguments CR LF&lt;/p&gt;

&lt;p&gt;$number of bytes of argument 1 CR LF&lt;/p&gt;

&lt;p&gt;argument data CR LF&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;$number of bytes of argument N CR LF&lt;/p&gt;

&lt;p&gt;&lt;argument data&gt; CR LF&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回复&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从第一个字节来校验回复的类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用单行回复，回复的第一个字节将是“+”&lt;/li&gt;
&lt;li&gt;错误消息，回复的第一个字节将是“-”&lt;/li&gt;
&lt;li&gt;整型数字，回复的第一个字节将是“:”&lt;/li&gt;
&lt;li&gt;批量回复，回复的第一个字节将是“$”  bulk strings 在$后面表示返回字符的长度，字符不存在则返回-1&lt;/li&gt;
&lt;li&gt;多个批量回复，回复的第一个字节将是“*”  Arrays 在*后面表示返回的批量数，请求键不存在则返回0，请求超时或者键丢失返回-1。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些同样可以使用与请求协议中&lt;/p&gt;

&lt;h2 id=&#34;redis内部机制&#34;&gt;redis内部机制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;redis动态字符串&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct sdshdr {
    long len;
    long free;
    char buf[];
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个结构体，代表这字符串的长度和内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef char *sds;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一种char*类型的type：sds&lt;/p&gt;

&lt;p&gt;利用如下的结构进行字符串存储&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct sdshdr *sh;

-----------
|5|0|redis|
-----------
^   ^
sh  sh-&amp;gt;buf

所以sh = zmalloc(sizeof(struct sdshdr)+initlen+1); 分配空间
    sh = (void*) (s-(sizeof(struct sdshdr))); 指针首位置，这边结构体是只会占用两个long的字节。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Redis虚拟内存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis虚拟内存就是指swap出用disk磁盘上的空间来存储，key是必须存放在内存的，value经常使用的放在内存中，不经常使用的可以swap到disk上。具体应用还是要看场景是否适用，并不是用来就好。&lt;/p&gt;

&lt;p&gt;配置后就可以使用了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm-enabled yes
vm-pages 用于配置swap文件中页的总数
vm-page-size 用于配置页的字节数

# The default vm-max-threads configuration 线程式虚拟内存 阻塞式虚拟内存
vm-max-threads 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于实现原理这块还没有搞明白，鉴于这个功能目前实用性不大，之后研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Redis事件库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事件库就是用来监听端口，进行连接，接受数据，并进行各种操作的代码库。&lt;/p&gt;

&lt;p&gt;redis事件库是基于epoll上实现的事件循环，在redis事件库中定义的读写事件和定时事件，先遍历当前时间最近的定时事件，计算出时间差作为对读写事件遍历的超时时间，避免了epoll超时影响定时事件的执行，遍历当前非定时事件，遇到需要处理的事件，就放入到已就绪的fired队列中，然后遍历这个队列进行fd事件的处理。直到定时事件的发生。依次循环完成了redis事件库的驱动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;管道(pipelining)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。就是可以同时处理多个命令，最后一起读取结果。减少了每一次连接的时间。不管这个连接是RTT（连接慢）还是loopback（连接较快）。开启管道后效率可以提升五倍这样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pub/sub&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发布订阅是一种消息通信的模式，主要是为了解耦消息发布者和消息订阅者的耦合关系，类似于观察者模式。
redis的pub/sub是通过中间通道chaannel来实现的，其实就是key，然后通过subscribe／unsbuscribe/publish来对channel其实也就是key进行操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过期&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;访问这个key时，发现其过期，进行删除操作&lt;/li&gt;
&lt;li&gt;每隔10S，随机抽取20个key，删除过期的key，如果删除的大于25%，重复此操作&lt;/li&gt;
&lt;li&gt;在复制aof文件期间，发现过期key就会将del操作一起合并到aof文件中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;回收机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis在内存达到设置的最大值时采取近似LUR(近期最少使用)算法回收，有对应的回收策略。所以正常是需要设置maxmemory的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redis主从复制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis的slave在第一次连接或者重新连接master的时候，会发送一个同步命令，然后master会收集出所有对数据修改的命令，然后向slave发送数据文件，给slave加载到内存中去，master接着发送所有收集的命令，完成主从的同步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;持久化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;redis的持久化有两种，一种是rdb快照模式的数据备份，另外一种就是aof的命令备份模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;rdb
rdb就是通过fork出一个子进程来将现有的内存数据写入到一个rdb结尾的文件中，比如每五分钟进行一次数据备份，但是如果突然发送故障，会导致数据五分钟里面的数据丢失，所以需要aof的持久化方式。但是rdb在恢复数据的时候是比aof要快的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;aof
aof就是将redis执行的命令存储到一个结尾为aof的文件中，这个可以安排每秒进行一次备份操作，这样最多丢失一秒的数据。就具有很强的持久化能力了。而且aof会对文件进行重写，使得aof文件不易变的那么庞大。并且命令集便于分析查看。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;信号与连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SIGTERM 设置一个定时任务SHUTDOWNredis实例。&lt;/p&gt;

&lt;p&gt;SIGSEGV
SIGBUS
SIGFPE
SIGILL
直接终止。&lt;/p&gt;

&lt;p&gt;redis连接也是基于socket，默认最大10000个客户端连接，可配置maxclients，可对客户端连接设置超时装置。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;redis使用&#34;&gt;redis使用&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;内存优化&#34;&gt;内存优化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用特殊编码&lt;/li&gt;
&lt;li&gt;使用32位实例内存要控制在4G内&lt;/li&gt;
&lt;li&gt;使用bit级和byte级操作&lt;/li&gt;
&lt;li&gt;尽可能的使用hashes&lt;/li&gt;
&lt;li&gt;注意内存分配&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;redis事务&#34;&gt;redis事务&lt;/h3&gt;

&lt;p&gt;开启一个事务 MULTI 后面跟着操作，在执行EXEC前是不会被执行的，直到执行命令EXEC&lt;/p&gt;

&lt;p&gt;在redis事务中有错误是不会回滚的，会返回错误继续执行下去，因为没有回滚的必要，必然是编码问题导致的。&lt;/p&gt;

&lt;p&gt;放弃事务 DISCARD&lt;/p&gt;

&lt;p&gt;乐观锁 WATCH 就是对key保持观察，在key发生变化期间不能完成当前对事务对操作。&lt;/p&gt;

&lt;h3 id=&#34;大量数据的插入&#34;&gt;大量数据的插入&lt;/h3&gt;

&lt;p&gt;使用redis客户端的pipe模式，原理同管道。&lt;/p&gt;

&lt;p&gt;也可以重文件导入大量的数据，将命令写在txt文档里面，最好是文档进行转码，在server里面导入，结合上面的pipe模式比较实用。&lt;/p&gt;

&lt;h3 id=&#34;redis配置&#34;&gt;redis配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以通过客户端&amp;ndash;命令行配置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以通过服务config命令行实现运行时配置修改。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置有空格用双引号。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;redis持久化&#34;&gt;redis持久化&lt;/h3&gt;

&lt;p&gt;数据备份&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。&lt;/li&gt;
&lt;li&gt;确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。&lt;/li&gt;
&lt;li&gt;至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;容灾备份&lt;/p&gt;

&lt;p&gt;Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。例如Amazon S3以及其他类型的S3，或者VPS来保存数据文件。&lt;/p&gt;

&lt;p&gt;rdb文件：默认情况下，redis数据库快照是保存在dump.rdb文件中，可以手动设置，在配置文件中save/bgsave&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAVE 60 1000   在60秒里有1000个键的改动。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aof文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;appendonly yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redis会执行BGRWEWRITEAOF来进行数据的重写操作，如果aof文件损坏，可以使用redis-check-aof来修复。&lt;/p&gt;

&lt;p&gt;正常建议同时使用rdb和aof持久化。&lt;/p&gt;

&lt;h3 id=&#34;redis-安全&#34;&gt;redis 安全&lt;/h3&gt;

&lt;p&gt;redis在安全方面并没有做太多的优化，只是支持密码的校验，通过AUTH来设置，还有只是对一些命令对禁用，使用配置文件中rename-command.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>