<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/tool/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/tool/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>chrome的开发者工具</title>
      <link>http://kingjcy.github.io/blog/2017/06/07/chrome%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 07 Jun 2017 15:56:36 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/07/chrome%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;chrome的开发者工具在开发过程中是十分常用的，这边整理一些。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Elements: 允许我们从浏览器的角度看页面，也就是说我们可以看到chrome渲染页面所需要的的HTML、CSS和DOM(Document Object Model)对象。此外，还可以编辑这些内容更改页面显示效果；
Network: 可以看到页面向服务器请求了哪些资源、资源的大小以及加载资源花费的时间，当然也能看到哪些资源不能成功加载。此外，还可以查看HTTP的请求头，返回内容等；
Sources: 主要用来调试js；
Timeline: 提供了加载页面时花费时间的完整分析，所有事件，从下载资源到处理Javascript，计算CSS样式等花费的时间都展示在Timeline中；
Profiles: 分析web应用或者页面的执行时间以及内存使用情况；
Resources: 对本地缓存（IndexedDB、Web SQL、Cookie、应用程序缓存、Web Storage）中的数据进行确认及编辑；
Audits: 分析页面加载的过程，进而提供减少页面加载时间、提升响应速度的方案；
Console: 显示各种警告与错误信息，并且提供了shell用来和文档、开发者工具交互。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;快速编辑HTML元素&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;选择开发工具面板的Elements
在Elements下的元素编辑器中选择一个DOM元素
右击选择edit as html，然后进行编辑&lt;/p&gt;

&lt;p&gt;右击的辅助功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Add Attribute: 在标签中增加新的属性；
Force Element State: 有时候我们为页面元素添加一些动态的样式，比如当鼠标悬停在元素上时的样式，这种动态样式很难调试。我们可以使用Force Element State强制元素状态，便于调试，如下图：
![图4. 强制元素状态][4]
Edit as HTML: 以HTML形式更改页面元素；
Copy XPath: 复制XPath；
Delete Node: 删除DOM节点；
Break On: 设置DOM 断点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elements右面展示的是css属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Styles: 显示用户定义的样式，比如请求的default.css中的样式，和通过Javasript生成的样式，还有开发者工具添加的样式；
Computed: 显示开发者工具计算好的元素样式；
Event Listeners: 显示当前HTML DOM节点和其祖先节点的所有JavaScript事件监听器，这里的监听脚本可以来自Chrome的插件。可以点击右边小漏斗形状(filter)选择只显示当前节点的事件监听器。
DOM Breakpoints: 列出所有的DOM 断点；
Properties: 超级全面地列出当前选中内容的属性，不过基本很少用到。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;network&lt;/p&gt;

&lt;p&gt;请求的每个资源在Network表格中显示为一行，每个资源都有许多列的内容(如红色区块1)，不过默认情况下不是所有列都显示出来，可以右击来选择，每一个文件点击都有具体的传输过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Headers 该资源的HTTP头信息。
Preview 根据你所选择的资源类型（JSON、图片、文本）显示相应的预览。
Response 显示HTTP的Response信息。
Cookies 显示资源HTTP的Request和Response过程中的Cookies信息。
Timing 显示资源在整个请求生命周期过程中各部分花费的时间。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;快速获取curl，network获取的资源上右击copy-&amp;gt;copy as cURL&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gulp</title>
      <link>http://kingjcy.github.io/blog/2017/06/06/gulp/</link>
      <pubDate>Tue, 06 Jun 2017 10:56:22 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/06/gulp/</guid>
      <description>&lt;p&gt;编译工具gulp&lt;/p&gt;

&lt;p&gt;Gulp 是一个构建工具，一个 streaming 构建工具，一个 nodejs 写的构建工具，类似于make的工具，gulpfile.js类似于makefile由一个个task组成.可以用于很多类型工程的编译。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install —global gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但最多的是作为项目的开发依赖（devDependencies）安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install —save-dev gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建gulpfile.js文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&amp;quot;gulp&amp;quot;);
var ts = require(&amp;quot;gulp-typescript&amp;quot;);
var tsProject = ts.createProject(&amp;quot;tsconfig.json&amp;quot;);

gulp.task(&amp;quot;default&amp;quot;, function () {
    return tsProject.src()
            .pipe(tsProject())
                    .js.pipe(gulp.dest(&amp;quot;dist&amp;quot;));
                    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后直接运行gulp就默认执行default的task。&lt;/p&gt;

&lt;p&gt;也可以指定task&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般task 有 3 个参数。&lt;/p&gt;

&lt;p&gt;默认default 是方法名称，可以自定义方法名称，直接用gulp编译或者在依赖中调用。可以说这个是入口，看ts项目的时候可以重这边开始看。&lt;/p&gt;

&lt;p&gt;[‘watch’] 这是依赖的作业列表，它们是由顺序的，按数组顺序依次执行。&lt;/p&gt;

&lt;p&gt;第三个参数是成功执行完上面的依赖作业后执行的回调函数。&lt;/p&gt;

&lt;p&gt;流式处理&lt;/p&gt;

&lt;p&gt;src 是输入&lt;/p&gt;

&lt;p&gt;dest 是输出&lt;/p&gt;

&lt;p&gt;pipe 是管道的意思，也是 stream 里核心概念，也就是说：上一个的输出，是下一个的输入&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes入门</title>
      <link>http://kingjcy.github.io/blog/2016/11/24/kubernetes%E5%85%A5%E9%97%A8/</link>
      <pubDate>Thu, 24 Nov 2016 09:41:30 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/11/24/kubernetes%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;p&gt;kubernetes是一种以容器为核心的，自动化部署应用程序的分布式的容器管理平台。它具有部署面广，可扩展，各种自动化的特性，容器是操作系统虚拟化，而不是硬件虚拟化，能够很好的隔离，互不干扰，并且很容易构建等特性。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;kubernetes架构是master/save，下面我们对每个节点上的组件进行了解&lt;/p&gt;

&lt;p&gt;master组件&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;apiserver是集群的核心，它提供来kubernetes的API，提供了集群管理的接口，是集群内各模块数据传输和通信的中心，还拥有完备的集群安全机制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;集群管理接口&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用于http请求&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认8080，可以通过启动参数“&amp;ndash;insecure-port”修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认ip为localhost，可以通过启动参数“&amp;ndash;insecure-bind-address”来修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不需要认证或者授权&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安全端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用于https请求&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认端口6443，可以通过启动参数“&amp;ndash;secure-port”修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认ip为非本地网络接口，可以通过启动参数“&amp;ndash;bind-address”来修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;需要认证或者授权&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认不启动&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以通过三种方式来访问apiserver提供的接口&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;REST API&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如访问nodes，我们可以访问/api/v1/proxy/nodes/{names}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;各种语言的client lib&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命令行kubectl&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;kubectl的原理是将输入的转化为REST API来调用，将返回结果输出。只是对REST API的一种封装，可以说是apiserver的一个客户端&lt;/p&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl [command] [options]

[command]
1. help 帮助命令，可以查找所有的命令，在我们不会用的适合，要学会使用这个命令。
    kubectl help
2. get   获取信息
    kubectl get po
3. describe  获取相关的详细信息
    kubectl describe po rc-nginx-2-btv4j
4. create  创建
    kubectl create -f rc-nginx.yaml
5. replace  更新替换
    kubectl replace -f rc-nginx.yaml 
6. patch  如果一个容器已经在运行，这时需要对一些容器属性进行修改，又不想删除容器，或不方便通过replace的方式进行更新。kubernetes还提供了一种在容器运行时，直接对容器进行修改的方式，就是patch命令.
    kubectl patch pod rc-nginx-2-kpiqt -p &#39;{&amp;quot;metadata&amp;quot;:{&amp;quot;labels&amp;quot;:{&amp;quot;app&amp;quot;:&amp;quot;nginx-3&amp;quot;}}}&#39;
7. edit edit提供了另一种更新resource源的操作

    kubectl edit po rc-nginx-btv4j 
    上面命令的效果等效于：
    kubectl get po rc-nginx-btv4j -o yaml &amp;gt;&amp;gt; /tmp/nginx-tmp.yaml 
    vim /tmp/nginx-tmp.yaml 
    /*do some changes here */ 
    kubectl replace -f /tmp/nginx-tmp.yaml 

8. Delete  删除
    kubectl delete -f rc-nginx.yaml
    kubectl delete po rc-nginx-btv4j
    kubectl delete po -lapp=nginx-2

9. logs    显示日志，跟docker的logs命令类似。如果要获得tail -f 的方式，也可以使用-f选项。
    kubectl logs rc-nginx-2-kpiqt 
10. rolling-update  滚动更新.
    kubectl rolling-update rc-nginx-2 -f rc-nginx.yaml，
    这个还提供如果在升级过程中，发现有问题还可以中途停止update，并回滚到前面版本 
    kubectl rolling-update rc-nginx-2 —rollback

11. scale 扩容缩容
    kubectl scale rc rc-nginx-3 —replicas=4 

12. 以上都是常用的，其他的可以使用时通过help去使用

[options]
1. -n=--namespace 指定命名空间
2. 其他的可以通过kubectl options来查看使用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apiserver的作用和原理&lt;/p&gt;

&lt;p&gt;apiserver负责各个模块之间的通信，集群里的功能模块通过apiserver将信息存入到etcd中，其他模块通过apiserver读取这些信息，实现来模块之间的交互，比如，node上的kubelet隔一段时间将自身的信息报告给apiserver，apiserver接受这些信息存入到etcd中，controller manager 中的node controller定期读取这些信息然后作出相应的处理。&lt;/p&gt;

&lt;p&gt;apiserver是一套基于restful类型的接口，我们来通过源码解析看服务的启动和实现&lt;/p&gt;

&lt;p&gt;看源码，先了解kubernetes的源码结构，cmd是入口，pkg是主要实现。&lt;/p&gt;

&lt;p&gt;看apiserver的入口文件kubernetes-1.6.1/cmd/kube-apiserver/apiserver.go,比较简单，主要是初始化一些结构，然后调用run来实现apiserver的启动。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    rand.Seed(time.Now().UTC(). UnixNano())

    s := options.NewServerRunOptions()  //新建一个APIServer对象，APIServer结构体
    s.AddFlags(pflag.CommandLine)       //命令行参数输入

    flag.InitFlags()                    //解析并格式化传入的参数，填充kubeletserver结构体
    logs.InitLogs()                     //初始化日志
    defer logs.FlushLogs()              //刷新日志到磁盘，这边用了defer，可见是在进程推出后保存日志

    verflag.PrintAndExitIfRequested()

    if err := app.Run(s); err != nil {          //启动，run
        fmt.Fprintf(os.Stderr, &amp;quot;%v\n&amp;quot;, err)
        os.Exit(1)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后主要在run函数中实现&lt;/p&gt;

&lt;p&gt;scheduler&lt;/p&gt;

&lt;p&gt;controller-manager是管理器的控制者。使用是集群管理控制中心。内部对应控制器如下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;replication controller副本控制 ,它的主要作用是确保规定数量的pod正常运行。当然他是通过rc机制实现的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它的作用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重新调度 就是上面说的能确保规定数量的pod运行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;弹性伸缩 可以通过spec.replicas来改变pod的数量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;滚动更新 一个一个pod的更新&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;node controller节点管理。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先我们需要了解kubelet通过apiserver想etcd中存储的节点信息有节点健康状况，节点资源，节点名称地址，操作系统版本，docker版本，kubelet版本等等，其中一个节点健康状况分为三种True，false，unknown三种状态，也是最直接的节点状态&lt;/p&gt;

&lt;p&gt;然后这个控制器就会重etcd中逐个节点读取这些状态，将来自kubelet状态来改变node controller中nodestatusmap中状态，对于状态不对的node节点加入一个队列，等待确认node是否有问题，有问题就进行信息同步，并且删除节点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;resourcequota controller资源配额&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这一个功能十分必要，它确保任何对象任何时候都不会超量占用资源，确保来系统的稳定性。目前k8s支持三个层次的资源配额&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;容器级别  可以限制cpu和memory&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pod级别  对pod内所有容器的可用资源进行限制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;namespace级别  pod数量，rc数量 service数量，rq数量，secret数量，persistent volume数量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现机制：准入机制（admission caotrol）&lt;/p&gt;

&lt;p&gt;在etcd中会维护一个资源配额记录，每次用户通过apiserver进行请求时，这个控制器会先进行计算，如果资源不过就会拒绝请求。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;namespace controller主要是监控namespace的状态，在其失效的情况下,对其进行处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;serviceAccount controller和token controller&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是两个安全监控，在apiserver启动的时候使用serviceaccount，就会产生一个key和crt，那么在controller mansge启动的时候通过参数指定这个key就会自动创建一个secret，也会创建一个token controller完成对serviceaccount的监控。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;service controller和endpoint controller&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个就是对service和endpoint进行监控对管理器。&lt;/p&gt;

&lt;p&gt;save组件&lt;/p&gt;

&lt;p&gt;kubelet&lt;/p&gt;

&lt;p&gt;proxy&lt;/p&gt;

&lt;p&gt;pod: 一种应用的实例，例如一个web站点，包含前端，后端，数据库这三个容器，放在一个pod中对外就是一个web服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod的四种状态

pending pod已经创建，但是内部镜像还没有完全创建
running 容器已经创建，至少有一个容器处于运行状态
succeeded  pod内容器都成功终止，且不会重启
failed  所有容器已经退出，至少有一个是因为发生错误而退出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;service：pod的路由代理的抽象，外围通过service提供的地址进行交互，而service来和变化的pod进行交互。&lt;/p&gt;

&lt;p&gt;endpoint：&lt;/p&gt;

&lt;p&gt;replicationController：pod的服务抽象，动态解决pod的扩容缩容问题。保持pod的资源的备份数一定。&lt;/p&gt;

&lt;p&gt;Label:是联系pod和service，replicationController的一种标志，它是由key/value形成的，比如一个pod的label：app=bake,那么service和replicationController也可以通过label:app=bake来对pod进行操作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go项目--frp</title>
      <link>http://kingjcy.github.io/blog/2016/06/17/go%E9%A1%B9%E7%9B%AE--frp/</link>
      <pubDate>Fri, 17 Jun 2016 09:54:42 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/06/17/go%E9%A1%B9%E7%9B%AE--frp/</guid>
      <description>&lt;p&gt;frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, udp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;首先需要安装go语言环境，然后可以直接使用go工具来下载安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/fatedier/frp
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会在对应的bin文件中产生可执行文件，在对应的conf下有对应的配置文件&lt;/p&gt;

&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;

&lt;h3 id=&#34;ssh内网穿透&#34;&gt;ssh内网穿透&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改 frps.ini 文件，配置一个名为 ssh 的反向代理：&lt;/p&gt;

&lt;h1 id=&#34;frps-ini&#34;&gt;frps.ini&lt;/h1&gt;

&lt;p&gt;[common]
bind_port = 7000&lt;/p&gt;

&lt;p&gt;[ssh]
listen_port = 6000
auth_token = 123&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动 frps：&lt;/p&gt;

&lt;p&gt;./frps -c ./frps.ini&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改 frpc.ini 文件，设置 frps 所在服务器的 IP 为 x.x.x.x；&lt;/p&gt;

&lt;p&gt;#frpc.ini
[common]
server_addr = x.x.x.x
server_port = 7000
auth_token = 123&lt;/p&gt;

&lt;p&gt;[ssh]
local_ip = 127.0.0.1
local_port = 22&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动 frpc：&lt;/p&gt;

&lt;p&gt;./frpc -c ./frpc.ini&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过 ssh 访问内网机器，假设用户名为 test：&lt;/p&gt;

&lt;p&gt;ssh -oPort=6000 test@x.x.x.x&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有很多应用参考 &lt;a href=&#34;https://github.com/fatedier/frp/blob/master/README_zh.md&#34;&gt;https://github.com/fatedier/frp/blob/master/README_zh.md&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;godep&#34;&gt;godep&lt;/h2&gt;

&lt;p&gt;godep是go的包管理工具，便于编码中对第三方依赖包对管理。&lt;/p&gt;

&lt;h3 id=&#34;安装-1&#34;&gt;安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;确保已经有go语言的环境并且设置好了 GOPATH 环境变量。&lt;/li&gt;
&lt;li&gt;使用 go get -u github.com/tools/godep 下载 godep 包并自动安装。&lt;/li&gt;
&lt;li&gt;godep 可执行程序会放在 $GOPATH/bin 目录下。所以想直接用 godep 执行命令的话需要将该路径加入到全局的环境变量 PATH 中，可以将export PATH=&amp;ldquo;$PATH:$GOPATH/bin&amp;rdquo;加入到系统启动脚本中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;基本使用-1&#34;&gt;基本使用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;构建项目&lt;/p&gt;

&lt;p&gt;godep save 或者 godep save ./&amp;hellip; 后者会递归查找所有引用的第三方包。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个命令做了以下几件事：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 查找项目中所用到的所有的第三方包
2. 在项目目录下创建 Godeps 目录，Godeps/Godeps.json 是依赖文件，包括了go的版本，用到的第三包的引入路径，版本号等信息，json文件需要一并加入到版本控制里。
3. 所有依赖的第三包的代码会被拷贝到 Godeps/_workspace/src 下，并且移除了 .git 这样的版本控制信息。Godeps/_workspace 里的内容如果加到版本控制里，别人下载代码后可以直接编译，不需要另外再下依赖包，但是项目大小会变大。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载第三方源码&lt;/p&gt;

&lt;p&gt;godep restore&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个命令是根据 Godeps/Godeps.json 文件把项目的依赖包下载到 $GOPATH 目录下，需要注意这个命令是会修改 $GOPATH 下依赖包的状态的，所以最好还是将 Godeps/_workspace 里的内容直接加到自己项目的版本控制里。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;其他命令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他的 go 命令基本上都可以通过 godep 执行，godep 封装的 go 命令其实就是将 Godeps/_workspace 加入到 GOPATH 中，这样编译的时候就会去 Godeps/_workspace 中寻找第三方包。&lt;/p&gt;

&lt;h2 id=&#34;源码解析&#34;&gt;源码解析&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>shell 积累</title>
      <link>http://kingjcy.github.io/blog/2016/03/02/shell-%E7%A7%AF%E7%B4%AF/</link>
      <pubDate>Wed, 02 Mar 2016 17:26:28 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/03/02/shell-%E7%A7%AF%E7%B4%AF/</guid>
      <description>&lt;p&gt;shell主要是用于linux的系统操作的脚本语言，python主要适用于web界面的，如果用python写一些linux系统的东西会比较冗余。&lt;/p&gt;

&lt;p&gt;shell是一个命令解释器，也就是我们常说的bash(bash只是shell中最常用的一种，还有很多shell解释器)，是与操作系统直接进行交互的还可以支持多种编程化操作的强大工具。&lt;/p&gt;

&lt;p&gt;shell是一种很强大的脚本语言，也是操作终端的利器，用好shell可以让你在linux环境开发中如鱼得水，这边别学习别记录，便于备忘与查找。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;不适合shell的场景&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;密集型任务，需要计算，hash，排序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对跨平台和安全性有要求的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大量文件操作，图型操作，io和socket&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些不适用的场景可以用强大一点的脚本语言python，ruby，perl，或者高层次的编译语言c/c++，java等。&lt;/p&gt;

&lt;p&gt;##shell基本语法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;开头
#!/bin/sh&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;符号#!用来告诉系统它后面的参数是用来执行该文件的程序,是一个解释器的标记。在这个例子中我们使用/bin/sh来执行程序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 #!/bin/sh
2 #!/bin/bash
3 #!/usr/bin/perl 
4 #!/usr/bin/tcl 
5 #!/bin/sed -f
6 #!/usr/awk -f
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;特殊字符&lt;/p&gt;

&lt;h1 id=&#34;注释&#34;&gt;注释&lt;/h1&gt;

&lt;p&gt;/ 转义
; 命令分隔符
;; case终止符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case &amp;quot;$variable&amp;quot; in
abc) echo &amp;quot;\$variable = abc&amp;quot; ;; 
xyz) echo &amp;quot;\$variable = xyz&amp;quot; ;; 
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;. source/正则中匹配任意字符
, 逗号链接了一系列的算术操作,虽然里边所有的内容都被运行了,但只有最后一项被 返回
` 后置引用,命令替换&lt;/p&gt;

&lt;dl&gt;
&lt;dd&gt;&lt;p&gt;空命令
$ 变量替换,在正则表达式中作为行结束符
${} 参数替换
() 命令组.如:(a=hello;echo)  在()中的命令列表,将作为一个子 shell 来运行. 在()中的变量,由于是在子 shell 中,所以对于脚本剩下的部分是不可用的. 如:&lt;/p&gt;

&lt;p&gt;a=123
( a=321; )&lt;/p&gt;

&lt;p&gt;echo&amp;rdquo;a=$a&amp;rdquo;&lt;/p&gt;

&lt;p&gt;a=123&lt;/p&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;{} 这个结构创建了一个匿名的函数.但是与函数不同的是,在其中声明的变量,对于脚本其他部分的代码来说还是可见的,在大括号中,不允许有空白,除非这个空白是有意义的
    a=123
    ( a=321; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo&amp;quot;a=$a&amp;quot; 

a=321
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;amp;&amp;gt;&amp;gt;&amp;amp;&amp;gt;&amp;gt;&amp;lt; 重定向.
scriptname &amp;gt;filename 重定向脚本的输出到文件中.覆盖文件原有内容.
command &amp;amp;&amp;gt;filename 重定向 stdout 和 stderr 到文件中
command &amp;gt;&amp;amp;2 重定向 command 的 stdout 到 stderr
scriptname &amp;gt;&amp;gt;filename 重定向脚本的输出到文件中.添加到文件尾端,如果没有文件, 则创建这个文件.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;| 管道
子进程的运行的管道,不能够改变脚本的变量.
1 variable=&amp;ldquo;initial_value&amp;rdquo;
2 echo &amp;ldquo;new_value&amp;rdquo; | read variable
3 echo &amp;ldquo;variable = $variable&amp;rdquo; #variable = initial_value&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;| 强制重定向&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;|| 或-逻辑操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 if [ $condition1 ] || [ $condition2 ]
2 if [ $condition1 -o $condition2 ] 相同
3 # 如果 condition1 或 condition2 为 true,那结果就为 true.
4
5 if [[ $condition1 || $condition2 ]] # 也可以
6 # 注意||不允许出现在[ ... ]中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;amp;&amp;amp; 与-逻辑操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 if [ $condition1 ] &amp;amp;&amp;amp; [ $condition2 ]
2 与if [ $condition1 -a $condition2 ] 相同
3 # 如果 condition1 和 condition2 都为 true,那结果就为 true.
4
5 if [[ $condition1 &amp;amp;&amp;amp; $condition2 ]] # 也可以.
6 # 注意&amp;amp;&amp;amp;不允许出现在[ ... ]中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;- 选项,前缀.在所有的命令内如果想使用选项参数的话,前边都要加上&amp;rdquo;-&amp;ldquo;,之前工作的目录&lt;/p&gt;

&lt;p&gt;^ 行首,正则表达式中表示行首.&amp;ldquo;^&amp;ldquo;定位到行首.&lt;/p&gt;

&lt;p&gt;exit 退出脚本&lt;/p&gt;

&lt;p&gt;((&amp;hellip;))与 let 命令很像,允许算术扩展和赋值.举个简单的例子 a=$(( 5 + 3 )),将把 a 设为 &amp;ldquo;5+3&amp;rdquo;或者 8.然而,双圆括号也是一种在 Bash 中允许使用 C 风格的变量处理的机制.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明，直接赋值就可以，应用变量的话，用$+变量名的形式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;等号前后不能有空格,如果赋值后面是执行语句，需要用&lt;code&gt;来表示，执行语句都是用&lt;/code&gt;都可以不一定语句后&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A=(1 1 2 3)  定义
${A[i]}    取数组的值,重0开始的
${A[@]}     显示所有的参数
${#A[@]}    显示参数的个数
${A[@]/1/2}  将一换成2
unset A[2]  删除A[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function command()
{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;写入文件并覆盖旧文件
&amp;gt; 加到文件的尾部，保留旧文件内容。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;流程控制&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;判断&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if .... then 
.... 
elif .... then 
.... 
else 
.... 
fi

当 if 和 then 在一个条件测试的同一行中的话,必须使用&amp;quot;;&amp;quot;


通常用&amp;quot; [ ] &amp;quot;来表示条件测试。注意这里的空格很重要。要确保方括号的空格。 
[ -f &amp;quot;somefile&amp;quot; ] ：判断是否是一个文件 
[ -x &amp;quot;/bin/ls&amp;quot; ] ：判断/bin/ls是否存在并有可执行权限 
[ -n &amp;quot;$var&amp;quot; ] ：判断$var变量是否有值 
[ &amp;quot;$a&amp;quot; = &amp;quot;$b&amp;quot; ] ：判断$a和$b是否相等 ,注意“=”和变量之间要有空格。
多重条件可以用&amp;amp;&amp;amp;或者||来逻辑判断，但是用两个[]来使用，例如[]||[]

1.整数比较 
-eq 等于,如:if [ &amp;quot;$a&amp;quot; -eq &amp;quot;$b&amp;quot; ]   
-ne/!= 不等于,如:if [ &amp;quot;$a&amp;quot; -ne &amp;quot;$b&amp;quot; ] 
-gt 大于,如:if [ &amp;quot;$a&amp;quot; -gt &amp;quot;$b&amp;quot; ]   
-ge 大于等于,如:if [ &amp;quot;$a&amp;quot; -ge &amp;quot;$b&amp;quot; ]   
-lt 小于,如:if [ &amp;quot;$a&amp;quot; -lt &amp;quot;$b&amp;quot; ]   
-le 小于等于,如:if [ &amp;quot;$a&amp;quot; -le &amp;quot;$b&amp;quot; ]   
&amp;lt;   小于(需要双括号),如:((&amp;quot;$a&amp;quot; &amp;lt; &amp;quot;$b&amp;quot;))   
&amp;lt;=  小于等于(需要双括号),如:((&amp;quot;$a&amp;quot; &amp;lt;= &amp;quot;$b&amp;quot;))   
&amp;gt;   大于(需要双括号),如:((&amp;quot;$a&amp;quot; &amp;gt; &amp;quot;$b&amp;quot;))   
&amp;gt;   &amp;gt;=  大于等于(需要双括号),如:((&amp;quot;$a&amp;quot; &amp;gt;= &amp;quot;$b&amp;quot;))   



2.字符串比较

= 等于,如:if [ &amp;quot;$a&amp;quot; = &amp;quot;$b&amp;quot; ]   
== 等于,如:if [ &amp;quot;$a&amp;quot; == &amp;quot;$b&amp;quot; ],与=等价  




[[ $a == z* ]]   # 如果$a以&amp;quot;z&amp;quot;开头(模式匹配)那么将为true   
[[ $a == &amp;quot;z*&amp;quot; ]] # 如果$a等于z*(字符匹配),那么结果为true   

  [ $a == z* ]     # File globbing 和word splitting将会发生   
  [ &amp;quot;$a&amp;quot; == &amp;quot;z*&amp;quot; ] # 如果$a等于z*(字符匹配),那么结果为true



还有一些参数的比较见下面一个专题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while
while表达式： ----------while read line    这边的line只是一个变量，read应该读到换行符就解释
while ...; do 
.... 
done &amp;lt; filename   -----追加文件输入

可以用关键字&amp;quot;break&amp;quot; 用来跳出循环；也可以用关键字”continue”用来不执行余下的部分而直接跳到下一个循环。大部分和for差不多，但是有一些必须使用while，比如无限循环。一般和read一起使用对文件进行操作，比如行操作，read line大部分和for差不多，但是有一些必须使用while，比如无限循环。一般和read一起使用，read读取数据。，read读取数据。

for var in ....; do 
.... 
done 

在一个 for 循环中忽略[list]的话,将会使循环操作$@(从命令行传递给脚本的参数

也可以使用命令替换来产生 for 循环的[list],例如`seq 1 15`

for在shell中十分强大，它在批量操作，批量部署上有这个很大的优势。

until 条件
do
done

直到条件满足才退出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case &amp;quot;$variable&amp;quot; in
&amp;quot;$condition1&amp;quot;) command...
;;
&amp;quot;$condition1&amp;quot;) command...
;;
esac
注意: 对变量使用&amp;quot;&amp;quot;并不是强制的,因为不会发生单词分离. 每句测试行,都以右小括号)结尾.
每个条件块都以两个分号结尾;;.
case 块的结束以 esac(case 的反向拼


select i in var
do
done

一般与变量PS3结合使用

PS3=&amp;quot;what do you like:&amp;quot;
selct i in centos ubuntu readhat
do 
    echo &amp;quot;you like $i&amp;quot;
done

1)centos
2)ubuntu
3)readhat
what do you like:1
you like centos

可以结合上面的case进行步骤操作。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;awk&#34;&gt;awk&lt;/h2&gt;

&lt;p&gt;awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;{pattern + action}&amp;rsquo; {filenames}
尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。&lt;/p&gt;

&lt;p&gt;awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。&lt;/p&gt;

&lt;p&gt;通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@www ~]# last -n 5 &amp;lt;==仅取出前五行
root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in
root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)
root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)
dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)
root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是显示最近登录的5个帐号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#last -n 5 | awk  &#39;{print $1}&#39;
root
root
root
dmtsai
root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;awk工作流程是这样的：读入有&amp;rsquo;\n&amp;rsquo;换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&amp;rdquo;空白键&amp;rdquo; 或 &amp;ldquo;[tab]键&amp;rdquo;,所以$1表示登录用户，$3表示登录用户ip,以此类推。&lt;/p&gt;

&lt;p&gt;NF最后一行，NR是最后一列。&lt;/p&gt;

&lt;p&gt;指定分隔符 awk -F: &amp;lsquo;{print &amp;ldquo;01: &amp;ldquo;$1}&amp;lsquo;,这个就以：分域了。可以在print中添加注解，相当于拼接字符串。&lt;/p&gt;

&lt;p&gt;简单用法，有时间继续补充&lt;/p&gt;

&lt;h2 id=&#34;空格&#34;&gt;空格&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;等号赋值两边不能有空格, var=string command,针对=后面跟上命令的，可以有空格，但是后面的命令必须要用``来执行，注意&lt;/li&gt;
&lt;li&gt;命令与选项之间需要空格&lt;/li&gt;
&lt;li&gt;管道两边空格可有可无&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;sed&#34;&gt;sed&lt;/h2&gt;

&lt;p&gt;sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法&lt;/p&gt;

&lt;p&gt;sed命令行格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed [-nefri] ‘command’ 输入文本

常用选项：
    -n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
    -e∶直接在指令列模式上进行 sed 的动作编辑；
    -f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；
    -r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
    -i∶直接修改读取的档案内容，而不是由萤幕输出。 不加则不修改源文件      

常用命令：
     a   ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
     c   ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
     d   ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
     i   ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
     p  ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～
     s  ∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

主要用于查找替换

sed &amp;quot;s/a/b/g&amp;quot; filename      替换，b替换a
sed &amp;quot;s/^/&amp;amp; /g&amp;quot; filename     开头是^,结尾是$,添加&amp;amp;，这些都是正则里面的，可以用于其他的比如grep，学会举一反三
sed &amp;quot;/a/a b/&amp;quot; filename      查找追加，追加a，在前面加i
sed &amp;quot;1p&amp;quot;                    打印第一行，一到五行1，5p，匹配打印这一行/a/p,最后一行$p

例如：

1. 在文件最后追加一些内容，常用于配置

sed -i &amp;quot;$a 内容&amp;quot; filename 可以用于追加内容，但是觉得还是直接用echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; filename好一点

2.还可以在每个行首行尾追加内容

sed -i &amp;quot;s/$/&amp;amp; 内容/g&amp;quot; filename
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;变量&#34;&gt;$变量&lt;/h2&gt;

&lt;p&gt;特殊变量列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;变量     含义
$0     当前脚本的文件名
$n     传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
$#     传递给脚本或函数的参数个数。
$*     传递给脚本或函数的所有参数。
$@     传递给脚本或函数的所有参数。被双引号(&amp;quot; &amp;quot;)包含时，与 $* 稍有不同，下面将会讲到。
$?     上个命令的退出状态，或函数的返回值。0表示成功，可以用于脚本的命令执行状态的判断。
$$     当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开头
    #!/bin/sh&lt;/p&gt;

&lt;h3 id=&#34;多台服务器&#34;&gt;多台服务器&lt;/h3&gt;

&lt;p&gt;ue是很好的文本编辑器，用于处理文本编辑上具有很大的优势，包括块处理，替换，编码上，要学会用它来编辑我们需要的文档，比如今天的ip端口的整理替换用于shell脚本来跑&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装redis&lt;/p&gt;

&lt;p&gt;redis=(10.147.0.1 10.147.0.107 10.147.0.16 10.147.0.31 10.147.0.17 10.147.0.32 10.147.0.46 10.147.0.61 10.147.0.47 10.147.0.62 10.147.0.76 10.147.0.91 10.147.0.77 10.147.0.92)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这边给变量赋值，这些ip在ue中可以很好的处理。等于号前后不能有空格，数组就是用大括号和逗号来表达&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for x in ${redis[@]}
do
ssh $x -t &amp;quot;mkdir -p /root/redis&amp;quot;
done

for x in ${redis[@]};do scp redis-3.2.8.tar.gz root@$x:/root/redis; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边把安装包重一台机器上复制到所有的机器上。-t 该参数通过指定一个伪终端迫使SecureShell客户端以交互模式工作，即使在给定命令的情况下也是如此。它被用于执行在远地主机上的基于屏幕的程序。通过-t参数来执行后面的命令，然后退出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for x in ${redis[@]}
do 
ssh $$x -t &amp;quot;tar -zxf redis-3.2.8.tar.gz &amp;amp;&amp;amp; cd redis-3.2.8 &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make PREFIX=/usr/lib/redis install &amp;amp;&amp;amp; chown -R  hnapp:hnapp /usr/lib/redis &amp;amp;&amp;amp; chmod 777 -R /usr/lib/redis&amp;quot;&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边就是把所有的机器上安装上redis,可以将所有的命令进行联合用&amp;amp;&amp;amp;。这样用shell的for循环在一台机器上处理所有机器的安装，可以大幅度提高工作效率和减少出错。&lt;/p&gt;

&lt;p&gt;修改所有机器的密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for x in ${cxx[@]}; do ssh $x -t &amp;quot;echo Rljgvz0j | passwd --stdin root&amp;quot;; done
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建集群的配置文件&lt;/p&gt;

&lt;p&gt;for x in ${redis[@]}; do ssh $x -t &amp;ldquo;mkdir /usr/lib/redis/conf&amp;rdquo;; done
cd /usr/lib/redis/conf
vi redis-common.conf
for x in ${redis[@]}; do scp redis-common.conf $x:&lt;code&gt;pwd&lt;/code&gt;; done&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以这样创建一个公共配置文件include在每个配置文件中,这边有一个pwd指令是指当前目录，上面这个是正常的方法，下面我们来使用单个配置文件&lt;/p&gt;

&lt;p&gt;首先在一台机器上创建一个配置文件redis-.conf，在文件文件中需要改变的设置为变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;daemonize yes
tcp-backlog 511
timeout 0
tcp-keepalive 0
loglevel notice
databases 16
dir xccccccccccccccccccc
slave-serve-stale-data yes
slave-read-only yes
repl-disable-tcp-nodelay yes
slave-priority 100
appendonly yes
appendfsync everysec
no-appendfsync-on-rewrite yes
auto-aof-rewrite-min-size 64mb
lua-time-limit 5000
cluster-enabled yes
cluster-node-timeout 15000
cluster-migration-barrier 1
slowlog-log-slower-than 10000
slowlog-max-len 128
notify-keyspace-events &amp;quot;&amp;quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
port 6379
maxmemory cxxxxxxxxxxxxx
maxmemory-policy allkeys-lru
appendfilename &amp;quot;appendonly-6379.aof&amp;quot;
dbfilename dump-6379.rdb
cluster-config-file nodes-6379.conf
auto-aof-rewrite-percentage 80-100
logfile xcxcxcxcxcxcxcxcxcxc
protected-mode no
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后写脚本redis_install.sh来替换变量，生成对应的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash                                                     ----shell脚本的可执行文件，类似的python都是这样声明

clusterName=$1                                                  ----获取shell的参数$1-n
memCache=$2 

----因为嵌套在下面的循环中，会导致冲突，所有这边单独拿出来跑一边
rm -f mkredisdir.sh
echo &amp;quot;#!/bin/bash&amp;quot; &amp;gt;&amp;gt; mkredisdir.sh
cat redis_$clusterName.txt | awk -F&#39;[: ]&#39; &#39;{for(i=2;i&amp;lt;=NF;i++){printf(&amp;quot;ssh %s -ttt \&amp;quot;mkdir -p /data1/redis/%s\&amp;quot; \n&amp;quot;,$1,$i)}}&#39; &amp;gt;&amp;gt; mkredisdir.sh  ----NF最后一行，NR是最后一列。
chmod 755 mkredisdir.sh
./mkredisdir.sh
if [ $? -ne 0 ];then
    exit 1
fi




while read line                                                 ----while循环结构do,done,读一行read line
do
    IP=`echo ${line} |  awk -F: &#39;{print $1}&#39;`                   ----获取文件中一行的ip,awk对line进行域划分，这边获取第一域            
    dirName=`echo /usr/lib/redis/conf/$clusterName/`            ----获取文件名，这个shell中用``来执行命令，获取对结果给变量
    portList=(`echo ${line} |  awk -F: &#39;{print $2}&#39; | tr -d &#39;|&#39;`)   ----这边获取端口list,用tr删除所有的|
    for x in ${portList[@]}                                         ----在端口中循环
    do

        logfile=&amp;quot;/data1/redis/$x/$x.log&amp;quot;                            ----获取日志文件名
        tmpFileName=/tmp/redis-$x.conf                              ----临时文件名,tmp目录下系统是自动清理的，一般清理十天前的文件
        sed &amp;quot;s/6379/$x/g&amp;quot; redis-.conf &amp;gt; $tmpFileName                ----把redis-.conf文件中的6379替换为变量$x重写到新文件中
        sed -i &amp;quot;s#xccccccccccccccccccc#/data1/redis/$x#g&amp;quot; $tmpFileName  ----这边是把新文件中的xccccccccccccccccccc替换为/data1/redis/$x，如果变量中含有／就用#
        sed -i &amp;quot;s/cxxxxxxxxxxxxx/$memCache/g&amp;quot; $tmpFileName
        sed -i &amp;quot;s#xcxcxcxcxcxcxcxcxcxc#$logfile#g&amp;quot; $tmpFileName
        scp $tmpFileName $IP:${dirName}/                                ----将对应的配置文件拷贝到对应主机的目录下
        if [ $? -ne 0 ];then                                            ----如果失败则退出
            echo &amp;quot;scp  $tmpFileName to $IP failed.&amp;quot;
            exit 1
        fi
    done
done &amp;lt; redis_${clusterName}.txt                                         ----输入文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写脚本的时候可以使用-X来调试shell脚本，&amp;rdquo;-x&amp;rdquo;选项可用来跟踪脚本的执行，是调试shell脚本的强有力工具。“-x”选项使shell在执行脚本的过程中把它实际执行的每一个命令行显示出来，并且在行首显示一个&amp;rdquo;+&amp;ldquo;号。 &amp;ldquo;+&amp;ldquo;号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令。 “-x”选项使用起来简单方便，可以轻松对付大多数的shell调试任务,应把其当作首选的调试手段。
这边需要看一下解析的文件才能看懂&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10.147.0.1:6000 6001
10.147.0.107:6020 6021
10.147.0.16:6040 6041
10.147.0.31:6060 6061
10.147.0.17:6080 6081
10.147.0.32:6100 6101
10.147.0.46:6120 6121
10.147.0.61:6140 6141
10.147.0.47:6160 6161
10.147.0.62:6180 6181
10.147.0.76:6200 6201
10.147.0.91:6220 6221
10.147.0.77:6240 6241
10.147.0.92:6260 6261
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以生成所有redis需要的配置文件并且在对应的主机路径,下面就是启动所有的redis&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for x in ${redis[@]}; do ssh $x; done  -------这样可以按循序一台台主机上进行操作，然后没有把握的大批量数据就这样操作，如果又把我可以直接ssh $x -t ``
find /usr/lib/redis/conf/ -name &amp;quot;*.conf&amp;quot; |  xargs -i /usr/lib/redis/bin/redis-server {}  ----获取的序列可以直接给{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动好后就要给redis配备集群角色了，先安装ruby，gem,以及redis的gem包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for x in ${redis[@]}; do  ssh $x -t &amp;quot;yum install -y ruby;gem install -l redis-3.2.2.gem&amp;quot;; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成tb脚本&lt;/p&gt;

&lt;p&gt;首先上面的文件处理成ip:port&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;{

for(i=2;i&amp;lt;=NF;i++){
    if (i!=NF){
        printf(&amp;quot;%s:%s &amp;quot;,$1,$i)
    }else{
        printf(&amp;quot;%s:%s \n&amp;quot;,$1,$i)}
}

}&#39; REDIS_W_DICT_NAT.txt &amp;gt; REDIS_W_DICT_NAT_cluster.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成shell脚本createsh.sh来生成对应的ruby脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

fileName=$1                                                                         ----正常获取启动参数
masterList=`awk &#39;{for(i=1;i&amp;lt;=NF;i++){                                               ----按行循环，如果这一列是奇数则取奇数位，偶数则取偶数位，最终获取所有的主的ip和port
    if(NR%2!=0){
        if(i%2!=0){
            printf(&amp;quot;\&amp;quot;%s\&amp;quot;,&amp;quot;,$i)
        }
    }else{
        if(i%2==0){
            printf(&amp;quot;\&amp;quot;%s\&amp;quot;,&amp;quot;,$i)
        }
    }
    }
}&#39; $fileName`


masterListForStr=`echo $masterList | tr -s &#39;,&#39; &#39; &#39; | tr -d &#39;&amp;quot;&#39;`                     ----将重复的空格和逗号都删除，并删除引号
masterList=`echo [${masterList%,}]`                                                     


num=1
master=&amp;quot;&amp;quot;
slave=&amp;quot;&amp;quot;
cxx1=(`sed -n &#39;1&#39;p $fileName`)                                                      ----p是打印对应的行，这个就是获取第一行
cxx2=(`sed -n &#39;2&#39;p $fileName`)
cxx3=(`sed -n &#39;3&#39;p $fileName`)
cxx4=(`sed -n &#39;4&#39;p $fileName`)
cxx5=(`sed -n &#39;5&#39;p $fileName`)
cxx6=(`sed -n &#39;6&#39;p $fileName`)
cxx7=(`sed -n &#39;7&#39;p $fileName`)
cxx8=(`sed -n &#39;8&#39;p $fileName`)
cxx9=(`sed -n &#39;9&#39;p $fileName`)
cxx10=(`sed -n &#39;10&#39;p $fileName`)
cxx11=(`sed -n &#39;11&#39;p $fileName`)
cxx12=(`sed -n &#39;12&#39;p $fileName`)
cxx13=(`sed -n &#39;13&#39;p $fileName`)
cxx14=(`sed -n &#39;14&#39;p $fileName`)

lineCount=`awk &#39;END{print NF}&#39; $fileName`                                           ----end是指处理完所有的执行，这边就是获取一行有多少个数据

num=0
num2=1
while [ $num -lt $lineCount ]
do
    eval str1=&#39;$&#39;{cxx1[${num}]}                                                     ----存在变量的变量需要用eval，获取第一列的所有数据
    eval str2=&#39;$&#39;{cxx2[${num}]}
    eval str3=&#39;$&#39;{cxx3[${num}]}
    eval str4=&#39;$&#39;{cxx4[${num}]}
    eval str5=&#39;$&#39;{cxx5[${num}]}
    eval str6=&#39;$&#39;{cxx6[${num}]}
    eval str7=&#39;$&#39;{cxx7[${num}]}
    eval str8=&#39;$&#39;{cxx8[${num}]}
    eval str9=&#39;$&#39;{cxx9[${num}]}
    eval str10=&#39;$&#39;{cxx10[${num}]}
    eval str11=&#39;$&#39;{cxx11[${num}]}
    eval str12=&#39;$&#39;{cxx12[${num}]}
    eval str13=&#39;$&#39;{cxx13[${num}]}
    eval str14=&#39;$&#39;{cxx14[${num}]}

    res=`expr $num2 % 2`                                                            ----执行算数用expr
    if [ &amp;quot;X$res&amp;quot; = &amp;quot;X1&amp;quot; ];then                                                      ----奇数重上往下，偶数重下往上，生成上下key/value结构，json格式
        str=&amp;quot;$str,\&amp;quot;${str1}\&amp;quot;:\&amp;quot;${str2}\&amp;quot;,\&amp;quot;${str3}\&amp;quot;:\&amp;quot;${str4}\&amp;quot;,\&amp;quot;${str5}\&amp;quot;:\&amp;quot;${str6}\&amp;quot;,\&amp;quot;${str7}\&amp;quot;:\&amp;quot;${str8}\&amp;quot;,\&amp;quot;${str9}\&amp;quot;:\&amp;quot;${str10}\&amp;quot;,\&amp;quot;${str11}\&amp;quot;:\&amp;quot;${str12}\&amp;quot;,\&amp;quot;${str13}\&amp;quot;:\&amp;quot;${str14}\&amp;quot;&amp;quot;
    else
        str=&amp;quot;$str,\&amp;quot;${str14}\&amp;quot;:\&amp;quot;${str13}\&amp;quot;,\&amp;quot;${str12}\&amp;quot;:\&amp;quot;${str11}\&amp;quot;,\&amp;quot;${str10}\&amp;quot;:\&amp;quot;${str9}\&amp;quot;,\&amp;quot;${str8}\&amp;quot;:\&amp;quot;${str7}\&amp;quot;,\&amp;quot;${str6}\&amp;quot;:\&amp;quot;${str5}\&amp;quot;,\&amp;quot;${str4}\&amp;quot;:\&amp;quot;${str3}\&amp;quot;,\&amp;quot;${str2}\&amp;quot;:\&amp;quot;${str1}\&amp;quot;&amp;quot;
    fi  

    ((num = num + 1))
    ((num2 = num2 + 1))
done

#echo $master
str=`echo $str | cut -c 2-`                                                         ----删除第一个逗号
str=`echo &amp;quot;{$str}&amp;quot;`

slaveListForStr=`/usr/bin/python &amp;lt;&amp;lt;EOF                                              ----开始结束,将python嵌入到shel中，输出字符直接给一个变量

allDict=$str                                                                        ----将json格式到字符串给python中到数组，类似于c++中到vector
masterList=$masterList
slaveStr=&amp;quot;&amp;quot;
for master in masterList:
    slaveStr=slaveStr + &amp;quot; &amp;quot; + allDict[master]                                       ----进行匹配
    print slaveStr


EOF`
echo &amp;quot;/root/redis-3.2.8/src/redis-trib.rb create --replicas 1 &amp;quot;$masterListForStr$slaveListForStr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成redis官方的tb脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/root/redis-3.2.8/src/redis-trib.rb create --replicas 1 ip:port                 -------这边是先都是主后面都是备，一一对应，这个脚本有自己均衡m/s的功能，不一定会按着对应分配master和slave，但是正常情况下都是对应的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可见shell的自动化脚本确实很强大，可以解决很多问题。&lt;/p&gt;

&lt;h2 id=&#34;test结构&#34;&gt;test结构&lt;/h2&gt;

&lt;p&gt;if test condition-true 这种形式和 if[condition-true]这种形式是等价的&lt;/p&gt;

&lt;p&gt;有一个专用命令&amp;rdquo;[&amp;ldquo;(左中括号,特殊字符).这个命令与 test 命令等价。在版本 2.02 的 Bash 中,推出了一个新的[[&amp;hellip;]]扩展 test 命令.因为这种表现形式可能对某些语 言的程序员来说更加熟悉.注意&amp;rdquo;[[&amp;ldquo;是一个关键字,并不是一个命令.&lt;/p&gt;

&lt;p&gt;Bash 把[[ $a -lt $b ]]看作一个单独的元素,并且返回一个退出码.&lt;/p&gt;

&lt;p&gt;[-f filename]相当于判断文件是否存在&lt;/p&gt;

&lt;p&gt;[-d dir]        判断目录是否存在&lt;/p&gt;

&lt;p&gt;[ -n string ]  –n 字符串 字符串的长度非零&lt;/p&gt;

&lt;p&gt;[ -z string ]  字符串的长度零&lt;/p&gt;

&lt;p&gt;[ -a FILE ] 如果 FILE 存在则为真。&lt;/p&gt;

&lt;p&gt;[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。&lt;/p&gt;

&lt;p&gt;[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。&lt;/p&gt;

&lt;p&gt;[ -d FILE ] 如果 FILE 存在且是一个目录则为真。&lt;/p&gt;

&lt;p&gt;[ -e FILE ] 如果 FILE 存在则为真。&lt;/p&gt;

&lt;p&gt;[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。&lt;/p&gt;

&lt;p&gt;[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。&lt;/p&gt;

&lt;p&gt;[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。&lt;/p&gt;

&lt;p&gt;[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。&lt;/p&gt;

&lt;p&gt;[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。&lt;/p&gt;

&lt;p&gt;[ -r FILE ] 如果 FILE 存在且是可读的则为真。&lt;/p&gt;

&lt;p&gt;[ -s FILE ] 如果 FILE 存在且大小不为0则为真。&lt;/p&gt;

&lt;p&gt;[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。&lt;/p&gt;

&lt;p&gt;[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。&lt;/p&gt;

&lt;p&gt;[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。&lt;/p&gt;

&lt;p&gt;[ -x FILE ] 如果 FILE 存在且是可执行的则为真。&lt;/p&gt;

&lt;p&gt;[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。&lt;/p&gt;

&lt;p&gt;[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。&lt;/p&gt;

&lt;p&gt;[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。&lt;/p&gt;

&lt;p&gt;[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。&lt;/p&gt;

&lt;p&gt;[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。&lt;/p&gt;

&lt;h3 id=&#34;shell内建变量&#34;&gt;shell内建变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$BASH
这个变量将指向 Bash 的二进制执行文件的位置.

$BASH_ENV
这个环境变量将指向一个 Bash 启动文件,这个启动文件将在调用一个脚本时被读取.

$BASH_SUBSHELL
这个变量将提醒 subshell 的层次,这是一个在 version3 才被添加到 Bash 中的新特性.

$BASH_VERSINFO[n]
记录 Bash 安装信息的一个 6 元素的数组.与下边的$BASH_VERSION 很像

$DIRSTACK
在目录栈中最上边的值

$EDITOR
脚本调用的默认编辑器,一般是 vi 或者是 emacs.

$EUID
&amp;quot;effective&amp;quot;用户 ID 号.

$FUNCNAME 当前函数的名字.

$GLOBIGNORE
一个文件名的模式匹配列表

$GROUPS
当前用户属于的组.

$HOME
用户的 home 目录

$HOSTNAME
hostname 命令将在一个 init 脚本中,在启动的时候分配一个系统名字. gethostname()函数将用来设置这个$HOSTNAME 内部变量

$HOSTTYPE
主机类型

$IFS 内部域分隔符.

$IGNOREEOF
忽略 EOF

$LC_COLLATE
常在.bashrc 或/etc/profile 中设置,这个变量用来在文件名扩展和模式匹配校对顺序. 如果$LC_COLLATE 被错误的设置,那么将会在 filename globbing 中引起错误的结果.

$LC_CTYPE
这个内部变量用来控制 globbing 和模式匹配的字符串解释.

$LINENO
这个变量记录它所在的 shell 脚本中它所在行的行号.这个变量一般用于调试目的.

$MACHTYPE
系统类型

$OLDPWD你所在的之前的目录

$OSTYPE 操作系统类型.

$PATH
指向 Bash 外部命令所在的位置

$PIPESTATUS
数组变量将保存最后一个运行的前台管道的退出码

$PPID
一个进程的$PPID 就是它的父进程的进程

$PROMPT_COMMAND 这个变量保存一个在主提示符($PS1)显示之前需要执行的命令

$PS1  2  3  4 提示符

$PWD 工作目录(你当前所在的目录). 与 pwd 内建命令作用相同.

$SHELLOPTS
这个变量里保存 shell 允许的选项,这个变量是只读

$SHLVL
Shell 层次

$TMOUT
如果$TMOUT 环境变量被设置为一个非零的时间值,那么在过了这个指定的时间之后, shell 提示符将会超时,这会引起一个 logout.

$UID
用户 ID 号.
当前用户的 id 号,在/etc/passwd 中记录.
这个值不会因为用户使用了 su 命令而改变.$UID 是只读变量,不容易在命令行或者是脚 本中被修改,并且和内建的 id 命令很相像.

$SECONDS 这个脚本已经运行的时间(单位为秒).

$RANDOM: 产生随机整数
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;${#string}
expr length $string 
expr &amp;quot;$string&amp;quot; : &#39;.*&#39;

1 stringZ=abcABC123ABCabc 
3 echo ${#stringZ}
4 echo `expr length $stringZ`                  -------表达式变量的值，一般用于整数值，也可用于字符串。·
5 echo `expr &amp;quot;$stringZ&amp;quot; : &#39;.*&#39;`

15
15
15

expr match &amp;quot;$string&amp;quot; &#39;$substring&#39; $substring 是一个正则表达式
expr &amp;quot;$string&amp;quot; : &#39;$substring&#39; $substring 是一个正则表达式     
两者相等


 stringZ=abcABC123ABCabc
 2 # |------|
 3
 4 echo `expr match &amp;quot;$stringZ&amp;quot; &#39;abc[A-Z]*.2&#39;`
 5 echo `expr &amp;quot;$stringZ&amp;quot; : &#39;abc[A-Z]*.2&#39;`

 8
 8

expr index $string $substring 匹配到子串的第一个字符的位置.

截取
${string:position}
在 string 中从位置$position 开始提取子串.
如果$string 为&amp;quot;*&amp;quot;或&amp;quot;@&amp;quot;,那么将提取从位置$position 开始的位置参数
${string:position:length}
在 string 中从位置$position 开始提取$length 长度的子串.


反向截取
echo ${stringZ:-4}     
# 以${parameter:-default}方式,默认是提取完整地字符串.
echo ${stringZ:(-4)}
echo ${stringZ: -4}
# 现在,它可以工作了.
# 使用圆括号或者添加一个空格来转义这个位置参数.


abcABC123ABCabc
Cabc
Cabc

expr substr $string $position $length
在 string 中从位置$position 开始提取$length 长度的子串.


子串削除
${string#substring}
从$string 的左边截掉第一个匹配的$substring
${string##substring}
从$string 的左边截掉最后一个个匹配的$substring
${string%substring}
从$string 的右边截掉第一个匹配的$substring
${string%%substring}
从$string 的右边截掉最后一个匹配的$substrin  expr substr $string $position $length
在 string 中从位置$position 开始提取$length 长度的子串.


子串替换
${string/substring/replacement}
使用$replacement 来替换第一个匹配的$substring.
${string//substring/replacement}
使用$replacement 来替换所有匹配的$substring.
${string/#substring/replacement}
如果$substring 匹配$string 的开头部分,那么就用$replacement 来替换$substring.
${string/%substring/replacement}
如果$substring 匹配$string 的结尾部分,那么就用$replacement 来替换$substring.

字符串扩展
${parameter}
与$parameter 相同,就是 parameter 的值.
${parameter-default},${parameter:-default} 如果 parameter 没被 set,那么就使用 default.
${parameter=default},${parameter:=default}
如果 parameter 未设置,那么就设置为 default.
${parameter+alt_value},${parameter:+alt_value}
如果 parameter 被 set 了,那就使用 alt_value,否则就使用 null 字符串.
${parameter?err_msg}, ${parameter:?err_msg}
如果 parameter 被 set,那就是用 set 的值,否则 print err_msg.

变量长度/子串删除 ${#var}
字符串长度($var 的字符数量).对于一个数组,${#array}是数组中第一个元素的长度.
一些例外:
${#*}和${#@}将给出位置参数的个数. 对于数组来说${#array[*]}和${$#array[@]}将给出数组元素的个数.
${var#Pattern}, ${var##Pattern}
从$var 开头删除最近或最远匹配$Pattern 的子串.
${var%Pattern}, ${var%%Pattern}
从$var 结尾删除最近或最远匹配$Pattern 的子串.



变量扩展/子串替换
这些结构都是从 ksh 中吸收来的.
${var:pos}
变量 var 从位置 pos 开始扩展.
${var:pos:len}
从位置 pos 开始,并扩展 len 长度个字符.见 Example A-14(这个例子里有这种操作的一个 创造性用法)
${var/Pattern/Replacement}
使用 Replacement 来替换 var 中的第一个 Pattern 的匹配.
${var//Pattern/Replacement}
全局替换.在 var 中所有的匹配,都会用 Replacement 来替换.
向上边所说,如果 Replacement 被忽略的话,那么所有匹配到的 Pattern 都会被删除.
${var/#Pattern/Replacement}
如果 var 的前缀匹配到了 Pattern,那么就用 Replacement 来替换 Pattern.
${var/%Pattern/Replacement}
如果 var 的后缀匹配到了 Pattern,那么就用 Replacement 来替换 Pattern.

间接引用
a=letter_of_alphabet
letter_of_alphabet=z
echo 
# 直接引用.
echo &amp;quot;a = $a&amp;quot;
# 间接引用.
eval a=\$$a
echo &amp;quot;Now a = $a&amp;quot;


a = letter_of_alphabet
Now a = z
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;内建命名&#34;&gt;内建命名&lt;/h2&gt;

&lt;p&gt;I/O&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo
打印(到 stdout)一个表达式或变量
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;系统增量备份和全量备份&#34;&gt;系统增量备份和全量备份&lt;/h2&gt;

&lt;p&gt;全量备份&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -g /tmp/snop -zcvf /tmp/sh.tar.gz /data/sh ------ -g /tmp/snop就是建立了一个快照，便于下面增量备份坐参考，重新全量备份，只要把这个快照删除就行了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增量备份&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -g /tmp/snop -zxcf /tmp/sh_add.tar.gz /data/sh --------这边的快照名要和上面全量的一样，但是tar包名不能一样。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以用corntab来每天跑这个脚本，在这个脚本历可以设置每周日进行全量备份，其他时间进行增量备份&lt;/p&gt;

&lt;h2 id=&#34;tmp-snop就是建立了一个快照-便于下面增量备份坐参考-重新全量备份-只要把这个快照删除就行了&#34;&gt;/tmp/snop就是建立了一个快照，便于下面增量备份坐参考，重新全量备份，只要把这个快照删除就行了&lt;/h2&gt;

&lt;p&gt;增量备份&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -g /tmp/snop -zxcf /tmp/sh_add.tar.gz /data/sh --------这边的快照名要和上面全量的一样，但是tar包名不能一样。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以用corntab来每天跑这个脚本，在这个脚本历可以设置每周日进行全量备份，其他时间进行增量备份&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>包管理工具--yum和rpm</title>
      <link>http://kingjcy.github.io/blog/2015/12/05/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7--yum%E5%92%8Crpm/</link>
      <pubDate>Sat, 05 Dec 2015 17:01:13 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2015/12/05/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7--yum%E5%92%8Crpm/</guid>
      <description>&lt;p&gt;软件包的管理使我们安装软件更加简单高效，经常在linux上使用的rpm和yum。这边做一个简单的备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;yum&#34;&gt;yum&lt;/h1&gt;

&lt;p&gt;yum是yellow dog uodater,modifies的简称，是一种基于rpm包管理工具的软件包管理工具，能够重制定的服务器下载rpm包并安装，并且解决依赖包的获取和安装，能够完成软件的安装，卸载，查找。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;yum [options] [command] [package ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[options]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-y 在安装过程中都选择yes
-q 不显示安装的过程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[command]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install  安装，不带制定的包名就会全部安装，切记！
localinstall   安装本地包，可以直接用于*.rpm来安装所有的本地包
remove   卸载
erase    卸载
update   升级，这个经常不带包名来升级所有的包
list     显示可用包 
list installed  显示已经安装的包
clean all  清除缓存
makecache  加载缓存,这边只是缓存，在安装过程中可以提高速度。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[package]就是我们需要安装的包名。&lt;/p&gt;

&lt;p&gt;只下载rpm包，不安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install --downloadonly --downloaddir=/tmp &amp;lt;package-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;yum配置文件&#34;&gt;yum配置文件&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;cat /etc/yum.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边有两个配置cachedir=XXX这个一般是存储安装包的地方，但是一般安装包是不保留的，要保留包需要修改配置keepcache=1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;yum源&#34;&gt;yum源&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;yum源就是yum下载软件包的指定的地方，yum源有的可以直接用yum安装，但是最主要的就是repo文件，一般所有的yum源文件都在/etc/yum.repo.d/下面，一般修改yum源后会使用yum makecache 来包源的安装包缓存下来加快安装速度。&lt;/p&gt;

&lt;p&gt;文件结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[serverid]    ----唯一的源标志
name=Some name for this server  ----对这个源的描述
baseurl=url://path/to/repository/    ------源的url， 目前http:// ftp:// file://三种
mirrorlist=     -----一般禁用，是镜像服务器地址列表
gpgcheck=1        ------是否进行gpg校验，一般在线需要校验，确保安全性，本地的就不需要校验了
enabled=0       --------启用或者禁用此源
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5   ----导入每个reposity的GPG key，用于gpg校验的，rpm --import 重网站下载下的一个关于key的txt文件。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;已经很形象了展示源的使用，下面介绍几种常用的方式&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地源&lt;/p&gt;

&lt;p&gt;就是指将rpm包下载下来或者自己把源码打包成rpm，放在本地的目录下，然后用createrepo命令把这些包加载为yum的仓库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;createrepo path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在在源文件中加上repo文件,比如vi /etc/yum.repos.d/inkscope_repo.repo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[local]
name=My inkScope Repo
baseurl=file:///home/cephdev/inkscope
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就会使用/home/cephdev/inkscope的安装包，这个就是用baseurl的file://格式&lt;/p&gt;

&lt;p&gt;下载rpm包的时候一般可以用wget或者curl，当然也可以直接重网页上下载。也可以用yum   &amp;ndash;downloadonly &amp;ndash;downloaddir=DLDIR来下载&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;补充&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;wget 是一个重网上下载文件的工具，支持HTTP，HTTPS和FTP协议。&lt;/p&gt;

&lt;p&gt;wget [option] url&lt;/p&gt;

&lt;p&gt;它支持很多参数，常用的是-c也就是continue的意思，下载未完成的文件，-b转入后台运作，-t设置连接次数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;curl是一个支持上传和下载的文件传输工具，正常使用它curl url来在stdout上打印出网站的html来测试这个url是否通，实际上就是下载来这个网站的html文件。&lt;/p&gt;

&lt;p&gt;curl [option] url&lt;/p&gt;

&lt;p&gt;它也是支持很多参数的，常用的有-c（continue），下载到指定文件 -o XX等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这边讲到了打包成rpm包，也顺便讲一下怎么打包。这边就需要用到rpmbuild命令。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rpm和dpkg分别是Linux操作系统的两大底层的包管理工具，其他的yum，apt-*等这些底层依旧是用的这两个工具，但是他们顺带解决了包之间的依赖关系，所有比较好用，但是很多东西需要自己来解决依赖关系就需要了解这两个底层的工具，同时如果一个项目开源就应该提供对应的rpm包，才算完整，（这边啰嗦一下，一般开源的项目安装，一个是编译源码安装，二个就是rpm包安装，甚至更好的提供yum源更加便于安装，我们可以使用所有的rpm包安装自己的本地源，三就是官方提供编译好的可执行文件直接下载使用，加入系统服务什么的都是可以操作的），所以应该学会rpm打包。&lt;/p&gt;

&lt;p&gt;rpmbuild工具在4.4版本之前默认的路径是/usr/src/redhat，只能root用户使用，而在之后的版本中放到了$HOME/rpmbuild,开始提倡用非root用户了,这个目录是在/usr/lib/rpm/macros这个文件里的一个叫做%_topdir的宏变量来定义，可以在用户家目录下建立一个名为.rpmmacros的隐藏文件重新定义%_topdir.&lt;/p&gt;

&lt;p&gt;在%_topdir目录下一般需要建立6个目录，可以直接通过rpmbuild spec文件名进行创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;目录名 说明  macros中的宏名
BUILD   编译rpm包的临时目录 %_builddir
BUILDROOT   编译后生成的软件临时安装目录  %_buildrootdir
RPMS    最终生成的可安装rpm包的所在目录   %_rpmdir
SOURCES 所有源代码和补丁文件的存放目录 %_sourcedir
SPECS   存放SPEC文件的目录(重要) %_specdir
SRPMS   软件最终的rpm源码格式存放路径(暂时忽略掉，别挂在心上)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以将源码打成tar包放到对应的SOURCES目录,然后将打包规则文件放到对应的SPEC目录下面，使用rpmbuild命令在SPEC下来进行打包&lt;/p&gt;

&lt;p&gt;可以安装rpmdev工具（yum install -y rpmdev*）来创建spec文件的模板rpmdev-newspec -o Name-version.spec&lt;/p&gt;

&lt;p&gt;spec文件是rpm打包的关键，SPEC文件的核心是它定义了一些“阶段”(%prep、%build、%install和%clean)，当rpmbuild执行时它首先会去解析SPEC文件，然后依次执行每个“阶段”里的指令。&lt;/p&gt;

&lt;p&gt;spec头的关键字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name:用来定义软件包的名称，后面可以使用%{name}的方式引用，不能包含空格，且必须唯一
Summary: 软件包的内容概要，只能用一句话来概括
Version: 软件的实际版本号，具体命令需跟源包一致，后面可以使用%{
version}使用，不允许出现连字符&#39;-&#39;，会被认为非法字符
Release: 发布序列号，具体命令需跟源包一致，后面可以使用%{release}使用，一般是一个整数，也是rpm包版本信息的一部分
License: 软件授权方式，通常就是GPL
Source0: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%{source1}、%{source2}引用
buildroot在rpmbuild在制作rpm包的时候，会把编译生成的二进制文件和库文件先安装到一个临时目录，然后再结合spec文件从这个临时目录中提取文件 ，压缩生成rpm文件，这个临时目录就是buildroot所标示的目录BuildRoot: 这个是安装或编译时使用的“虚拟目录”，考虑到多用户的环境，一般定义为：%{_tmppath}/%{name}-%{version}-%{release}-root该参数非常重要，因为在生成rpm的过程中，执行make install时就会把软件安装到上述的路径中，在打包的时候，同样依赖“虚拟目录”为“根目录”进行操作。后面可使用$RPM_BUILD_ROOT 方式引用。也可见name，version，release三个必填参数比较重要。
URL: 软件的主页
Vendor: 发行商或打包组织的信息，例如RedFlag Co,Ltd
Disstribution: 发行版标识
Group: 软件分组，建议使用标准分组
-----------------------------------------
软件包所属类别，具体类别有：
Amusements/Games （娱乐/游戏）
Amusements/Graphics（娱乐/图形）
Applications/Archiving （应用/文档）
Applications/Communications（应用/通讯）
Applications/Databases （应用/数据库）
Applications/Editors （应用/编辑器）
Applications/Emulators （应用/仿真器）
Applications/Engineering （应用/工程）
Applications/File （应用/文件）
Applications/Internet （应用/因特网）
Applications/Multimedia（应用/多媒体）
Applications/Productivity （应用/产品）
Applications/Publishing（应用/印刷）
Applications/System（应用/系统）
Applications/Text （应用/文本）
Development/Debuggers （开发/调试器）
Development/Languages （开发/语言）
Development/Libraries （开发/函数库）
Development/System （开发/系统）
Development/Tools （开发/工具）
Documentation （文档）
System Environment/Base（系统环境/基础）
System Environment/Daemons （系统环境/守护）
System Environment/Kernel （系统环境/内核）
System Environment/Libraries （系统环境/函数库）
System Environment/Shells （系统环境/接口）
User Interface/Desktops（用户界面/桌面）
User Interface/X （用户界面/X窗口）
User Interface/X Hardware Support （用户界面/X硬件支持）
----------------------------------------------------
Patch: 补丁源码，可使用Patch1、Patch2等标识多个补丁，使用%patch0或%{patch0}引用
prefix主要用于定义可重新定义安装位置的包，也就是在安装时可以通过--prefix来定义包的安装路径
Prefix: %{_prefix} 这个主要是为了解决今后安装rpm包时，并不一定把软件安装到rpm中打包的目录的情况。这样，必须在这里定义该标识，并在编写%install脚本的时候引用，才能实现rpm安装时重新指定位置的功能
Prefix: %{sysconfdir} 这个原因和上面的一样，但由于%{_prefix}指/usr，而对于其他的文件，例如/etc下的配置文件，则需要用%{_sysconfdir}标识
BuildRequires:  在本机编译rpm包时需要的辅助工具，以逗号分隔。假如，要求编译myapp时，gcc的版本至少为4.4.2，则可以写成gcc &amp;gt;=4.2.2。还有其他依赖的话则以逗号分别继续写道后面。
Requires: 该rpm包所依赖的软件包名称，可以用&amp;gt;=或&amp;lt;=表示大于或小于某一特定版本，“&amp;gt;=”号两边需用空格隔开，而不同软件名称也用空格分开
Conflicts: 该包与哪些软件包冲突
Provides: 该包提供了什么，通常是包名或者虚拟包名
Packager: 打包者的信息，可以是名字或者邮件地址
%dscription 软件的详细说明，描述信息可以有多行，如果提供的描述信息是以空格开始的，则该信息单独显示在一行，如果信息前没有空格，则认为描述信息是一个段落
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;spec的主体&lt;/p&gt;

&lt;p&gt;关键的阶段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;阶段    动作
%prep    将%_sourcedir目录下的源代码解压到%_builddir目录下。如果有补丁的需要在这个阶段进行打补丁的操作
%build    在%_builddir目录下执行源码包的编译。一般是执行./configure和make指令
%install    将需要打包到rpm软件包里的文件从%_builddir下拷贝%_buildrootdir目录下。当用户最终用rpm -ivh name-version.rpm安装软件包时，这些文件会安装到用户系统中相应的目录里
制作rpm包    这个阶段是自动完成的，所以在SPEC文件里面是看不到的，这个阶段会将%_buildroot目录的相关文件制作成rpm软件包最终放到%_rpmdir目录里
%clean    编译后的清理工作，这里可以执行make clean以及清空%_buildroot目录等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体讲解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%prep 预处理脚本，
%setup -n %{name}-%{version} 把源码包解压并放好，可根据你的源码的名字格式，来确认解压后名字的格式，否则可能导致install的时候找不到对应的目录，正常使用%setup -q就可以解压在SOURCES目录下的tar包了。
◎补充一下
%setup 不加任何选项，仅将软件包打开。
%setup -n newdir 将软件包解压在newdir目录。
%setup -c 解压缩之前先产生目录。
%setup -b num 将第num个source文件解压缩。
%setup -T 不使用default的解压缩操作。
%setup -T -b 0 将第0个源代码文件解压缩。
%setup -q 指不显示输出（quietly）
%setup -c -n newdir 指定目录名称newdir，并在此目录产生rpm套件。
%patch 最简单的补丁方式，自动指定patch level。
%patch 0 使用第0个补丁文件，相当于%patch ?p 0。
%patch -s 不显示打补丁时的信息。
%patch -T 将所有打补丁时产生的输出文件删除。

%build 开始构建包
在BUILD目录下的对应的解压文件中进行编译，常见写法：
    %configure
    make %{?_smp_mflags} OPTIMIZE=&amp;quot;%{optflags}
    都是一些优化参数，定义在/usr/lib/rpm/marcros中

%install 开始把软件安装到虚拟的根目录中
这个阶段就是执行make install操作。这个阶段会在%_buildrootdir目录里建好目录结构，然后将需要打包到rpm软件包里的文件从%_builddir里拷贝到%_buildrootdir里对应的目录里
rm -rf $RPM_BUILD_ROOT
make DESTDIR=$RPM_BUILD_ROOT install
其中$RPM_BUILD_ROOT也可以换成我们前面定义的BuildRoot变量，不过要写成%{buildroot}才可以，必须全部用小写，不然要报错。


%clean 清理临时文件
[ &amp;quot;$RPM_BUILD_ROOT&amp;quot; != &amp;quot;/&amp;quot; ] &amp;amp;&amp;amp; rm -rf &amp;quot;$RPM_BUILD_ROOT&amp;quot;,一般清空RPM_BUILD_ROOT目录下的文件

%pre rpm安装前执行的脚本
%post rpm安装后执行的脚本
%preun rpm卸载前执行的脚本
%postun rpm卸载后执行的脚本

%files 定义那些文件或目录会放入rpm中
%deffattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755
%exclude 列出不想打包到rpm中的文件,如果%exclude指定的文件不存在，也会出错的

%changelog 变更日志 %files 定义那些文件或目录会放入rpm中
* date +&amp;quot;%a %b %d %Y&amp;quot; 修改人 邮箱 本次版本x.y.z-p
- 本次变更修改了那些内容&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;spec中常用的宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RPM_BUILD_DIR:    $HOME/rpmbuild/BUILD
RPM_BUILD_ROOT:   HOME/rpmbuild/BUILDROOT
%{_sysconfdir}:   /etc
%{_sbindir}：     /usr/sbin
%{_bindir}:       /usr/bin
%{_datadir}:      /usr/share
%{_mandir}:       /usr/share/man
%{_libdir}:       /usr/lib64
%{_prefix}:       /usr
%{_localstatedir}:   /usr/var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后使用rpmbuild命令进行rpm打包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpmbuild {-ba|-bb|-bp|-bc|-bi|-bl|-bs} [rpmbuild-options] SPECFILE ...   这个是针对spec文件的打包

rpmbuild {-ta|-tb|-tp|-tc|-ti|-tl|-ts} [rpmbuild-options] TARBALL ...               tar包

rpmbuild {--rebuild|--recompile} SOURCEPKG ...                                      源码

对上面的参数做一个诠释

第一个参数：b spec文件 t tar包

第二个参数：p 准备 a 编译打包成*.rpm和src.rpm  b编译只打包为*.rpm c 准备和编译 i 编译安装 l 检查文件是否安全 s编译只打包为src.rpm 

对于 --rpmbuild 编译成rpm包，--recompile 编译

一般正对spec文件都是使用rpmbuild -ba spec文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpmbuild -bb libmad-0.15.1b.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些安装包提供了打包的spec，比如apache下载httpd-2.4.20.tar.bz2这个包，就可以直接用rpm进行打包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpmbuild -tb httpd-2.4.20.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这边对apache打rpm包做一个实例操作&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接执行rpmbuild -tb httpd-2.4.20.tar.bz2会发现缺少很多的rpm包，大部分直接可以用yum install来安装，有两个包有点问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fedora18的源已经没有了，但是我们可以从fedoraproject的archive源中找到它&lt;a href=&#34;https://archive.fedoraproject.org/pub/archive/fedora/linux/releases/18/Everything/source/SRPMS/d/&#34;&gt;https://archive.fedoraproject.org/pub/archive/fedora/linux/releases/18/Everything/source/SRPMS/d/&lt;/a&gt;  是一个src.rpm包，则编译&lt;/p&gt;

&lt;p&gt;$ rpmbuild &amp;ndash;rebuild &amp;ndash;clean distcache-1.4.5-23.src.rpm&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后就可以在$HOME/rpmbuild/RPMS中找到对应的安装包，可以用yum localinstall *.rpm安装&lt;/p&gt;

&lt;p&gt;2.apr全称是Apache Portable Runtime，是httpd跨平台运行的基础。CentOS7源中提供的是1.4.x的版本，虽然httpd 2.4.20要求的apr版本是大于1.4.0即可，但是我发现在使用小于1.5.0版本的apr时，包含1.5.0都不行，所以需要手动下载包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpmbuild -tb apr-1.5.2.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以打包了。&lt;/p&gt;

&lt;p&gt;针对上面的src.rpm包的处理方式&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;就是使用rpmbuild &amp;ndash;rebuild &amp;ndash;clean distcache-1.4.5-23.src.rpm来直接打包&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rpm –ivh setarch-1.3-1.src.rpm   执行rpm安装命令然后就可以到对应的目录下编辑spec文件，然后就可以按着上面的进行编译安装&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地源也可以做成http和ftp的模式，也就是我们说的内部源，可以提供局域网使用&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般我们不使用ftp模式，因为防火墙等原因会造成很多的坑，所以一般采用http的模式，http一般是使用apache服务来实现。&lt;/p&gt;

&lt;p&gt;因为使用的是apache的服务，所以需要在http.conf里面配置的路径下面新建文件夹，将我们获取的rpm包放进去。&lt;/p&gt;

&lt;p&gt;然后对当前路径使用createrepo命令来进行仓库管理，就可以使用&lt;a href=&#34;http://ip/路径来访问获取这个目录下面的包了，将这个url配置到repo文件中的baseurl就完成了http模式的部署，内网都可以使用这个源来安装上面有的软件了。&#34;&gt;http://ip/路径来访问获取这个目录下面的包了，将这个url配置到repo文件中的baseurl就完成了http模式的部署，内网都可以使用这个源来安装上面有的软件了。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这边有一个路径下禁止访问的问题，需要关闭防火墙firewalld（centos7,更加强大，拥有图形化界面）,iptables（centos6）,setenforce(这个也是关闭防火墙,是selinux的，不同概念，需要开机就关闭就修改配置文件/etc/selinux/config),问题就解决了。其实大部分访问不了，而内部可以curl的就考虑防火墙。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;网络源，就是把第三方提供的源url配置好就可以在线安装了，例如epel源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常用源：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;epel源&lt;/p&gt;

&lt;p&gt;wget &lt;a href=&#34;http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm&#34;&gt;http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm&lt;/a&gt;
rpm -ivh epel-release-6-8.noarch.rpm&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;rpm&#34;&gt;rpm&lt;/h1&gt;

&lt;p&gt;rpm（rpm package manager）是red hat linux发行专门用来管理rpm包的管理工具。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm [option][rpmpackage]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[option]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-a：查询所有套件； 
-b&amp;lt;完成阶段&amp;gt;&amp;lt;套件档&amp;gt;+或-t &amp;lt;完成阶段&amp;gt;&amp;lt;套件档&amp;gt;+：设置包装套件的完成阶段，并指定套件档的文件名称； 
-c：只列出组态配置文件，本参数需配合&amp;quot;-l&amp;quot;参数使用； 
-d：只列出文本文件，本参数需配合&amp;quot;-l&amp;quot;参数使用； 
-e&amp;lt;套件档&amp;gt;或--erase&amp;lt;套件档&amp;gt;：删除指定的套件； 
-f&amp;lt;文件&amp;gt;+：查询拥有指定文件的套件； 
-h或--hash：套件安装时列出标记； 
-i：显示套件的相关信息； 
-i&amp;lt;套件档&amp;gt;或--install&amp;lt;套件档&amp;gt;：安装指定的套件档； 
-l：显示套件的文件列表； -p&amp;lt;套件档&amp;gt;+：查询指定的RPM套件档； 
-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户； 
-R：显示套件的关联性信息； 
-s：显示文件状态，本参数需配合&amp;quot;-l&amp;quot;参数使用； 
-U&amp;lt;套件档&amp;gt;或--upgrade&amp;lt;套件档&amp;gt;：升级指定的套件档； 
-v：显示指令执行过程； 
-vv：详细显示指令执行过程，便于排错。
--nodeps 忽略依赖关系
--force 强制安装
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的一些选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rpm -qa后面不接参数用于查看系统中已经安装的所有的rpm包&lt;/li&gt;
&lt;li&gt;rpm -q rpm包名用于查看系统中是否安装了该软件包，如果安装了，系统会显示完整的包名；如果没有安装，系统会提示&amp;rdquo;package bas is not installed&amp;rdquo;。&lt;/li&gt;
&lt;li&gt;rpm -qi rpm包名用于查看系统中已经安装的rpm包的完整信息，包括该包的版本信息，安装时间和大小等。&lt;/li&gt;
&lt;li&gt;rpm -ql rpm包名用于查看该软件包都安装到了那些位置。&lt;/li&gt;
&lt;li&gt;rpm -qf 文件名用于查看某个文件使用那个rpm包安装的。&lt;/li&gt;
&lt;li&gt;rpm -ivh 包名用于安装rpm软件包，i代表安装、v代表可视化安装、h代表安装的时候显示进度。&lt;/li&gt;
&lt;li&gt;rpm &amp;ndash;force -irpm包用于强制安装rpm软件包，&amp;ndash;force参数用于安装存在依存关系的rpm包。不过一般我们并不怎做，解决依存关系的较好的方法是使用#rpm -i 命令一起安装。&lt;/li&gt;
&lt;li&gt;rpm -e rpm包名用于删除rpm软件包。rpm -e &amp;ndash;nodeps 包名用于删除存在依存关系的软件包，该命令可以将和该包存在依存关系的所有的软件包统统删除。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rpm的大体使用也就这样，至于rpm打包已经在上面说过了，rpm需要下载后才能使用这个工具，但是在本地的安装包操作上还是比较强大的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>工具系列(二):gdb的使用总结</title>
      <link>http://kingjcy.github.io/blog/2015/03/14/%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E4%BA%8Cgdb%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 14 Mar 2015 15:48:41 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2015/03/14/%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E4%BA%8Cgdb%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;gdb在debug过程中起着巨大的作用，用好gdb调试工具可以很快的定位问题，解决问题，这边记录一点gdb的使用注意点，便于查看和备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;gdb调试能使用前提-编译时要加-g&#34;&gt;gdb调试能使用前提：编译时要加-g&lt;/h2&gt;

&lt;p&gt;list(l):显示文件内容，可以加行号，函数名，也可以是其他文件的函数file：fun/行号&lt;/p&gt;

&lt;p&gt;break(b):设置断点，运行到这边停止，可以是行号，或者函数名，也可以是其他文件的函数file：fun/行号，也可以跟随条件表达式，b if i = 5&lt;/p&gt;

&lt;p&gt;delete（d）：删除断点；加断点号&lt;/p&gt;

&lt;p&gt;info（i）：显示，比如显示断点 i b&lt;/p&gt;

&lt;p&gt;run（r）：运行程序，到断点处，&lt;/p&gt;

&lt;p&gt;continue（c）：继续运行到下一个断点&lt;/p&gt;

&lt;p&gt;step（s）：单步调试，进入函数内部&lt;/p&gt;

&lt;p&gt;next（n）：单步调试，不进入函数内部&lt;/p&gt;

&lt;p&gt;print（p）：打印；可以是变量==，也可以是静态数组或者动态数组，p 数组名，p *数组名＠长度　也可以动态改变变量值　ｐi = 100&lt;/p&gt;

&lt;p&gt;ptype ：显示类型&lt;/p&gt;

&lt;p&gt;watch 变量：观察变量的变化&lt;/p&gt;

&lt;p&gt;until：报循环运行结束&lt;/p&gt;

&lt;p&gt;finilsh：把函数运行完&lt;/p&gt;

&lt;p&gt;调试逻辑错误&lt;/p&gt;

&lt;p&gt;调试段错误
越界
往空地址里面写东西&lt;/p&gt;

&lt;h2 id=&#34;调试core&#34;&gt;调试core&lt;/h2&gt;

&lt;p&gt;首先可以查看是否产生core文件：ulimit -c 可以加指定大小的core文件，也可以是unlimited&lt;/p&gt;

&lt;p&gt;gdb 可执行文件名 core文件&lt;/p&gt;

&lt;p&gt;where知道具体位置，打印出相关信息。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>工具系列(一)：git和github的使用总结</title>
      <link>http://kingjcy.github.io/blog/2014/11/02/%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E4%B8%80git%E5%92%8Cgithub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 02 Nov 2014 16:50:34 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2014/11/02/%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E4%B8%80git%E5%92%8Cgithub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;一直想整理一下平时使用的工具，都没有时间，但是还是要带着整理的，备忘也便于查看。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;git&#34;&gt;&lt;em&gt;git&lt;/em&gt;&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;p&gt;git是一个分布式版本控制系统，它没有中央服务器，本地便是一个版本库。不需要联网就能开发，它是通过推送自己修改的内容给对方来实现版本控制的。&lt;/p&gt;

&lt;p&gt;svn则与之相反，svn是一种集中式的版本控制系统，它拥有中央服务器，需要先从中央服务器中下载最新的版本，然后进行修改，最后在将修改的推送到中央服务器上，所以必须能连接上服务器，不然不利于开发。&lt;/p&gt;

&lt;p&gt;相对而言，git适用于随时随地的本地开发。&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;linux下安装（centos）&lt;/p&gt;

&lt;p&gt;1.yum基础软件包管理工具&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum install git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;目前的yum源安装最高版本应该是1.7.1&lt;/p&gt;

&lt;p&gt;2.编译安装&lt;/p&gt;

&lt;p&gt;首先到github[&lt;a href=&#34;https://github.com/git/git/releases&#34;&gt;https://github.com/git/git/releases&lt;/a&gt;] 上下载最新的release版本。安装之前需要先安装git的依赖包：：curl、zlib、openssl、expat，还有libiconv。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -zxf git-2.0.0.tar.gz
$ cd git-2.0.0
$ make configure
$ ./configure --prefix=/usr
$ make all doc info
$ sudo make install install-doc install-html install-info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以检查版本安装是否成功了&lt;code&gt;git --version&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;操作使用&#34;&gt;操作使用&lt;/h3&gt;

&lt;p&gt;git是一个本地管理的软件，首先要掌握本地的使用命令：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;git init  在当前目录建立仓库，也就是初始化本地目录环境，可以看见有一个隐藏文件.git 要输出这个仓库，直接删除这个目录（暴力方法）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新建文件 touch t&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;加版本  git add t&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交版本  git commit t -m &amp;ldquo;版本说明日志&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     git commit -a -m &amp;quot;&amp;quot;  提交所有文件
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;版本比较 git diff t&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示版本日志  git log&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;恢复上一个版本 git reset &amp;ndash;hard 版本号，可以在git log中显示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看状态  git status&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分支&lt;/p&gt;

&lt;p&gt;创建分支:执行git branch &lt;branchname&gt;命令创建新分支&lt;/p&gt;

&lt;p&gt;切换分支:执行git checkout &lt;branchname&gt;命令切换到新分支&amp;mdash;合一步  git checkout -b XXXX、&lt;/p&gt;

&lt;p&gt;git branch -a   查看远程分支&lt;/p&gt;

&lt;p&gt;git branch 查看本地分支&lt;/p&gt;

&lt;p&gt;删除本地分支   git branch -d xxxxx&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;包括增删减改后的文件都可以用如上的操作，我这边主要对新增文件的操作，最重要是之后的提交。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;github&#34;&gt;&lt;em&gt;github&lt;/em&gt;&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;p&gt;github是一个git版本的远程服务器仓库，很多开源的项目都会将代码保存在这个托管平台上，是一个类似于dockerhub的存储功能的公共仓库。&lt;/p&gt;

&lt;p&gt;这边主要记录一些github和本地的git仓库的交互：&lt;/p&gt;

&lt;p&gt;首先创建ssh key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;574209987@qq.com&amp;quot;----生成家目录下的.ssh/XXX 秘钥文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后到github的settings中设置ssh key把公共密码贴进去&amp;rdquo;&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global 注册用户信息
git config --global user.name &amp;quot;jcy&amp;quot;
git config --global user.email &amp;quot;574209987@qq.com&amp;quot;
git config --global core.editor vim-----commit后用vim编辑
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;远程到本地&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/kingjcy/t2.git---远程克隆到本地
git fetch https://github.com/kingjcy/t2.git---远程覆盖本地
git pull https://github.com/kingjcy/t2.git----远程和本地合并，用于开发前同步版本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地到远程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote -v 来查看当前项目中都添加了哪些远程仓库-----其中Origin一般是自己在服务器上的远程仓库，其他的为他人的远程仓库。
git remote add 别名 https://github.com/kingjcy/Test.git-----添加远程库
git push  别名 master（分支名）----推送到远程
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;问题记录&#34;&gt;问题记录&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题1：error: The requested URL returned error: 403 Forbidden while accessing &lt;a href=&#34;https://github.com/kingjcy/kingjcy.github.io.git/info/refs&#34;&gt;https://github.com/kingjcy/kingjcy.github.io.git/info/refs&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改vim .git/config
url = https://@github.com/kingjcy/kingjcy.github.io.git改为url = https://kingjcy@github.com/kingjcy/kingjcy.github.io.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题2：(gnome-ssh-askpass:23502): Gtk-WARNING **: cannot open display:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;执行unset SSH_ASKPASS，不用输用户名，直接输入密码。
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>用hugo&#43;github构建自己的blog</title>
      <link>http://kingjcy.github.io/blog/2014/08/02/%E7%94%A8hugo&#43;github%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84blog/</link>
      <pubDate>Sat, 02 Aug 2014 17:26:28 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2014/08/02/%E7%94%A8hugo&#43;github%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84blog/</guid>
      <description>&lt;p&gt;这个是我用hugo+github搭建起个人blog写的第一篇文章，有点小兴奋。。。首先把搭建测过程写起来和大家分享一下吧。&lt;/p&gt;

&lt;p&gt;首先，作为一个程序员，不拥有自己搭建的blog，而去用别人搭建好的去注册一下，我是无法接受的！！搭建个人blog需要两个东西：&lt;/p&gt;

&lt;p&gt;1、静态网页生成器，有jekyll，hexo，hugo等，由于最近在玩go语言，所以就选择了hugo，其他的也没有深入了解，后面搭建起来，发现hugo还是比较简单。&lt;/p&gt;

&lt;p&gt;2、github pages 这个是github提供的一个托管工作，相当好用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;hugo&#34;&gt;hugo&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个比较方便的静态页面生成器，首先需要安装，我的系统是centos 64位的.&lt;/p&gt;

&lt;h3 id=&#34;install&#34;&gt;install&lt;/h3&gt;

&lt;p&gt;2、直接下载二进制文件，这也是我说的方便的地方。&lt;/p&gt;

&lt;p&gt;Hugo二进制下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载下来后，首先要生成自己的站点：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new site mysite&lt;/code&gt;&amp;ndash;这边hugo的二进制文件不一定是这个名字，可以起个别名alias来用&lt;/p&gt;

&lt;p&gt;这时会在mysite目录下生成一些目录和文件，这边简单的介绍一下，config.toml是网站的配置文件，这是它的作者GitHub联合创始人Tom Preston-Werner 觉得YAML不够优雅，捣鼓出来的一个新格式。如果你不喜欢这种格式，你可以将config.toml替换为YAML格式的config.yaml，或者json格式的config.json。hugo都支持。content目录里放的是你写的markdown文章，layouts目录里放的是网站的模板文件，static目录里放的是一些图片、css、js等资源。&lt;/p&gt;

&lt;p&gt;然后进入站点目录mysite，新建文档&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cd mysite&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new about.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这边新建一个md文件会出现在content目录下，一般这个about.md文件是一个关于本站的介绍或者blog个人介绍，在这边将一下md文件的编辑，其实就是MarkDown格式文件的编写，具体的格式可以参考本文的编辑，或者去网上去搜索一下就ok,这边我说几点，我经常记错&lt;/p&gt;

&lt;p&gt;1、就是&amp;rdquo;+++&amp;ldquo;内的赋值用&amp;rdquo;=&amp;ldquo;，&amp;rdquo;&amp;mdash;&amp;ldquo;内的用&amp;rdquo;:&amp;ldquo;。&lt;/p&gt;

&lt;p&gt;2、&lt;code&gt;###&lt;/code&gt;后面必须有空格。&lt;/p&gt;

&lt;p&gt;3、有空行才能换行。&lt;/p&gt;

&lt;p&gt;一般我们写博文，会放在content/post下，正如我这边编写的第一篇文&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new post/first.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后用vim编辑器进行编辑，编辑好后，就可以将你编辑的文字生成静态网页了，当然你肯定需要一个模板，这样可以使你的网页根据美观，这边在讲一下模板的使用&lt;/p&gt;

&lt;p&gt;1、模板放在站点的themes下，一般木有这个文件夹，我们需要新增一个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkdir themes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cd themes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2、模板可以到hugo官网上去找,那边可以showcase预览一下自己喜欢的，具体的安装方式也有介绍，就是用&lt;code&gt;git clone&lt;/code&gt;把源码下到themes目录下就好&lt;/p&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、编辑模板的配置文件，这个视具体模板，可以参考我的配置&lt;a href=&#34;https://github.com/kingjcy/&#34;&gt;https://github.com/kingjcy/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面就是生成我们需要的静态网页了，也就是前端的html文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo --theme=hyde --baseUrl=&amp;quot;http://kingjcy.github.io/&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不出意外的话，应该在站点目录下生成一个public文件夹，这个就是我们需要的所有文件了，至此第一步已经完成了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;github-pages&#34;&gt;github pages&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个就简单了，因为本身就是github提供现成的东西，首先新增一个repo，命名为：&lt;code&gt;kingjcy.github.io&lt;/code&gt; （kingjcy替换为你的github用户名）。&lt;/p&gt;

&lt;p&gt;然后将第一步的public加入git版本，上传到这个项目，就可以访问你的个人blog：&lt;code&gt;http://kingjcy.github.io/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;至于git版本控制和github直接的传输，这边就不多讲了，如果需要可以参考我的另外一篇博文《git和github的使用》。&lt;/p&gt;

&lt;p&gt;终于搭建完了，欢迎指正,tks。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>