<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/language/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/language/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>typescript</title>
      <link>http://kingjcy.github.io/blog/2017/06/05/typescript/</link>
      <pubDate>Mon, 05 Jun 2017 15:11:46 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/05/typescript/</guid>
      <description>&lt;p&gt;ts是js的一个超集。将ts编译成js，让js更加容易书写和表达。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g typescript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tsc helloworld.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本语法&lt;/p&gt;

&lt;p&gt;基础类型&lt;/p&gt;

&lt;p&gt;布尔&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isDone: boolean = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数字:和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，Typescript还支持ECMAScript 2015中引入的二进制和八进制字面量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串:可以使用双引号（ &amp;ldquo;）或单引号（&amp;rsquo;）表示字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let name: string = &amp;quot;bob&amp;quot;;

你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式

let name: string = `Gene`;
let sentence: string = `Hello, my name is ${ name }.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. let list: number[] = [1, 2, 3];
2. let list: Array&amp;lt;number&amp;gt; = [1, 2, 3];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元组 Tuple&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Declare a tuple type
let x: [string, number];
// Initialize it
x = [&#39;hello&#39;, 10]; // OK
// Initialize it incorrectly
x = [10, &#39;hello&#39;]; // Error


当访问一个越界的元素，会使用联合类型替代：

x[3] = &#39;world&#39;; // OK, 字符串可以赋值给(string | number)类型

console.log(x[5].toString()); // OK, &#39;string&#39; 和 &#39;number&#39; 都有 toString

x[6] = true; // Error, 布尔不是(string | number)类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;枚举&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Color {Red, Green, Blue};
let c: Color = Color.Green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值&lt;/p&gt;

&lt;p&gt;任意值：可以表示任何类型的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let notSure: any 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空值&lt;/p&gt;

&lt;p&gt;声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null&lt;/p&gt;

&lt;p&gt;变量声明&lt;/p&gt;

&lt;p&gt;let和const是JavaScript里相对较新的变量声明方式。&lt;/p&gt;

&lt;p&gt;var是js中使用的变量声明的关键字，在作用域上会出现问题，所以在ts中使用let声明，const声明的变量不能改变。&lt;/p&gt;

&lt;p&gt;interface&lt;/p&gt;

&lt;p&gt;可选属性：&lt;/p&gt;

&lt;p&gt;带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。&lt;/p&gt;

&lt;p&gt;只读属性：&lt;/p&gt;

&lt;p&gt;一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:&lt;/p&gt;

&lt;p&gt;class&lt;/p&gt;

&lt;p&gt;继承&lt;/p&gt;

&lt;p&gt;我们使用 extends关键字来创建子类，有公共，私有与受保护的修饰符&lt;/p&gt;

&lt;p&gt;函数&lt;/p&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x+y; };

let myAdd: (x:number, y:number)=&amp;gt;number =
    function(x: number, y: number): number { return x+y; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块&lt;/p&gt;

&lt;p&gt;“内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”&lt;/p&gt;

&lt;p&gt;模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export形式之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 import形式之一。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module X {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;export导出，同模块内，其实就是声明，因为定义在内部的，对于当前是不可见的。&lt;/p&gt;

&lt;p&gt;import 不同模块的需要导入。&lt;/p&gt;

&lt;p&gt;每个模块都有dafaul是默认导出的，设置标记后不需要专门导出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export default XXX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若要导入一个使用了export =的模块时，必须使用TypeScript提供的特定语法import let = require(&amp;ldquo;module&amp;rdquo;)。&lt;/p&gt;

&lt;p&gt;要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。&lt;/p&gt;

&lt;p&gt;我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在 .d.ts文件里定义的。 如果你熟悉C/C++，你可以把它们当做 .h文件。&lt;/p&gt;

&lt;p&gt;在Node.js里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的 export声明来为每个模块都定义一个.d.ts文件，但最好还是写在一个大的.d.ts文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用 module关键字并且把名字用引号括起来，方便之后import。 例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node.d.ts 
declare module &amp;quot;url&amp;quot; {
    export interface Url {
        protocol?: string;
        hostname?: string;
        pathname?: string;
    }

    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以/// &lt;reference&gt; node.d.ts并且使用import url = require(&amp;ldquo;url&amp;rdquo;);加载模块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// &amp;lt;reference path=&amp;quot;node.d.ts&amp;quot;/&amp;gt;
import * as URL from &amp;quot;url&amp;quot;;
let myUrl = URL.parse(&amp;quot;http://www.typescriptlang.org&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// &amp;lt;reference path=&amp;quot;../../includes.ts&amp;quot;/&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用标签指定它的命名空间，可以是一个命名空间分割成多个文件,也可以是多个命名空间，相当于引用模块&lt;/p&gt;

&lt;p&gt;装饰器
装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go积累</title>
      <link>http://kingjcy.github.io/blog/2017/05/23/go%E7%A7%AF%E7%B4%AF/</link>
      <pubDate>Tue, 23 May 2017 14:54:09 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/05/23/go%E7%A7%AF%E7%B4%AF/</guid>
      <description>&lt;p&gt;学习使用go语言已经有一段时间了，积累了很多的经验，这边进行整理并持续积累，也便于后期的备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;每个 Go 程序都是由包组成的。&lt;/p&gt;

&lt;p&gt;程序运行的入口是包 &lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;go自己的设计哲学：
1、不得包含源代码文件中没有用到的包
2、函数的左括号{位置
3、函数名大小写规则
4、不一定要用分号结束语句
package的名称必须和目录名保持一致&lt;/p&gt;

&lt;p&gt;Go语言的工作空间结构：
Go语言的工作空间其实就是一个文件目录，目录中必须包含src、pkg、bin三个目录。&lt;/p&gt;

&lt;p&gt;其中src目录用于存放Go源代码，pkg目录用于package对象，bin目录用于存放可执行对象
&amp;ndash;对应的环境变量的搭建&amp;ndash;
go命名行用到了GOPATH环境变量，在这个目录下收索
export GOPATH=你的工作空间路径
export PATH=$PATH:$GOPATH/bin&amp;mdash;-安装用这个路劲&lt;/p&gt;

&lt;p&gt;编译：build&lt;/p&gt;

&lt;p&gt;安装：
1、只要进入对应的应用包目录，然后执行go install，就可以安装了&lt;/p&gt;

&lt;p&gt;2、在任意的目录执行如下代码go install mymath&lt;/p&gt;

&lt;p&gt;go命令行工具
run:&lt;/p&gt;

&lt;p&gt;build:
1.如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install了。&lt;/p&gt;

&lt;p&gt;2.如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。&lt;/p&gt;

&lt;p&gt;3.如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。&lt;/p&gt;

&lt;p&gt;clean:
清除编译文件&lt;/p&gt;

&lt;p&gt;fmt：
格式化文件&lt;/p&gt;

&lt;p&gt;get：
动态获取远程代码包&lt;/p&gt;

&lt;p&gt;install：
这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin&lt;/p&gt;

&lt;p&gt;test：
自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件&lt;/p&gt;

&lt;p&gt;go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1
 go version 查看go当前的版本
go env 查看当前go的环境变量
go list 列出当前全部安装的package
 go run 编译并运行Go程序&lt;/p&gt;

&lt;p&gt;标准库：
bufio   带缓冲的io&lt;/p&gt;

&lt;p&gt;io&lt;/p&gt;

&lt;p&gt;fmt   基本输出输入&lt;/p&gt;

&lt;p&gt;Net/http.    http包提供了HTTP客户端和服务端的实现。&lt;/p&gt;

&lt;p&gt;strconv 类型转换 Itoa  Atoi&lt;/p&gt;

&lt;p&gt;time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//返回现在时间  
tNow := time.Now()  
//时间转化为string，layout必须为 &amp;quot;2006-01-02 15:04:05&amp;quot;  
timeNow := tNow.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)  
fmt.Println(&amp;quot;tNow(time format):&amp;quot;, tNow)  
fmt.Println(&amp;quot;tNow(string format):&amp;quot;, timeNow)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;make（）
make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。
//创建一个初始元素个数为5的数组切片，元素初始值为0
 a := make([]int, 5)  // len(a)=5&lt;/p&gt;

&lt;p&gt;1、变量
用关键字var来声明&lt;/p&gt;

&lt;p&gt;可以直接用:=这个服务声明初始化，但必须不是声明过的。
a := 10类似于var i int
        i = 10；
&lt;code&gt;:=&lt;/code&gt; 结构不能使用在函数外。&lt;/p&gt;

&lt;p&gt;支持多重赋值
i，j = j，i这样就完成了交换。&lt;/p&gt;

&lt;p&gt;支持匿名变量
func getname（）（firstname,lastname,nickname）{
}
&amp;mdash;&amp;gt;&lt;em&gt;,&lt;/em&gt;,nickname := getname();可以这样玩&lt;/p&gt;

&lt;p&gt;2、常量：
iota 一个特殊的常量，出现一次自动加一，当出现const的时候会自动置零
常量不能使用 := 语法定义&lt;/p&gt;

&lt;p&gt;枚举类型不需要enum
正常定义
const（
    Sunday = iota
    monday
)
其中的大写字母开头的在包外可用，小写字母开头的包内私有&lt;/p&gt;

&lt;p&gt;3、数组
1、主要是值类型，每次传参都是一个副本，要传址，需要用数组切片
2、遍历数组元素，除了用下标，也可以用关键字range，有两个返回值，一个是下标，一个是value,在对strings进行遍历的时候一个是下表，一个是ASII&lt;/p&gt;

&lt;p&gt;var a [10]int&lt;/p&gt;

&lt;p&gt;var a = [10]int{0,1,2,3,4,5,6,7,8,9}&lt;br /&gt;
var a = [&amp;hellip;]int{0,1,2,3,4,5,6,7,8,9}&lt;/p&gt;

&lt;p&gt;var a = [2][2]int{[2]int{1,1}, [2]int{2,2}}&lt;br /&gt;
var a = [2][2]int{{1,1}, {2,2}}&lt;/p&gt;

&lt;p&gt;数组切片
创建：1、在一个数组的基础上用[:]来创建
    2、直接用make函数创建
创建一个初始元素个数为5的数组切片，元素初始值为0：
mySlice1 := make([] int, 5)
创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：
mySlice2 := make([] int, 5, 10)
直接创建并初始化包含5个元素的数组切片：
mySlice3 := [] int{1, 2, 3, 4, 5}&lt;/p&gt;

&lt;p&gt;cap():分配的空间
len()：所占的元素
copy()：复制，以小的为准&lt;/p&gt;

&lt;p&gt;优点：可以动态增减元素，原始数组增减数据是要重新分配内存，然后将数据搬过去，这样比较消耗性能，但是数据切片则可以用cap（）知道分配的空间，然后充分利用，而后在内存不够会自动扩大内存。&lt;/p&gt;

&lt;p&gt;map[key] = value
定义 var a map[string]value&lt;/p&gt;

&lt;p&gt;4、控制语句：
顺序if条件中初始化的变量可以在else中使用，选择，循环(支持for，不支持while和do_while)，goto语句&amp;mdash;》跳到标志位&lt;/p&gt;

&lt;p&gt;5、函数：
关键字func、函数名、参数列表、返回值、函数体和返回语句。
func Add(a int, b int) (ret int, err error) {
}&lt;/p&gt;

&lt;p&gt;函数调用：
因此需要先牢记这样的规则：小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用。
n, err := Foo(0)
if err != nil {
 // 错误处理
} else {
 // 使用返回值n
}&lt;/p&gt;

&lt;p&gt;不定参数：传入参数的数量不变
语法糖：&amp;hellip;type
func myfunc(args &amp;hellip; int) {
}
如果是不同的类型则用interface{}
func myfunc(args &amp;hellip; interface{}) {
}&lt;/p&gt;

&lt;p&gt;如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice&amp;hellip;)。
nums := []int{1, 2, 3, 4}
myfunc(noms…)&lt;/p&gt;

&lt;p&gt;多返回值
支持匿名函数&amp;mdash;闭包？？？&lt;/p&gt;

&lt;p&gt;6、错误处理
error接口
关键字defer
defer 语句会延迟函数的执行直到上层函数返回。
两个函数panic，recover&lt;/p&gt;

&lt;p&gt;面向对象：&amp;mdash;很直接，没有隐藏this指针
func (a Integer) Less(b Integer) bool { // 面向对象
return a &amp;lt; b
}
func Integer_Less(a Integer, b Integer) bool { // 面向过程
return a &amp;lt; b
}
a.Less(2) // 面向对象的用法
Integer_Less(a, 2) // 面向过程的用法&lt;/p&gt;

&lt;p&gt;STRUCT基本和c差不多，也有继承采取了组合的文法&amp;ndash;通过结构体继承，没有private，public关键字来保护，而是通过字母大小写来，
初始化常用方法：
rect1 := new(Rect)
rect2 := &amp;amp;Rect{}
rect3 := &amp;amp;Rect{0, 0, 100, 200}
rect4 := &amp;amp;Rect{width: 100, height: 200}&lt;/p&gt;

&lt;p&gt;未显式初始化的都是对应的零值
构造函数用一个全局函数NEWXXXX来表示
func NewRect(x, y, width, height float64) *Rect {
 return &amp;amp;Rect{x, y, width, height}
}&lt;/p&gt;

&lt;p&gt;最重要的就是接口interface（是any类型）的改造-非侵入式的.&amp;mdash;可以完成包与包之间的调用，或者同一个包内部的调用
interface是一组method的组合，我们通过interface来定义对象的一组行为。实现interface中的所有方法的类就是实现了这个接口，可以调用这个接口以及这个接口中的方法。interface中的方法不能重载。
空的interface可以存储任意类型的值。&lt;/p&gt;

&lt;p&gt;并发：不要通过共享内存来通信，而应该通过通信来共享内存。
多进程&amp;mdash;&amp;mdash;-开销太大，都是基于内核的调用
多线程&amp;mdash;&amp;mdash;-相对开销小，但是远远达不到需求，最多并发1万这样
基于回调的非阻塞/异步io&amp;mdash;-共享内存式的同步异步，导致编程相当复杂
协程&amp;mdash;-轻量级线程，轻松达到100w的并发&lt;/p&gt;

&lt;p&gt;所以在协程的基础上，go支持在语言上实现协程并发goroutine，goroutine类似于进程，各个协程之间互不干涉，通过channel通信控制，这样减少了很多的复杂问题，所以goroutine重点：
关键字go&amp;mdash;&amp;ndash;只要在执行体前加上关键字go就能实现协程并发
消息通信channel&amp;mdash;&amp;ndash;不同的协程之间，通过消息channel通信&lt;/p&gt;

&lt;p&gt;channel：关键字chan
声明var ch chan int
var m map[ string] chan bool
ch := make( chan int)
c := make( chan int, 1024)&amp;ndash;带缓冲的channel，后面的参数是缓冲大小
c := make( []chan int, 1024)&amp;ndash;这个是是数组&lt;/p&gt;

&lt;p&gt;写 ch &amp;lt;- 1     向channel写入数据通常会导致程序阻塞，直到有其他goroutine从这个channel中读取数据
读 value := &amp;lt;-ch    如果channel之前没有写入数据，那么从channel中读取数据也会导致程序阻塞，直到channel中被写入数据为止——这两点可以用于数据同步。&lt;/p&gt;

&lt;p&gt;select {
 case &amp;lt;-chan1:
 // 如果chan1成功读到数据，则进行该case处理语句
 case chan2 &amp;lt;- 1:
 // 如果成功向chan2写入数据，则进行该case处理语句
default:
 // 如果上面都没有成功，则进入default处理流程
}&amp;mdash;-超时机制也是用select来实现的&lt;/p&gt;

&lt;p&gt;单向channel：
var ch1 chan int // ch1是一个正常的 channel，不是单向的
var ch2 chan&amp;lt;- float64// ch2是单向channel，只用于写float64数据
var ch3 &amp;lt;-chan int // ch3 是单向channel，只用于读取int数据&lt;/p&gt;

&lt;p&gt;ch4 := make( chan int)
ch5 := &amp;lt;-chan int(ch4) // ch5就是一个单向的读取channel
ch6 := chan&amp;lt;- int(ch4) // ch6 是一个单向的写入channel&lt;/p&gt;

&lt;p&gt;关闭close（）&amp;mdash;-x, ok := &amp;lt;-ch，可以通过ok来判断channel是否关闭，一个非空的通道也是可以关闭的，但是通道中剩下的值仍然可以被接收到。&lt;/p&gt;

&lt;p&gt;go并发也提供锁机制Mutex和RWMutex
var l sync.Mutex
func foo() {
 l.Lock()
 defer l.Unlock()
 //&amp;hellip;
}&lt;/p&gt;

&lt;p&gt;全局唯一性操作
var once sync.Once&lt;/p&gt;

&lt;p&gt;time&lt;/p&gt;

&lt;p&gt;time.Duration（时长，耗时）
time.Time（时间点）
time.C（放时间点的管道）[ Time.C:=make(chan time.Time) ]&lt;/p&gt;

&lt;p&gt;方法
定时器time—sleep，after（time.Duration）多长时间后执行，一个阻塞一个非阻塞
打点器tick（time.Duration）每隔多长时间执行一次
time.Now()当前时间
可以哟过sub，add加减
定时器和打点器可以实现速率控制&lt;/p&gt;

&lt;p&gt;排序：sort包
常用方法：
排序字符串sort.Strings()
排序int。sort.Ints()
是否排序好。sort.IntsAreSorted(ints）
可以自定义排序实现sort.Interface中的方法，然后可以用sort方法自定义排序。&lt;/p&gt;

&lt;p&gt;Panic处理意外的错误。&lt;/p&gt;

&lt;p&gt;golang中包的理解
定义：
关键字 package XXXX&lt;/p&gt;

&lt;p&gt;我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。&lt;/p&gt;

&lt;p&gt;Go标准库中的包对应的源码部分路径在：$GOROOT/src，而标准库中包编译后的.a文件路径在$GOROOT/pkg/darwin_amd64下。&lt;/p&gt;

&lt;p&gt;执行go install libproj1/foo，Go编译器编译foo包，并将foo.a安装到$GOPATH/pkg/darwin_amd64/libproj1下&amp;mdash;不用先go build然后在go install&lt;/p&gt;

&lt;p&gt;因此我们要依赖第三方包，就必须搞到第三方包的源码，这也是Golang包管理的一个特点&lt;/p&gt;

&lt;p&gt;编译main包时，编译器到底用的是.a还是源码？&amp;mdash;-在使用第三方包的时候，当源码和.a均已安装的情况下，编译器链接的是源码。
最根本的是链接的是链接了以该最新源码编译的临时目录下的.a文件，而不是pkg下面的.a文件。&amp;mdash;如果想依赖pkg下面的.a文件，那只能分布编译了，把6l链接时的-L $WORK 去掉，才会找到pkg下面（具体参考-X -V参数的编译原理）&lt;/p&gt;

&lt;p&gt;标志库也是依赖源码编译产生的临时目录下的.a文件，但是当标准库的源码发生变化时，编译器不会尝试重新编译&amp;ndash;但是第三方库发生变化时，会重新编译生成临时文件，然后连接&lt;/p&gt;

&lt;p&gt;临时文件不是一直存在的，只是在编译的时候产生&lt;/p&gt;

&lt;p&gt;import后面的是路劲名还是包名？&amp;mdash;&amp;ndash;import后面的最后一个元素应该是路径，就是目录，并非包名。&amp;ndash;而调用的函数的那个是包名&amp;mdash;所以源码路劲一定要存在，不然就can not find&lt;/p&gt;

&lt;p&gt;引用包
import 文件所在的目录路劲（除去$GOPATH/src）
同一个目录下不能定义不同的package&lt;/p&gt;

&lt;p&gt;import m &amp;ldquo;lib/math&amp;rdquo;import语句用m替代lib/math  m指代的是lib/math路径下唯一的那个包&amp;ndash;一定是唯一，不然报错&lt;/p&gt;

&lt;p&gt;第三方语言包管理插件godep安装：
我这边找了一个现成的exe文件放到对应的目录下：&lt;a href=&#34;https://github.com/kr/heroku-buildpack-go/raw/master/linux-amd64/bin/godep&#34;&gt;https://github.com/kr/heroku-buildpack-go/raw/master/linux-amd64/bin/godep&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;go环境变量：
GOROOT ：go的安装目录&lt;/p&gt;

&lt;p&gt;GOPATH ：你自己开发go语言代码的目录，目录结构为bin,pkg,src，如果你有多个目录，那么使用分号分隔。&lt;/p&gt;

&lt;p&gt;网络编程：
    func Dial(net, addr string) (Conn, error)&lt;/p&gt;

&lt;p&gt;其中net参数是网络协议的名字， addr参数是IP地址或域名，而端口号以“:”的形式跟随在地址
或域名的后面，端口号可选。如果连接成功，返回连接对象，否则返回error。&lt;/p&gt;

&lt;p&gt;Dial() 函数支持如下几种网络协议： &amp;ldquo;tcp&amp;rdquo; 、 &amp;ldquo;tcp4&amp;rdquo; （仅限IPv4）、 &amp;ldquo;tcp6&amp;rdquo; （仅限
IPv6）、 &amp;ldquo;udp&amp;rdquo; 、 &amp;ldquo;udp4&amp;rdquo;（仅限IPv4）、 &amp;ldquo;udp6&amp;rdquo;（仅限IPv6）、 &amp;ldquo;ip&amp;rdquo; 、 &amp;ldquo;ip4&amp;rdquo;（仅限IPv4）和&amp;rdquo;ip6&amp;rdquo;
（仅限IPv6）。&lt;/p&gt;

&lt;p&gt;func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error)
func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error)
func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)
func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err error)&lt;/p&gt;

&lt;p&gt;与之前使用Dail() 的例子相比，这里有两个不同:
net.ResolveTCPAddr() ，用于解析地址和端口号；
net.DialTCP() ，用于建立链接。
这两个函数在Dial() 中都得到了封装。/Applications/QQ.app&lt;/p&gt;

&lt;p&gt;我们给 fmt.Println 一个短名字的别名
var p = fmt.Println&lt;/p&gt;

&lt;p&gt;随机数rand&lt;/p&gt;

&lt;p&gt;Rand. Intn(n)。int代表整数，后面的n代表范围，其他类型类似&lt;/p&gt;

&lt;p&gt;((rand.Float64() * 5) + 5)这个技巧可以用来生成其他范围的随机浮点数，例如5.0 &amp;lt;= f &amp;lt;= 10.0&lt;/p&gt;

&lt;p&gt;种子
s1 := rand.NewSource(time.Now().UnixNano())
    r1 := rand.New(s1)&lt;/p&gt;

&lt;p&gt;相同的种子产生的随机数是一样的。&lt;/p&gt;

&lt;p&gt;数字解析包strconv
Url解析包url
SHA1散列就是通过一个算法计算散列值，使用Go 在多个 crypto/* 包中实现了一系列散列函数。
Base64编码—加密解密&lt;/p&gt;

&lt;p&gt;命令行参数
os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。&lt;/p&gt;

&lt;p&gt;命令行标志解析flag包
环境变量设置在os包&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;go提供了安装包，直接下载解压设置/etc/profile环境变量就可以使用go了，简单便捷&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOROOT=/home/test/Go/go—-源码安装路径

export PATH=$GOROOT/bin:$PATH——声明应用

export GOPATH=/home/test/Go/go-project—你的项目路劲
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;最常用的一种形式&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;./test&amp;rdquo;导入同一目录下test包中的内容&lt;/p&gt;

&lt;p&gt;import f &amp;ldquo;fmt&amp;rdquo;导入fmt，并给他启别名ｆ&lt;/p&gt;

&lt;p&gt;import . &amp;ldquo;fmt&amp;rdquo;，将fmt启用别名&amp;rdquo;.&amp;ldquo;，这样就可以直接使用其内容，而不用再添加ｆｍｔ，如fmt.Println可以直接写成Println&lt;/p&gt;

&lt;p&gt;import  _ &amp;ldquo;fmt&amp;rdquo; 表示不使用该包，而是只是使用该包的init函数，并不显示的使用该包的其他内容。注意：这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;struct&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type person struct {
    name string
    age int
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;    var P person  // P现在就是person类型的变量了
    P.name = &amp;quot;Astaxie&amp;quot;  // 赋值&amp;quot;Astaxie&amp;quot;给P的name属性.
    P.age = 25  // 赋值&amp;quot;25&amp;quot;给变量P的age属性type person struct {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按照顺序提供初始化值&lt;/p&gt;

&lt;p&gt;P := person{&amp;ldquo;Tom&amp;rdquo;, 25}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过field:value的方式初始化，这样可以任意顺序&lt;/p&gt;

&lt;p&gt;P := person{age:24, name:&amp;ldquo;Tom&amp;rdquo;}&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;4。 interface&lt;/p&gt;

&lt;p&gt;Go语言引入了一种新类型—Interface，它在效果上实现了类似于C++的“多态”概念。&lt;/p&gt;

&lt;p&gt;从语法上看，Interface定义了一个或一组method(s)，这些method只有函数签名，没有具体的实现代码（有没有联想起C++中的虚函数？）。若某个数据类型实现了Interface中定义的那些被称为&amp;rdquo;methods&amp;rdquo;的函数，则称这些数据类型实现（implement）了interface。&lt;/p&gt;

&lt;p&gt;Interface类型的更通用定义可归纳如下：
type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    &amp;hellip;
}&lt;/p&gt;

&lt;p&gt;以fmt包的Printf()函数为例，其函数签名格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Printf(format string, a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数在实现底层的打印行为时，要求传入的可变长参数实现了fmt包中定义的Stringer接口，这个接口类型定义及描述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Stringer interface {
    String() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一段简单的打印代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

func main() {
    addrs := map[string]IPAddr{
        &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
        &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
    }
}

loopback: [127 0 0 1]
googleDNS: [8 8 8 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要求按规定的格式打印：IPAddr{1, 2, 3, 4}应该输出为&amp;rdquo;1.2.3.4&amp;rdquo;的格式，所以IPAddr这个自定义类型需要实现Stringer接口，实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

// TODO: Add a &amp;quot;String() string&amp;quot; method to IPAddr.
func (ip IPAddr) String() string {    
    return fmt.Sprintf(&amp;quot;%v.%v.%v.%v&amp;quot;, ip[0], ip[1], ip[2], ip[3])
}

func main() {
    addrs := map[string]IPAddr{
        &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
        &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
    }
}

googleDNS: 8.8.8.8
loopback: 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;go tool&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;go build&lt;/p&gt;

&lt;p&gt;go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。&lt;/p&gt;

&lt;p&gt;如果是普通包，当你执行go build命令后，不会产生任何文件。&lt;/p&gt;

&lt;p&gt;如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin木下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/a.exe。&lt;/p&gt;

&lt;p&gt;如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。&lt;/p&gt;

&lt;p&gt;你也可以指定编译输出的文件名。比如，我们可以指定go build -o myapp.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。&lt;/p&gt;

&lt;p&gt;go build 会忽略目录下以”_”或者”.”开头的go文件。&lt;/p&gt;

&lt;p&gt;go build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。&lt;/p&gt;

&lt;p&gt;go clean&lt;/p&gt;

&lt;p&gt;go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括&lt;/p&gt;

&lt;p&gt;_obj/ 旧的object目录，由Makefiles遗留
_test/ 旧的test目录，由Makefiles遗留
_testmain.go 旧的gotest文件，由Makefiles遗留
test.out 旧的test记录，由Makefiles遗留
build.out 旧的test记录，由Makefiles遗留
*.[568ao] object文件，由Makefiles遗留
DIR(.exe) 由 go build 产生
DIR.test(.exe) 由 go test -c 产生
MAINFILE(.exe) 由 go build MAINFILE.go产生&lt;/p&gt;

&lt;p&gt;go fmt&lt;/p&gt;

&lt;p&gt;go fmt 命令主要是用来帮你格式化所写好的代码文件。&lt;/p&gt;

&lt;p&gt;比如我们写了一个格式很糟糕的test.go文件，我们只需要使用fmt命令，就可以让go帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了 go fmt 命令而已。&lt;/p&gt;

&lt;p&gt;使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w src，可以格式化整个项目。&lt;/p&gt;

&lt;p&gt;go get&lt;/p&gt;

&lt;p&gt;go get 命令主要是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具.&lt;/p&gt;

&lt;p&gt;所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。&lt;/p&gt;

&lt;p&gt;go get 命令本质上可以理解为：首先通过源码工具clone代码到src目录，然后执行go install。&lt;/p&gt;

&lt;p&gt;如果需要更新所有的依赖库，增加 -u 参数&lt;/p&gt;

&lt;p&gt;go install&lt;/p&gt;

&lt;p&gt;go install 命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。&lt;/p&gt;

&lt;p&gt;.exe文件： 一般是 go install 带main函数的go文件产生的，有函数入口，所有可以直接运行。&lt;/p&gt;

&lt;p&gt;.a应用包： 一般是 go install 不包含main函数的go文件产生的，没有函数入口，只能被调用。&lt;/p&gt;

&lt;p&gt;go test&lt;/p&gt;

&lt;p&gt;go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似&lt;/p&gt;

&lt;p&gt;ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
&amp;hellip;
默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag&lt;/p&gt;

&lt;p&gt;go doc&lt;/p&gt;

&lt;p&gt;go doc 命令其实就是一个很强大的文档工具。&lt;/p&gt;

&lt;p&gt;如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net/http；查看某一个包里面的函数，那么执行godoc fmt Printf；也可以查看相应的代码，执行godoc -src fmt Printf；&lt;/p&gt;

&lt;p&gt;通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。&lt;/p&gt;

&lt;p&gt;其他命令&lt;/p&gt;

&lt;p&gt;Go语言还提供了其它有用的工具，例如下面的这些工具&lt;/p&gt;

&lt;p&gt;go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1&lt;/p&gt;

&lt;p&gt;go version 查看go当前的版本&lt;/p&gt;

&lt;p&gt;go env 查看当前go的环境变量&lt;/p&gt;

&lt;p&gt;go list 列出当前全部安装的package&lt;/p&gt;

&lt;p&gt;go run 编译并运行Go程序&lt;/p&gt;

&lt;h2 id=&#34;开发工具&#34;&gt;开发工具&lt;/h2&gt;

&lt;p&gt;尝试了liteide和sublime text，感觉还是sublime text比较好，它支持源码的查看的跳转，编译执行，而liteide在跳转上有点问题，不能跳转到自定义的函数，不知道是不是我配置的问题（基本上就是在查看选项设定了go环境变量），所以自己开发的时候决定用sublime&lt;/p&gt;

&lt;p&gt;sublime text go环境搭建&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在mac上安装go并设置好环境变量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装一个Package Control，这个应该是一个插件管理工具，用于安装很多其他插件的，只要用ctrl+ ` 打开命令行输入执行命令&lt;/p&gt;

&lt;p&gt;import urllib.request,os,hashlib; h = &amp;lsquo;7183a2d3e96f11eeadd761d777e62404&amp;rsquo; + &amp;lsquo;e330c659d4bb41d3bdf022e94cab3cd0&amp;rsquo;; pf = &amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &amp;lsquo;&lt;a href=&#34;http://sublime.wbond.Net/&#39;&#34;&gt;http://sublime.wbond.Net/&#39;&lt;/a&gt; + pf.replace(&amp;rsquo; &amp;lsquo;, &amp;lsquo;%20&amp;rsquo;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&amp;lsquo;Error validating download (got %s instead of %s), please try manual install&amp;rsquo; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &amp;lsquo;wb&amp;rsquo; ).write(by)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装好后可以在preferences中找到这个插件。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装go插件gosublime&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们点击Package Control插件或者用shift+ctrl+p来打开，输入pcip（Package Control:Install Package的缩写）也就是安装插件的意思。然后输入gosublime就会自动安装了，安装好了依旧可以在preferences下找到这个gosublime插件。&lt;/p&gt;

&lt;p&gt;4.然后就可以在gopath下建src，src下建对应的项目，使用sublime进行编码，查看，按command+b进入到shell模式进行编译执行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>markdown的基本使用</title>
      <link>http://kingjcy.github.io/blog/2014/11/24/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 24 Nov 2014 16:50:39 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2014/11/24/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;markdown&#34;&gt;Markdown&lt;/h2&gt;

&lt;p&gt;markdown是一种可以用文本编辑器就编写带有特定格式的标记语言，语法简单，容易上手，使得编写文档到web界面展示更加简便快捷，也使我们的精力更加注重到文档内容的本身。这边只是对于markdown的语法做一个简单的学习与备忘，没有深入研究。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-标题&#34;&gt;1. 标题&lt;/h3&gt;

&lt;p&gt;在Markdown当中设置标题，有两种方式：&lt;/p&gt;

&lt;p&gt;第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。&lt;/p&gt;

&lt;p&gt;第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）&lt;/p&gt;

&lt;p&gt;标题&lt;/p&gt;

&lt;p&gt;#一级标题&lt;/p&gt;

&lt;p&gt;##二级标题&lt;/p&gt;

&lt;p&gt;###三级标题&lt;/p&gt;

&lt;h3 id=&#34;2-块注释&#34;&gt;2. 块注释&lt;/h3&gt;

&lt;p&gt;通过在文字开头添加“&amp;gt;”表示块注释。（当&amp;gt;和文字之间添加五个blank时，块注释的文字会有变化。）也就是平时使用的引用。&lt;/p&gt;

&lt;h3 id=&#34;3-粗体与斜体&#34;&gt;3. 粗体与斜体&lt;/h3&gt;

&lt;p&gt;Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;
将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;粗体&lt;/strong&gt;
将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来&lt;/p&gt;

&lt;h3 id=&#34;4-无序列表&#34;&gt;4. 无序列表&lt;/h3&gt;

&lt;p&gt;在文字开头添加(&lt;em&gt;, +, and -)实现无序列表。但是要注意在(&lt;/em&gt;, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）&lt;/p&gt;

&lt;h3 id=&#34;5-有序列表&#34;&gt;5. 有序列表&lt;/h3&gt;

&lt;p&gt;使用数字后面跟上句号。（还要有空格）&lt;/p&gt;

&lt;h3 id=&#34;6-链接-links&#34;&gt;6. 链接（Links）&lt;/h3&gt;

&lt;p&gt;Markdown中有两种方式，实现链接，分别为内联方式和引用方式。&lt;/p&gt;

&lt;p&gt;内联方式：This is an &lt;a href=&#34;http://example.com/&#34;&gt;example link&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is an [example link](http://example.com/).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用方式：
I get 10 times more traffic from &lt;a href=&#34;http://google.com/&#34; title=&#34;Google&#34;&gt;Google&lt;/a&gt; than from &lt;a href=&#34;http://search.yahoo.com/&#34; title=&#34;Yahoo Search&#34;&gt;Yahoo&lt;/a&gt; or &lt;a href=&#34;http://search.msn.com/&#34; title=&#34;MSN Search&#34;&gt;MSN&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].


[1]: http://google.com/        &amp;quot;Google&amp;quot; 
[2]: http://search.yahoo.com/  &amp;quot;Yahoo Search&amp;quot; 
[3]: http://search.msn.com/    &amp;quot;MSN Search&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-图片-images&#34;&gt;7. 图片（Images）&lt;/h3&gt;

&lt;p&gt;图片的处理方式和链接的处理方式，非常的类似。&lt;/p&gt;

&lt;p&gt;内联方式：
&lt;code&gt;![alt text](/path/to/img.jpg &amp;quot;Title&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用方式：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;![alt text][id]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[id]: /path/to/img.jpg &amp;quot;Title&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;9-代码-html中所谓的code&#34;&gt;9. 代码（HTML中所谓的Code）&lt;/h3&gt;

&lt;p&gt;实现方式有两种：&lt;/p&gt;

&lt;p&gt;第一种：简单文字出现一个代码框。使用&lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt;。（&lt;code&gt;不是单引号而是左上角的ESC下面~中的&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;第二种：大片文字需要实现代码框。使用Tab和四个空格。&lt;/p&gt;

&lt;h3 id=&#34;10-脚注-footnote&#34;&gt;10. 脚注（footnote）&lt;/h3&gt;

&lt;p&gt;实现方式如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hello[^hello]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[^hello]: hi&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;11-分割线&#34;&gt;11. 分割线&lt;/h3&gt;

&lt;p&gt;分割线的语法只需要另起一行，连续输入三个星号 ***或者&amp;mdash; 即可。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;12-表格&#34;&gt;12. 表格&lt;/h3&gt;

&lt;p&gt;使用很简单&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Year&lt;/th&gt;
&lt;th&gt;Temperature (low)&lt;/th&gt;
&lt;th&gt;Temperature (high)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1900&lt;/td&gt;
&lt;td&gt;-10&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1910&lt;/td&gt;
&lt;td&gt;-15&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1920&lt;/td&gt;
&lt;td&gt;-10&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;Year | Temperature (low) | Temperature (high)
-----|----|----
1900 | -10 | 25
1910 | -15 | 30
1920 | -10 | 32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这边差不多就够我平时写文档时用的了，如果有需要特殊情况的可以进行网上搜索，查询使用.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>