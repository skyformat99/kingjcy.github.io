<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/tags/linux/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux进程后台运行方式</title>
      <link>http://kingjcy.github.io/blog/2015/12/29/linux%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 29 Dec 2015 09:20:23 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2015/12/29/linux%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;p&gt;让linux进程后台运行是我们开发过程中很有必要的事情，不但可以不影响shell的操作，而且可以解决ssh断开后进程继续运行的问题，在一些比较耗时间的进程上，可以放在后台慢慢跑，不影响当前操作，可以说很有用途，下面我们来了解一下几种linux进程后台运行的方式。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-进程后台运行&#34;&gt;1.进程后台运行&lt;/h2&gt;

&lt;p&gt;我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;nohup&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;nohup就是忽略hangup的信号。&lt;/p&gt;

&lt;p&gt;用法：nohup 命令 [参数]&amp;hellip;&lt;/p&gt;

&lt;p&gt;　或：nohup 选项&lt;/p&gt;

&lt;p&gt;忽略挂起信号运行指定的命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--help      显示此帮助信息并退出
--version       显示版本信息并退出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上&amp;rdquo;&amp;amp;&amp;ldquo;来将命令同时放入后台运行，也可用&amp;rdquo;&amp;gt;filename 2&amp;gt;&amp;amp;1&amp;rdquo;来更改缺省的重定向文件名。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;setsid&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;setsid就是改变该进程的属于，不属于该终端的子进程。&lt;/p&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setsid [选项] &amp;lt;程序&amp;gt; [参数 ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-c, --ctty     将控制终端设置为当前终端
-h, --help     显示此帮助并退出
-V, --version  输出版本信息并退出
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;amp;就是把进程转为后台进程job，可以用ps查看。这个也是通过躲避hangup信号来实现的。可以通过bg和fg job_spec来切换前台后台状态。&lt;/p&gt;

&lt;p&gt;可以通过jobs来查看后台job进程。&lt;/p&gt;

&lt;h2 id=&#34;2-已运行进程后台运行&#34;&gt;2.已运行进程后台运行&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;disown&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用disown -h jobspec来使某个作业忽略HUP信号。&lt;/p&gt;

&lt;p&gt;用disown -ah 来使所有的作业都忽略HUP信号。&lt;/p&gt;

&lt;p&gt;用disown -rh 来使正在运行的作业忽略HUP信号。&lt;/p&gt;

&lt;p&gt;需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。&lt;/p&gt;

&lt;h2 id=&#34;3-大批量操作&#34;&gt;3.大批量操作&lt;/h2&gt;

&lt;p&gt;使用 screen 很方便，有以下几个常用选项：&lt;/p&gt;

&lt;p&gt;用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）。&lt;/p&gt;

&lt;p&gt;用screen -list 来列出所有会话。&lt;/p&gt;

&lt;p&gt;用screen -r session name来重新连接指定会话。&lt;/p&gt;

&lt;p&gt;用快捷键CTRL-a d 来暂时断开当前会话。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>linux分区与挂载</title>
      <link>http://kingjcy.github.io/blog/2015/12/20/linux%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/</link>
      <pubDate>Sun, 20 Dec 2015 15:47:26 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2015/12/20/linux%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/</guid>
      <description>&lt;p&gt;Linux中一切皆文件，理解linux系统下的分区和挂载能够很大程度的来帮助我们理解linux文件系统。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;分区&#34;&gt;分区&lt;/h2&gt;

&lt;p&gt;其实是对磁盘进行划分以便于存储管理。主要是使用fdisk命令来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp17 /]# fdisk -l

磁盘 /dev/sda：214.7 GB, 214748364800 字节，419430400 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x0006fd47

设备 Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048   419430399   209202176   8e  Linux LVM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这台机器上有一块大小为214G的磁盘，这块磁盘有两个分区，sda1和sda2,假如是一块新磁盘，就可以直接使用fdisk /dev/sda来进行sda[1-N]，具体操作很简单这边就不赘述了。&lt;/p&gt;

&lt;p&gt;这边有一个概念，就是不同接口对应的磁盘名也是不一样的，IDE接口的则是hd[a-z][1-N],SCSI和SATA接口的则是sd[a-z][1-N],还有其他。&lt;/p&gt;

&lt;h2 id=&#34;lvm&#34;&gt;LVM&lt;/h2&gt;

&lt;p&gt;上面分区分好后我们可以使用LVM来进行管理，由此可见，LVM是对磁盘分区后的一种管理机制。&lt;/p&gt;

&lt;p&gt;LVM中有四大命令&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先是将分区转化为物理卷，然后就可以在物理卷上进行逻辑卷的操作了&lt;/p&gt;

&lt;p&gt;pvcreate /dev/sda2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建卷组,并将这个物理卷加入到卷组中&lt;/p&gt;

&lt;p&gt;vgcreate vgdata /dev/sda2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从物理卷中分割内存创建逻辑卷&lt;/p&gt;

&lt;p&gt;lvcreate -L size -n name vgdata&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有些卷组已经创建好的，我们就可以直接来创建逻辑卷了，可以用vgdisplay来查看有哪些卷组。同样查看有哪些逻辑卷用lvdisplay.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;删除逻辑卷&lt;/p&gt;

&lt;p&gt;lvremove name&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;格式化逻辑卷&#34;&gt;格式化逻辑卷&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mkfs [-V] [-t fstype] [fs-options] filesys [blocks] [-L Lable]
-t  就是指定格式化文件的格式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以直接使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs.xfs(文件格式)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令也还是调用的mkfs.xfs这个命令。&lt;/p&gt;

&lt;h2 id=&#34;挂载&#34;&gt;挂载&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mount [-t vfstype] [-o options] device dir
-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。
-o options 主要用来描述设备或档案的挂接方式。ro：采用只读方式挂接设 rw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集
device 要挂接(mount)的设备。也就是逻辑卷。
dir设备在系统上的挂接点(mount point)。也就是挂载目录。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查看&#34;&gt;查看&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp17 /]# df -h
文件系统                 容量  已用  可用 已用% 挂载点
/dev/mapper/centos-root   50G  6.4G   44G   13% /
devtmpfs                 4.9G     0  4.9G    0% /dev
tmpfs                    4.9G   84K  4.9G    1% /dev/shm
tmpfs                    4.9G   17M  4.9G    1% /run
tmpfs                    4.9G     0  4.9G    0% /sys/fs/cgroup
/dev/mapper/centos-home   50G   33M   50G    1% /home
/dev/sda1                497M  141M  356M   29% /boot
tmpfs                   1001M   16K 1001M    1% /run/user/42
tmpfs                   1001M     0 1001M    0% /run/user/0
/dev/mapper/centos-ceph   50G  5.1G   45G   11% /ceph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;df加-h可以更加清晰的查看系统文件，看看逻辑卷挂载点在哪，也可以直接看挂载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp17 /]# mount | grep centos
/dev/mapper/centos-root on / type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/mapper/centos-home on /home type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/mapper/centos-ceph on /ceph type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;卸载挂载的文件系统&#34;&gt;卸载挂载的文件系统&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;umount device
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>linux下ccpp</title>
      <link>http://kingjcy.github.io/blog/2015/03/14/linux%E4%B8%8Bccpp/</link>
      <pubDate>Sat, 14 Mar 2015 15:14:28 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2015/03/14/linux%E4%B8%8Bccpp/</guid>
      <description>&lt;p&gt;这里主要是一些平时linux c/c++下编程时遇到的一些注意点，记录下来便于学习和备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;c-c-库&#34;&gt;c/c++库&lt;/h2&gt;

&lt;p&gt;在我们编程过程中经常需要用到别人封装好的库（库是一种用于快速开发，迅速上手，不必重复造轮子，任何一个产品都需要一个库文件提供api，让我们接入使用），在调用的时候，分为静态库和动态库。&lt;/p&gt;

&lt;p&gt;linux下静态库和共享库：库文件名必须以lib开头&lt;/p&gt;

&lt;p&gt;静态库是.a文件，编译时会包含在可执行文件中，可执行文件运行时是不需要该静态库的，这样会使可执行文件变大，占用内存和磁盘空间，ar rcs 库名 。o文件名&lt;/p&gt;

&lt;p&gt;动态库是.so .sa文件，这个是在可执行文件中保存一个地址列表，程序运行时用到才会去调用，不然加载到内存中共享，节省资源，现在比较实用的方法   gcc -shared -fPIC.o文件名 库名.so&lt;/p&gt;

&lt;p&gt;编译搜索路径：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;-L,-I指定的路劲下&lt;/li&gt;
&lt;li&gt;环境变量下指定路劲，libarypath ,LD_LIBRARY_PATH&lt;/li&gt;
&lt;li&gt;系统指定的路劲，usr/include,usr/lib,usr/local/inlude,usr/local/lib&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动态库的优先级高于静态库&lt;/p&gt;

&lt;p&gt;在一个程序运行时是不需要静态库的，但是需要链接动态库，所以一个可执行文件运行环境改变时，需要将其对应的动态库一并复制到新环境中，这些动态库是可以共享的&lt;/p&gt;

&lt;p&gt;我们可以使用ldd 可执行文件名，来查看对应的动态库是否找到了&lt;/p&gt;

&lt;p&gt;如果没有找到，则需要增加对应的动态库：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf文件的，但是添加完后需要调用下ldconfig，不然添加的library会找不到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果添加的library不在/lib和/usr/lib里面的话，就一定要修改/etc/ld.so.conf文件，往该文件追加library所在的路径，然后也需要重新调用下ldconfig命令。比如在安装MySQL的时候，其库文件/usr/local/mysql/lib，就需要追加到/etc/ld.so.conf文件中。命令如下：&lt;/p&gt;

&lt;p&gt;$echo &amp;ldquo;/usr/local/mysql/lib&amp;rdquo; &amp;gt;&amp;gt; /etc/ld.so.conf
$ldconfig&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果添加的library不在/lib或/usr/lib下，但是却没有权限操作写/etc/ld.so.conf文件的话，这时就需要往export里写一个全局变量LD_LIBRARY_PATH，就可以了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ace&#34;&gt;ACE&lt;/h3&gt;

&lt;p&gt;ACE可以说是在网络编程中比较著名的了，自适配通信环境（ADAPTIVE Communication Environment）是一个比较重量级的家伙，有大约二十万行代码，一堆的设计模式，很多架构，支持跨平台。ACE提供了一组丰富的可复用C++ Wrapper Facade（包装外观）和框架组件，可跨越多种平台完成通用的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。ACE的目标用户是高性能和实时通信服务和应用的开发者。它简化了使用进程间通信、事件多路分离、显式动态链接和并发的OO网络应用和服务的开发。此外，通过服务在运行时与应用的动态链接，ACE还使系统的配置和重配置得以自动化&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;ACE_DLL&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ACE_DLL封装了操作系统对dll(动态链接库Dynamic Link Library)的操作，因为Windows和*nix对dll操作的接口不一致，如Windows使用LoadLibrary/GetProcAddress/FreeLibrary这三个函数来显示地加载dll，从dll中找到函数地址以及关闭dll，而Linux则使用dlopen/dlsym/dlclose做同样的事情，ACE要使得程序具有良好的跨平台特性就需要屏蔽这些平台的差异性，而向上呈现出统一的接口。&lt;/p&gt;

&lt;p&gt;下面这个例子展示了如何使用ACE_DLL类来操作dll。&lt;/p&gt;

&lt;p&gt;dll_impl.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

//向外暴露这个接口，使用&amp;quot; extern &amp;quot;C&amp;quot; &amp;quot;来声明之，否则待会儿调用symbol来获取本函数的地址时就必须填全名
extern &amp;quot;C&amp;quot; person create_person(const string&amp;amp; name, unsigned int age);

class person
{

public:
    person(const string&amp;amp; name, unsigned int age);

    ~person();

    string get_person_name() const;

    private:
        string m_name;
        unsigned int m_age;
};
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dll_impl.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`
#include &amp;quot;dll_impl.h&amp;quot;

person::person(const string&amp;amp; name, unsigned int age) : m_name(name), m_age(age)
{
    cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;quot; say hello!&amp;quot; &amp;lt;&amp;lt; endl;
}

person::~person() 
{
    cout &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;quot; say byebye!&amp;quot; &amp;lt;&amp;lt; endl;
}

string person::get_person_name() const {
    return m_name;
}

person create_person(const string&amp;amp; name, unsigned int age){
    return person(name, age);
}
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dll_test.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`
#include &amp;quot;ace/Log_Msg.h&amp;quot;
#include &amp;quot;ace/DLL.h&amp;quot; 
#include &amp;quot;ace/ACE.h&amp;quot;

#include &amp;quot;dll_impl.h&amp;quot;

int main()
{
    ACE_DLL dll;

    int retval = dll.open(&amp;quot;libperson.so&amp;quot;, ACE_DEFAULT_SHLIB_MODE, 1);  

    if (retval != 0) {
        return -1;
    }else{
        ACE_DEBUG((LM_DEBUG, &amp;quot;open the dll successfully!!!\n&amp;quot;));
    }

    //声明一个函数指针类型
    typedef person (*person_factory)(const string&amp;amp; name, unsigned int age);

    person_factory fac=(person_factory)dll.symbol(&amp;quot;create_person&amp;quot;);

    if(fac == NULL)
    {
        cout &amp;lt;&amp;lt; &amp;quot;get symbol failed!&amp;quot; &amp;lt;&amp;lt; endl;
        return -1;
    }

    person per = fac(&amp;quot;ecy&amp;quot;, 24);

    cout &amp;lt;&amp;lt; per.get_person_name() &amp;lt;&amp;lt; endl;

    dll.close();

    return 0;
 }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译过程如下：&lt;/p&gt;

&lt;p&gt;1、首先生成动态链接库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -shared -o libperson.so dll_impl.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、生成测试程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -g -o dll_test dll_test.cpp -L. -lperson -lACE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、设置LD_LIBRARY_PATH&lt;/p&gt;

&lt;p&gt;测试程序运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ecy@ecy-geek:~/ACE/ace_dll$ ./dll_test 
open the dll successfully!!!
ecy say hello!
ecy
ecy say byebye!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对象编程和结构编程&#34;&gt;对象编程和结构编程&lt;/h2&gt;

&lt;p&gt;面向结构（c）就好比一个游戏中的怪物，我把这个怪物的各个方面分解成许多小的代码实现相应的动作最后共同实现，至此只这一个怪物，如果想要生成多个怪物，只需要重复编写相同的代码.&lt;/p&gt;

&lt;p&gt;面向对象（c++）就好比我把这个怪物封装为一个模型，然后生成多个对象，只对此对象进行在操作，这样每个对象的状态都可以是不一样的&lt;/p&gt;

&lt;p&gt;我觉得这个是对对象编程和结构编程一种比较好对描述。所以在很多过程中把c/c++结合起来实用比较好。&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;c++&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;private类成员不能在类以外直接访问，可以通过类的public方法来访问，当然类本身也可以访问&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类对象 是 在内存栈中使用构造函数开辟的一块内存空间&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-复制则将内存中的数据复制过去，但是本身对象地址不会改变&lt;/p&gt;

&lt;p&gt;类指针 是 在内存堆中使用new开辟出来的一个内存地址（nwe都是在内存堆上）,但是指针本身存储在栈上&amp;mdash;&amp;mdash;&amp;ndash;复制则将改变了指针的地址，那么就都不一样了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义指针时，包括上面的类指针，一定要new（malloc（size））出一片内存空间来给这个指针赋值，这个时候才能调用构造函数来初始化这个类，才使得类的内存空间初始化完成，后才能调用内部的成员变量和成员函数，但是定义对象时会自动调用构造函数，完成类的空间分配。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;顺序容器vector   类模板 (list, deque)
声明：vector&amp;lt;int&amp;gt; ivec;
初始化：vector&amp;lt;T&amp;gt; v1/v2(v1)/v1(n,i)/v1(n)值初始化
操作：empty(),size()--&amp;gt;size_type,push_back(),begin(),end()，c[n]=c.at(n),push_front(),front(),back()，push_insert()，删除erase(),clear() pop_back()，pop_front() ，swap()交换,assign()重置，capacity()容量，reserve（）剩余存储空间                        
下标：从0开始
迭代器iterator：--&amp;gt;const_iterator 只读不写,迭代器循环一直到最后一个位置的下一位
      for(vector&amp;lt;int&amp;gt;::iterator iter=iter.begin()，iter!=iter.end(),++iter) 
      *iter=0;
类型：size_type,iterator,const_iterator....
string： 
操作：substr()---&amp;gt;s.substr(pos,n)   返回s中从下标pos开始的n个字符,replace()，append()追加,find(),compare(),getline().
容器适配器：
    stack:empty(),top(),pop(),size(),push()---&amp;gt;FILO
    queue:empty(),front(),back(),push(),size(),pop()
    priority_queue:push(),top()




关联容器
类型：
pair:声明            初始化                                   成员
操作:pair&amp;lt;t1,t2&amp;gt;p1,pair&amp;lt;t1,t2&amp;gt;p1(v1,v2)--&amp;gt;make_pair(v1,v2) p.first,p.second
map :
map&amp;lt;k,v&amp;gt;m;     m.instert(make_pair(v1,v2)),m.insert(map(string,int)::value_type(v1,v2))----&amp;gt;value_type与pair&amp;lt;const k,v&amp;gt;是一样的

map[key] = value的两种插入存储代码：
        1、mapReconFtpCfg[key] = v_RecondCfgList[i];


        2、mapProductCumulateCfg.insert( make_pair( g_ProductCumulateCfg[i].m_nPRODUCT_CODE, g_ProductCumulateCfg[i] ) );

count(),find(),erase()       
set 
multimap的find，equal_range查找，find返回的是一直指向第一个key（value）的指针，equal_range返回是一对指针（pair），first指向的是第一个key（value），second指向的是最后一个key（value）的下一个位置，如果要用其中的数据，就可以遍历，用迭代器，前面的指针就是迭代器，只要++（被重载过，就相当于指针指向下一个）就可以一个个数据遍历然后就可以用了还可以用count()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string的find&lt;/p&gt;

&lt;p&gt;////find函数返回类型 size_type&lt;br /&gt;
 string s(&amp;ldquo;1a2b3c4d5e6f7g8h9i1a2b3c4d5e6f7g8ha9i&amp;rdquo;);&lt;br /&gt;
 string flag;&lt;br /&gt;
 string::size_type position;&lt;/p&gt;

&lt;p&gt;//find 函数 返回jk 在s 中的下标位置&lt;br /&gt;
 position = s.find(&amp;ldquo;jk&amp;rdquo;);&lt;br /&gt;
 if (position != s.npos)  //如果没找到，返回一个特别的标志c++中用npos表示，我这里npos取值是4294967295,它表示string结束的地方，相当于char*中的\0
     {&lt;br /&gt;
       cout &amp;lt;&amp;lt; &amp;ldquo;position is : &amp;ldquo; &amp;lt;&amp;lt; position &amp;lt;&amp;lt; endl;&lt;br /&gt;
     }&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据转换&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(long)-1  直接转化-1为long&lt;/p&gt;

&lt;p&gt;nvl(pool_id，0) 如果pool_id值不存在就为0，这个是在sql中实用&lt;/p&gt;

&lt;p&gt;lexical_cast&lt;/p&gt;

&lt;p&gt;XXXX_cast&amp;lt;类型&amp;gt;（数据）&amp;mdash;&amp;mdash;&amp;mdash;-数据本身类型不变，产生一个临时数据&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;fork&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;fork,创建子进程，重fork向下是父进程和子进程同时执行，调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1）在父进程中，fork返回新创建子进程的进程ID；也就是说大于0的是父进程

2）在子进程中，fork返回0；等于0的是子进程

3）如果出现错误，fork返回一个负值；小于0出错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.extern&lt;/p&gt;

&lt;p&gt;在源文件A里定义的函数，在其它源文件里是看不见的（即不能访问）。为了在源文件B里能调用这个函数，应该在B的头部加上一个外部声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; extern   函数原型；   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，在源文件B里也可以调用那个函数了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;启动参数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;argc表示启动参数的个数，argv代表启动参数的值 ，argv[0] 进程名，argv[1]第一个参数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;makefile基础&lt;/p&gt;

&lt;p&gt;MakeFile:
tt:tt.o
    g++ -o tt tt.o&lt;/p&gt;

&lt;p&gt;tt.o:tt.cpp
    g++ -c -o tt.o tt.cpp&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;typedef int nnn 别名，用nnn代表int&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;include&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;include 只是一个占位符，是把对应的文件都替代过来，到最后的一个大文件里是没有include的；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;传参&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;string 是一个类：一般使用引用，减少资源利用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const string &amp;amp;cValueStr 这个对同一块内存空间进行了const修饰，所以这块内存空间是不会变化的

string &amp;amp;cValueStr  既是传入的一般还要有相应的返回，引用和原来变量是公用的同一块内存，当cValueStr  变化了，原来的变量也就变化了

string cValueStr  直接把变量赋给了cValueStr  ，开辟了两块空间内存，如果变量较大改用引用就不浪费资源了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;long是基本类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一般不要使用引用。但是需要改变值就要引用

对于返回参数来说，必须要引用，不然是值传递，不能起到传递的作用，要用long &amp;amp;n  就是想第二种说的string &amp;amp;cValueStr  既是传入的一般还要有相应的返回，改变的是变量的指针，即指向的地址



#include 
using namespace std;
void swap(int &amp;amp;a,int &amp;amp;b)   //引用传递
{
int temp;
temp =a;
a = b;
b = temp;
}
void swap(int *a,int *b)  //地址传递      指针变量存放地址---指针
{
int temp;
temp = *a;
*a = *b;
*b =temp;
}
void swap1(int p,int q) //值传递 
{
int temp = p;
p = q;
q = temp;
}
int main()
{
int x =20;
int y =24;
int m =10;
int n =11;
swap(&amp;amp;x,&amp;amp;y);   /*地址传递*/
swap(m,n);     /*引用传递*/
int i =20;
int j =24;
swap1(i,j);    /*只改变栈中的值，主程序中的值并未改变*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家发现没有，值传递和引用传递函数内部几乎都是一样的，引用传递相对值传递和地址传递的好处在于在不需要另外开辟一块内存空间，而地址传递和值传递都需要另外开辟空间，从效率上来讲，引用传递的效率比另外两个都要高，对于值传递，它只改变栈内的值，主程序中的值其实并未改变，大家使用的的时候要多加小心。&lt;/p&gt;

&lt;p&gt;&amp;amp;a 取地址&lt;/p&gt;

&lt;p&gt;*a 取内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i = 2,*p=&amp;amp;i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这中定义的方式很经典的概括了*和&amp;amp;，这边是定义指针p为int*，并且初始化为i的地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *p  ======char p[]--------------------这个就是动态数组，需要在堆上开辟内存
char p[10]--------------这个是固定大小的数组，也不等价于*p
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;运算符重载：实际上就相当于一个运算符就是一个函数，根据参数来识别，未重载之前是基本符号，相当于一个汇编指令&lt;/p&gt;

&lt;p&gt;重载就是为了重复使用相同函数名的函数，符号也一样。是类和运算结合的产物。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;模版&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数模板：&amp;mdash;-第一个参数推演出类型template &lt;class T&gt;  函数类型  函数名{}&lt;/p&gt;

&lt;p&gt;类模板：&amp;mdash;&amp;ndash;需要对象声明类型&amp;mdash;temolate &lt;class T&gt; class A {}；   A&lt;int&gt; a;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;演化成什么类型就是什么类型，后面直接替代就好，都是在全局声明。&lt;/p&gt;

&lt;p&gt;模板类是不能单独写成cpp文件的，那样编译器无法识别模板是什么类型，就便不过去，如果不是模板类则可以的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;c_str()函数是指转为c风格的字符串c-string，在编程中减少for循环的实用可以提高性能&lt;/p&gt;

&lt;p&gt;m_nCityId = atol(s_cityId.c_str());
c_str()是c_string就是转化为C语言的string类型也就是char *，string是在c++中被封装成类的。&lt;/p&gt;

&lt;p&gt;m_NowDate.getSysDate();
LOG_DEBUG(g_logger, &amp;ldquo;m_NowDate:&amp;rdquo; &amp;lt;&amp;lt; m_NowDate.str());
.str（）是指把对象m_NowDate中的成员变量显示出来string&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类对象实例化成员和容器中的成员：&lt;/p&gt;

&lt;p&gt;CNGReconBankCtrlDT dt;
dt.m_nCITY_ID = v_RecondCfgList[i].m_nCITY_ID;
这个是成员变量，可以直接赋值&lt;/p&gt;

&lt;p&gt;vector&lt;CNGReconBankCtrlDT&gt; dtlist;
dtlist[0].m_nCITY_ID 这个可以当常量使用，但是不可以赋值改变&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;纯虚函数 virtual void 函数名（） = 0;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;含纯虚函数 的是抽象类，抽象类只有用指针或者引用，不允许有对象&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;标准库抛出的异常，都可以用exception类，里面有一个what（）函数，可以显示异常信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一般传入参数是数组字符的没有说明元素个数的，都会以null结尾的&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、返回指针函数，正常返回一个非空指针，出错返回NULL；&lt;/p&gt;

&lt;p&gt;2、返回整数函数，正常返回非负整数，一般是0，出错返回一个负数，一般为-1&lt;/p&gt;

&lt;p&gt;3、xxx_t   整数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;时间系统：
内核&amp;mdash;&amp;mdash;-time（NULL）&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;time_t t&amp;mdash;&amp;mdash;&amp;ndash;localtime（&amp;amp;t）&amp;mdash;&amp;ndash;&amp;gt;tm *P&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;strftime（地址。。。）&amp;mdash;&amp;mdash;-char buf[]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exec系列函数，用新函数覆盖子进程函数&amp;mdash;&amp;mdash;&amp;mdash;-execvp（进程名，argv）execlp（进程名，数组）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;精灵进程（守护进程，后台进程）：daemon   1、fork父进程结束  2、函数setsid（）3、函数umask（）4、close（fd）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件描述符&lt;/p&gt;

&lt;p&gt;0  标准输入stdin
1  标准输出stdout
2  标准出错输出stderr
这些都是文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;signal&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;信号捕捉函数singal，当产生SIGTERM信号时触发函数cGiSigHandler&lt;/p&gt;

&lt;p&gt;信号捕获：函数signal（）    信号传递kill -信号名  pid&lt;/p&gt;

&lt;p&gt;signal()函数理解&lt;/p&gt;

&lt;p&gt;在&lt;signal.h&gt; 这个头文件中。&lt;/p&gt;

&lt;p&gt;signal（参数1，参数2）；&lt;/p&gt;

&lt;p&gt;参数1：我们要进行处理的信号。系统的信号我们可以再终端键入 kill -l查看(共64个)。其实这些信号时系统定义的宏。&lt;/p&gt;

&lt;p&gt;参数2：我们处理的方式（是系统默认还是忽略还是捕获）。&lt;/p&gt;

&lt;p&gt;一般有3中方式进行操作。&lt;/p&gt;

&lt;p&gt;(1)eg: signal(SIGINT ,SIG_ING );&lt;/p&gt;

&lt;p&gt;SIG_ING 代表忽略SIGINT信号，SIGINT信号代表由InterruptKey产生，通常是CTRL +C 或者是DELETE 。发送给所有ForeGround Group的进程。&lt;/p&gt;

&lt;p&gt;(2)eg: signal(SIGINT ,SIG_DFL );&lt;/p&gt;

&lt;p&gt;SIG_DFL代表执行系统默认操作，其实对于大多数信号的系统默认动作时终止该进程。这与不写此处理函数是一样的。&lt;/p&gt;

&lt;p&gt;(3)void ( &lt;em&gt;signal( int sig, void (&lt;/em&gt; handler)( int )))( int );&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int (*p)();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个函数指针, p所指向的函数是一个不带任何参数, 并且返回值为int的一个函数.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int (*fun())();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个式子与上面式子的区别在于用fun()代替了p,而fun()是一个函数,所以说就可以看成是fun()这个函数执行之后,它的返回值是一个函数指针,这个函数指针(其实就是上面的p)所指向的函数是一个不带任何参数,并且返回值为int的一个函数.&lt;/p&gt;

&lt;p&gt;void (*signal(int signo, void (*handler)(int)))(int);就可以看成是signal()函数(它自己是带两个参数,一个为整型,一个为函数指针的函数),而这个signal()函数的返回值也为一个函数指针,这个函数指针指向一个带一个整型参数,并且返回值为void的一个函数.&lt;/p&gt;

&lt;p&gt;在写信号处理函数时对于信号处理的函数也是void sig_fun(int signo);这种类型,恰好与上面signal()函数所返回的函数指针所指向的函数是一样的.void ( *signal() )( int );&lt;/p&gt;

&lt;p&gt;signal是一个函数, 它返回一个函数指针, 后者所指向的函数接受一个整型参数 且没有返回值, 仔细看, 是不是siganal( int signo, void (*handler)(int) )的第2个参数了,对了,其实他所返回的就是 signal的第2个信号处理函数,指向信号处理函数,就可以执行函数了( signal内部时, signal把信号做为参数传递给handler信号处理函数,接着 signal函数返回指针, 并且又指向信号处理函数, 就开始执行它)&lt;/p&gt;

&lt;p&gt;那么，signal函数的参数又是如何呢？signal函数接受两个参数：一个整型的信号编号，以及一个指向用户定义的信号处理函数的指针。我们此前已经定义了指向用户定义的信号处理函数的指针sfp：&lt;/p&gt;

&lt;p&gt;void (*sfp)(int);&lt;/p&gt;

&lt;p&gt;sfp 的类型可以通过将上面的声明中的sfp去掉而得到，即void (*)(int)。此外，signal函数的返回值是一个指向调用前的用户定义信号处理函数的指针，这个指针的类型与sfp指针类型一致。因此，我们可以如下声明signal函数：&lt;/p&gt;

&lt;p&gt;void (&lt;em&gt;signal(int, void(&lt;/em&gt;)(int)))(int);&lt;/p&gt;

&lt;p&gt;同样地，使用typedef可以简化上面的函数声明：&lt;/p&gt;

&lt;p&gt;typedef void (*HANDLER)(int);
HANDLER signal(int, HANDLER);&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;include&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自定义下的头文件只能用双引号去include&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;26&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>linux操作命令</title>
      <link>http://kingjcy.github.io/blog/2015/02/23/linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 23 Feb 2015 11:20:38 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2015/02/23/linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;p&gt;一些linux常用的的操作命令，记录备忘也便于使用时查看。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;tar&#34;&gt;tar&lt;/h3&gt;

&lt;p&gt;-c: 建立压缩档案
-x：解压
-t：查看内容
-r：向压缩归档文件末尾追加文件
-u：更新原压缩包中的文件&lt;/p&gt;

&lt;p&gt;这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。&lt;/p&gt;

&lt;p&gt;-z：有gzip属性的
-j：有bz2属性的
-Z：有compress属性的
-v：显示所有过程
-O：将文件解开到标准输出&lt;/p&gt;

&lt;p&gt;下面的参数-f是必须的&lt;/p&gt;

&lt;p&gt;-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。&lt;/p&gt;

&lt;p&gt;tar -cf all.tar *.jpg
这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。&lt;/p&gt;

&lt;p&gt;tar -rf all.tar *.gif
这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。&lt;/p&gt;

&lt;p&gt;tar -uf all.tar logo.gif
这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。&lt;/p&gt;

&lt;p&gt;tar -tf all.tar
这条命令是列出all.tar包中所有文件，-t是列出文件的意思&lt;/p&gt;

&lt;p&gt;tar -xf all.tar
这条命令是解出all.tar包中所有文件，-t是解开的意思&lt;/p&gt;

&lt;p&gt;压缩&lt;/p&gt;

&lt;p&gt;tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg&lt;/p&gt;

&lt;p&gt;tar -czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz&lt;/p&gt;

&lt;p&gt;tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2&lt;/p&gt;

&lt;p&gt;tar -cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z&lt;/p&gt;

&lt;p&gt;rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux&lt;/p&gt;

&lt;p&gt;zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux&lt;/p&gt;

&lt;p&gt;解压&lt;/p&gt;

&lt;p&gt;tar -xvf file.tar //解压 tar包&lt;/p&gt;

&lt;p&gt;tar -xzvf file.tar.gz //解压tar.gz&lt;/p&gt;

&lt;p&gt;tar -xjvf file.tar.bz2   //解压 tar.bz2&lt;/p&gt;

&lt;p&gt;tar -xZvf file.tar.Z   //解压tar.Z&lt;/p&gt;

&lt;p&gt;unrar e file.rar //解压rar&lt;/p&gt;

&lt;p&gt;unzip file.zip //解压zip&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;1、*.tar 用 tar -xvf 解压&lt;/p&gt;

&lt;p&gt;2、*.gz 用 gzip -d或者gunzip 解压&lt;/p&gt;

&lt;p&gt;3、&lt;em&gt;.tar.gz和&lt;/em&gt;.tgz 用 tar -xzf 解压&lt;/p&gt;

&lt;p&gt;4、*.bz2 用 bzip2 -d或者用bunzip2 解压&lt;/p&gt;

&lt;p&gt;5、*.tar.bz2用tar -xjf 解压&lt;/p&gt;

&lt;p&gt;6、*.Z 用 uncompress 解压&lt;/p&gt;

&lt;p&gt;7、*.tar.Z 用tar -xZf 解压&lt;/p&gt;

&lt;p&gt;8、*.rar 用 unrar e解压&lt;/p&gt;

&lt;p&gt;9、*.zip 用 unzip 解压&lt;/p&gt;

&lt;h3 id=&#34;grep&#34;&gt;grep&lt;/h3&gt;

&lt;p&gt;Grep 命令&lt;/p&gt;

&lt;p&gt;1、 参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-I ：忽略大小写 
-c ：打印匹配的行数 
-l ：从多个文件中查找包含匹配项 
-v ：查找不包含匹配项的行 
-n：打印包含匹配项的行和行标,cat也有这个作用 
-E:相当于egrep，深度匹配，多重匹配，比如egrep &amp;quot;a|b&amp;quot; filenamea|b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、RE（正则表达式）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\ 忽略正则表达式中特殊字符的原有含义 
^ 匹配正则表达式的开始行 
$ 匹配正则表达式的结束行 
\&amp;lt; 从匹配正则表达式的行开始 
\&amp;gt; 到匹配正则表达式的行结束 
[ ] 单个字符；如[A] 即A符合要求 
[ - ] 范围 ；如[A-Z]即A，B，C一直到Z都符合要求 
. 所有的单个字符 
* 所有字符，长度可以为0 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;usermod&#34;&gt;usermod&lt;/h3&gt;

&lt;p&gt;usermod -d /disk01/svn/jiangchunyin jiangchunyin  改变家目录&lt;/p&gt;

&lt;h3 id=&#34;du&#34;&gt;du&lt;/h3&gt;

&lt;p&gt;du -ks * |sort -n    按大小排序&lt;/p&gt;

&lt;h3 id=&#34;echo&#34;&gt;echo&lt;/h3&gt;

&lt;p&gt;echo $?     打印终止状态（进程）&lt;/p&gt;

&lt;h3 id=&#34;find-grep&#34;&gt;find&amp;amp;grep&lt;/h3&gt;

&lt;p&gt;查找当前目录下所有cpp文件中含有getUserProduct的地方&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find ./ -name &amp;quot;*.cpp&amp;quot; -print | xargs grep getUserProduct    -----xargs也是一种承接，一般不用于cp，mv，和-exec差不多
grep -n &amp;quot;sCrmOrgId&amp;quot; $(find . -name &amp;quot;*.cpp&amp;quot;)

find . -maxdepth 1 -type f -name &amp;quot;&amp;quot; -mtime -1 -exec rm -rf {} \      ----maxdepth 1 目录深度，这个就是一级，-type f表示只是找文件，-mtime -1当前一天的文件，表示多长时间的文件，-表示多少天以内的，+表示多少天以前的，比如三十天以前的-mtime +30 。-exec rm -rf {} \ 执行命令，{}表示前面的结果，最后又一个\是格式
find . -maxdepth 1 -type f -name &amp;quot;&amp;quot; -mtime +30 -exec cp  {} /tmp \      

find . -size +50M 大于五十M的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sudo&#34;&gt;sudo&lt;/h3&gt;

&lt;p&gt;编辑/etc/sudoers文件。也就是输入命令&amp;rdquo;vim /etc/sudoers&amp;rdquo;,进入编辑模式，找到这一 行：&amp;rdquo;root ALL=(ALL) ALL&amp;rdquo;在起下面添加&amp;rdquo;xxx ALL=(ALL) ALL&amp;rdquo;(这里的xxx是你的用户名)，然后保存退出。可以让普通 用户执行以下只有root用户执行的操作。避免总是用su - 用户切换&lt;/p&gt;

&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;linux根目录下各文件夹的作用

 /bin 二进制可执行命令   
 /dev 设备特殊文件   
 /etc 系统管理和配置文件   
 /etc/rc.d 启动的配置文件和脚本   
 /home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示   
 /lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件   
 /sbin 系统管理命令，这里存放的是系统管理员使用的管理程序   
 /tmp 公用的临时文件存储点   
 /root 系统管理员的主目录（呵呵，特权阶级）   
 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统。   
 /lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里   
 /proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。   
 /var 某些大文件的溢出区，比方说各种服务的日志文件   
 /usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：    
 /usr/x11r6 存放x window的目录   
 /usr/bin 众多的应用程序   
 /usr/sbin 超级用户的一些管理程序   
 /usr/doc linux文档   
 /usr/include linux下开发和编译应用程序所需要的头文件   
 /usr/lib 常用的动态链接库和软件包的配置文件   
 /usr/man 帮助文档   
 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里   
 /usr/local/bin 本地增加的命令   
 /usr/local/lib 本地增加的库根文件系统
 : /opt 主机额外安装软件所摆放的目录。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scp&#34;&gt;scp&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;scp （-r（目录））文件 用户名@主机名：目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;whereis-which&#34;&gt;whereis&amp;amp;which&lt;/h3&gt;

&lt;p&gt;whereis  软件名   &amp;ndash;&amp;gt;查看软件安装路径&lt;/p&gt;

&lt;p&gt;which  软件名     &amp;ndash;&amp;gt;软件软件的运行路径&lt;/p&gt;

&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;

&lt;p&gt;netstat -an | grep XXXX&lt;/p&gt;

&lt;p&gt;netstat -tln 查看端口使用情况，而netstat -tln | grep 8083 则是只查看端口8083的使用情况&lt;/p&gt;

&lt;h3 id=&#34;lsof&#34;&gt;lsof&lt;/h3&gt;

&lt;p&gt;lsof -i :8083  查看端口属于哪个程序？端口被哪个进程占用&lt;/p&gt;

&lt;h3 id=&#34;telnet-ping&#34;&gt;telnet&amp;amp;ping&lt;/h3&gt;

&lt;p&gt;ping  网络层协议，是发送一个包给目标主机，目标主机接收到包再返回一个响应的包，测试网络是否通&lt;/p&gt;

&lt;p&gt;telnet  ，ftp都是应用层的类似tcp的协议，但是都是明文密码登陆远程主机，而ssh也是，但是它比较安全，是密文发送的。&lt;/p&gt;

&lt;h3 id=&#34;useradd-passwd&#34;&gt;useradd&amp;amp;passwd&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;useradd –d /usr/sam -m sam&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。&lt;/p&gt;

&lt;p&gt;假设当前用户是sam，则下面的命令修改该用户自己的口令：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;passwd&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Old password:******&lt;/p&gt;

&lt;p&gt;New password:*******&lt;/p&gt;

&lt;p&gt;Re-enter new password:*******&lt;/p&gt;

&lt;p&gt;如果是超级用户，可以用下列形式指定任何用户的口令：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;passwd sam&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;New password:*******&lt;/p&gt;

&lt;p&gt;Re-enter new password:*******&lt;/p&gt;

&lt;h3 id=&#34;cat&#34;&gt;cat&lt;/h3&gt;

&lt;p&gt;不看注释
cat filename | grep -v &amp;ldquo;^#&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;ifconfig&#34;&gt;ifconfig&lt;/h3&gt;

&lt;p&gt;显示本机的ip，这只是一个工具，可以去看对应的网卡配置文件/etc/sysconfig/network-scripts/&lt;/p&gt;

&lt;h3 id=&#34;命令行和界面模式&#34;&gt;命令行和界面模式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/inittab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于centos6和7都是这个文件，但是表现方式不一样，重点都是run level是3则是命令行模式运行。5则是界面模式运行，前提是你安装了图型界面。&lt;/p&gt;

&lt;h3 id=&#34;网络设置&#34;&gt;网络设置&lt;/h3&gt;

&lt;p&gt;centos 7在/etc/sysconfig/metwork-script/下面的的ifcfg-不是lo的文件，设置其静态ip&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BOOTPROTO=&amp;quot;static&amp;quot;
IPADDR=192.168.56.102 #静态IP  
GATEWAY=192.168.0.1 #默认网关  
NETMASK=255.255.255.0 #子网掩码  
DNS1=114.114.114.114 #DNS 配置  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重启network&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl restart network
ifconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以看到成功设置ip了，然后最好把开始启动设置ONBOOT=&amp;ldquo;yes&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;tr&#34;&gt;tr&lt;/h3&gt;

&lt;p&gt;tr命令可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-c或——complerment：取代所有不属于第一字符集的字符；
-d或——delete：删除所有属于第一字符集的字符；
-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；
-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;p&gt;大小写转化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;HELLO WORLD&amp;quot; | tr &#39;A-Z&#39; &#39;a-z&#39;
hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除数字，是可以用范围的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;hello 123 world 456&amp;quot; | tr -d &#39;0-9&#39; 
hello world 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将制表符转换为空格&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat text | tr &#39;\t&#39; &#39; &#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cat-1&#34;&gt;cat&lt;/h3&gt;

&lt;p&gt;cat -A filename      &amp;mdash;-show all,用于查看是否有乱码&lt;/p&gt;

&lt;h3 id=&#34;sort&#34;&gt;sort&lt;/h3&gt;

&lt;p&gt;cat finenema | sort &amp;mdash;-排序&lt;/p&gt;

&lt;h3 id=&#34;find&#34;&gt;find&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-type：根据不同的文件类型筛选
f普通文件
d目录文件
l符号链接文件
b块设备 文件
c字符设备文件
p管道文件
s套接字文件



处理动作：
　　　　　　　　　　-print：输出至标准输出；默认的动作；
　　　　　　　　　　-ls：类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息；
　　　　　　　　　　-delete：删除查找到的文件；
　　　　　　　　　　-fls /PATH/TO/SOMEFILE：把查找到的所有文件的长格式信息保存至指定文件中；
　　　　　　　　　　-ok COMMAND {} \; ：对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；
　　　　　　　　　　-exec COMMAND {} \; ：对查找到的每个文件执行由COMMAND表示的命令；
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cut&#34;&gt;cut&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。
如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。

主要参数
-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c ：以字符为单位进行分割。
-d ：自定义分隔符，默认为制表符。
-f  ：与-d一起使用，指定显示哪个区域。
-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&amp;lt;br /&amp;gt;范围之内，该字符将被写出；否则，该字符将被排除。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子吧，当你执行ps命令时，会输出类似如下的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ who
rocrocket :0           2009-01-08 11:07
rocrocket pts/0        2009-01-08 11:23 (:0.0)
rocrocket pts/1        2009-01-08 14:15 (:0.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想提取每一行的第3个字节，就这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ who|cut -b 3
c
c
c
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ssh&#34;&gt;ssh&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;这边主要讲一下免密码登录，好多次都需要查找一番，决定记下来

A机器生成ssh的私钥和公钥

    ssh-keygen -t rsa

就会生成对应的私钥和公钥文件。将公钥文件id_rsa.pub上传到机器B上，注意这边最好不要直接复制容易乱码导致ssh免密码登录失败

    scp id_rsa.pub user@ip:pwd

然后就是将公钥放到B机器上的这个文件中authorized_keys

    cat id_rsa.pub &amp;gt;&amp;gt; authorized_keys
    chmod 600 authorized_keys

这样就可以了，同样使用于mac系统。

这边设计一个非root用户设置免密码登录的权限问题，权限太大也不行，家目录为755，.ssh的权限700， authorized_keys的权限600， 就够了，发现无法免密码登录就去查看日志/var/log/secure就知道了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dirname和basename&#34;&gt;dirname和basename&lt;/h3&gt;

&lt;p&gt;dirname命令可以取给定路径的目录部分（strip non-directory suffix from file name）。这个命令很少直接在shell命令行中使用，我一般把它用在shell脚本中，用于取得脚本文件所在目录，然后将当前目录切换过去。&lt;/p&gt;

&lt;p&gt;basename命令则用于获取文件名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@qzt196 ~]# dirname /usr/bin/sort 
/usr/bin
[root@qzt196 ~]# dirname stdio.h 
.

[root@qzt196 ~]# dirname /usr/bin 
/usr
[root@qzt196 ~]# dirname /usr/bin/ 
/usr
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;uid&#34;&gt;UID&lt;/h3&gt;

&lt;p&gt;shell 的 uid/gid 則是根据 /etc/passwd 的第 3 与第 4 两位决定.&lt;/p&gt;

&lt;p&gt;root 0 0&lt;/p&gt;

&lt;h3 id=&#34;sh&#34;&gt;sh&lt;/h3&gt;

&lt;p&gt;sh -n filename.sh    检查脚本是否正确&lt;/p&gt;

&lt;p&gt;sh -x filename.sh    查看脚本执行的步骤&lt;/p&gt;

&lt;h3 id=&#34;ctontab&#34;&gt;ctontab&lt;/h3&gt;

&lt;p&gt;crontab -e    定时一个任务，在这个任务中编辑对应的执行时间&lt;/p&gt;

&lt;p&gt;12 12 12 * * /usr/bin/bash filename.sh &amp;gt;&amp;gt; /tmp/mysql.log 2&amp;gt;&amp;amp;1&lt;/p&gt;

&lt;p&gt;2&amp;gt;$1  标准输出和标准输入都写到日志中，这边将脚本执行的日志进行重定向到/tmp/mysql.log，同时将标准输出和标准输入都写到这个文件中&lt;/p&gt;

&lt;h3 id=&#34;与&#34;&gt;&amp;amp;&amp;amp;与；&lt;/h3&gt;

&lt;p&gt;命令联合的时候&lt;/p&gt;

&lt;p&gt;&amp;amp;&amp;amp; 前面语句执行成功才能继续执行后面的，否则退出&lt;/p&gt;

&lt;p&gt;；前面的语句成功与否后面都会继续执行&lt;/p&gt;

&lt;h3 id=&#34;sort-1&#34;&gt;sort&lt;/h3&gt;

&lt;p&gt;sort -nr    重大到小排序&lt;/p&gt;

&lt;h3 id=&#34;date&#34;&gt;date&lt;/h3&gt;

&lt;p&gt;date -s 20170413  可以直接这样改变系统时间。&lt;/p&gt;

&lt;h3 id=&#34;hostname&#34;&gt;hostname&lt;/h3&gt;

&lt;p&gt;查看主机名，也可以直接改主机名，hostname name ,等同于修改/proc/sys/kernel/hostname文件。&lt;/p&gt;

&lt;h3 id=&#34;ipcs&#34;&gt;ipcs&lt;/h3&gt;

&lt;p&gt;ipcs用法&lt;/p&gt;

&lt;p&gt;ipcs -a  是默认的输出信息 打印出当前系统中所有的进程间通信方式的信息&lt;/p&gt;

&lt;p&gt;ipcs -m  打印出使用共享内存进行进程间通信的信息&lt;/p&gt;

&lt;p&gt;ipcs -q   打印出使用消息队列进行进程间通信的信息&lt;/p&gt;

&lt;p&gt;ipcs -s  打印出使用信号进行进程间通信的信息&lt;/p&gt;

&lt;p&gt;ipcs -t   输出信息的详细变化时间&lt;/p&gt;

&lt;p&gt;ipcs -p  输出ipc方式的进程ID&lt;/p&gt;

&lt;p&gt;ipcs -c  输出ipc方式的创建者/拥有者&lt;/p&gt;

&lt;p&gt;ipcrm用法
ipcrm -M shmkey  移除用shmkey创建的共享内存段&lt;/p&gt;

&lt;p&gt;ipcrm -m shmid    移除用shmid标识的共享内存段&lt;/p&gt;

&lt;p&gt;ipcrm -Q msgkey  移除用msqkey创建的消息队列&lt;/p&gt;

&lt;p&gt;ipcrm -q msqid  移除用msqid标识的消息队列&lt;/p&gt;

&lt;p&gt;ipcrm -S semkey  移除用semkey创建的信号&lt;/p&gt;

&lt;p&gt;ipcrm -s semid  移除用semid标识的信号&lt;/p&gt;

&lt;h3 id=&#34;netstat-1&#34;&gt;netstat&lt;/h3&gt;

&lt;p&gt;netstat 不加参数持续输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。加速输出,正常都加上
-l 仅列出有在 Listen (监听) 的服務状态

-p 显示建立相关链接的程序名
-r 显示路由信息，路由表
-e 显示扩展信息，例如uid等
-s 按各个协议进行统计
-c 每隔一个固定时间，执行该netstat命令。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看某个进程暂用的连接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;netstat -nap | grep pid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看连接某服务端口最多的的IP地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; netstat -nat | grep &amp;quot;192.168.1.15:22&amp;quot; |awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -20
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;top&#34;&gt;top&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;top [-dpqcCSsi] [n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。&lt;/p&gt;

&lt;p&gt;p 通过指定监控进程ID来仅仅监控某个进程的状态。&lt;/p&gt;

&lt;p&gt;q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。&lt;/p&gt;

&lt;p&gt;S 指定累计模式&lt;/p&gt;

&lt;p&gt;s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。&lt;/p&gt;

&lt;p&gt;i 使top不显示任何闲置或者僵死进程。&lt;/p&gt;

&lt;p&gt;c 显示整个命令行而不只是显示命令名&lt;/p&gt;

&lt;p&gt;这些参数也可以在top界面操作。&lt;/p&gt;

&lt;p&gt;常用操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;top   //每隔5秒显式所有进程的资源占用情况
top -d 2  //每隔2秒显式所有进程的资源占用情况
top -c  //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)
top -p 12345 -p 6789//每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况
top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sysctl&#34;&gt;sysctl&lt;/h3&gt;

&lt;p&gt;linux内核通过/proc虚拟文件系统向用户导出内核信息，用户也可以通过/proc文件系统或通过sysctl命令动态配置内核。比如，如果我们想启动NAT，除了加载模块、配置防火墙外，还需要启动内核转发功能。我们有三种方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接写/proc文件系统&lt;/p&gt;

&lt;p&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;利用sysctl命令&lt;/p&gt;

&lt;p&gt;sysctl -w net.ipv4.ip_forward=1&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sysctl -a可以查看内核所有导出的变量&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编辑/etc/sysctl.conf&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;添加如下一行，这样系统每次启动后，该变量的值就是1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.ipv4.ip_forward = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sysctl参数&lt;/p&gt;

&lt;p&gt;-w   临时改变某个指定参数的值，如         sysctl -w net.ipv4.ip_forward=1&lt;/p&gt;

&lt;p&gt;-a   显示所有的系统参数&lt;/p&gt;

&lt;p&gt;-p   从指定的文件加载系统参数&lt;/p&gt;

&lt;p&gt;关于/etc/sysctl.conf的详解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;解释一下sysctl.conf文件中参数的意义：

file-max：这个参数表示进程可以同时打开的最大句柄数，这个参数直接限制最大并发连接数。
tcp_tw_reuse：这个参数设置为1,表示允许将TIME-WAIT状态的socket重新用于新的TCP链接。这个对服务器来说很有意义，因为服务器上总会有大量TIME-WAIT状态的连接。
tcp_keepalive_time：这个参数表示当keepalive启用时，TCP发送keepalive消息的频度。默认是7200 seconds，意思是如果某个TCP连接在idle 2小时后，内核才发起probe。若将其设置得小一点，可以更快地清理无效的连接。
tcp_fin_timeout：这个参数表示当服务器主动关闭连接时，socket保持在FIN-WAIT-2状态的最大时间。
tcp_max_tw_buckets：这个参数表示操作系统允许TIME_WAIT套接字数量的最大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认是i180000,过多TIME_WAIT套接字会使Web服务器变慢。
tcp_max_syn_backlog：这个参数表示TCP三次握手建立阶段接受WYN请求队列的最大长度，默认1024,将其设置大一些可以使出现Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的连接请求。
ip_local_port_range：这个参数定义了在UDP和TCP连接中本地端口的取值范围。
net.ipv4.tcp_rmem：这个参数定义了TCP接受缓存（用于TCP接收滑动窗口）的最小值，默认值，最大值。
net.ipv4.tcp_wmem：这个参数定义了TCP发送缓存（用于TCP发送滑动窗口）的最小值，默认值，最大值。
netdev_max_backlog：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。这个参数表示该队列的最大值。
rmem_default：这个参数表示内核套接字接收缓存区默认的大小。
wmem_default：这个参数表示内核套接字发送缓存区默认的大小。
rmem_max：这个参数表示内核套接字接收缓存区默认的最大大小。
wmem_max：这个参数表示内核套接字发送缓存区默认的最大大小。


1、减少处于FIN-WAIT-2连接状态的时间，使系统可以处理更多的连接。
net.ipv4.tcp_fin_timeout = 2
如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。
对端可以出错并永远不关闭连接，甚至意外当机，缺省值是60秒。
2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN-WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。

2、以下两参数可解决生产场景中大量连接的Web（cache）服务器中TIME_WAIT过多问题。
net.ipv4.tcp_tw_reuse = 1
表示开启重用。允许将TIME-WAIT sockets重新用于新的 TCP 连接，默认为 0 表示关闭。

3、打开TIME-WAIT套接字重用及回收功能。
net.ipv4.tcp_tw_recycle = 1
表示开启TCP连接中TIME-WAIT sockets的快速收回功能，默认为 0 ，表示关闭。

4、当keepalive起用的时候，TCP发送keepalive消息的频度，缺省是2小时，改为20分钟。
net.ipv4.tcp_keepalive_time = 600

5、允许系统打开的端口范围
net.ipv4.ip_local_port_range = 4000    65000
表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为4000到65000。

6、提高系统支持的最大SYN半连接数(默认1024)
net.ipv4.tcp_max_syn_backlog = 16384
表示SYN队列的长度，默认为1024，加大队列长度为16384，可以容纳最多等待连接的网络连接数。
[root@centos5 ~]# cat /proc/sys/net/ipv4/tcp_max_syn_backlog 
1024

7、系统同时保持TIME_WAIT套接字的最大数量
net.ipv4.tcp_max_tw_buckets = 360000
表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为 5000。
对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。

8、路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。
net.ipv4.route.gc_timeout = 100

9、在内核放弃建立连接之前发送SYN包的数量。
net.ipv4.tcp_syn_retries = 1

10、减少系统SYN连接重试次数（默认是5）
net.ipv4.tcp_synack_retries = 1
为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。
也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。

11、设置系统对最大跟踪的TCP连接数的限制(CentOS 5.6无此参数)
net.ipv4.ip_conntrack_max = 25000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lsof-1&#34;&gt;lsof&lt;/h2&gt;

&lt;p&gt;lsof（list open files）是一个列出当前系统打开文件的工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COMMAND：进程的名称
PID：进程标识符
USER：进程所有者
FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等
TYPE：文件类型，如DIR、REG等
DEVICE：指定磁盘的名称
SIZE：文件的大小
NODE：索引节点（文件在磁盘上的标识）
NAME：打开文件的确切名称
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lsof  filename 显示打开指定文件的所有进程
lsof -a 表示两个参数都必须满足时才显示结果
lsof -c string   显示COMMAND列中包含指定字符的进程所有打开的文件
lsof -u username  显示所属user进程打开的文件
lsof -g gid 显示归属gid的进程情况
lsof +d /DIR/ 显示目录下被进程打开的文件
lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长
lsof -d FD 显示指定文件描述符的进程
lsof -n 不将IP转换为hostname，缺省是不加上-n参数
lsof -i 用以显示符合条件的进程情况
lsof -i[46] [protocol][@hostname|hostaddr][:service|port]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如查看22端口的运行情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lsof -i :22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用于恢复已经删除的数据，文件被删除，但是正在对其读写的进程还是会继续对其进行操作，保存在/proc下面对应的进程号下面的文件描述符中，我们可以通过这个来恢复删除的文件&lt;/p&gt;

&lt;p&gt;先看有木有进程占用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lsof | grep 文件名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将这个文件追加到原来的文件中去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/进程id/fd/fid &amp;gt;&amp;gt; 原来文件名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以用于查看指定进程的连接情况，先获取进程id&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps -ef|grep frps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后根据id来查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lsof -p 4721 -nP | grep TCP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lsof 的 -nP 参数用于将 ip 地址和端口号显示为正常的数值类型，否则可能会用别名表示。就可以看出来多少连接多少监听&lt;/p&gt;

&lt;h2 id=&#34;iptables&#34;&gt;iptables&lt;/h2&gt;

&lt;p&gt;查看当前规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -L -n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加指定端口到防火墙&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -I INPUT -p 协议 --dport 端口号 -j ACCEPT
iptables -I INPUT -p udp --dport 161 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tail和head&#34;&gt;tail和head&lt;/h2&gt;

&lt;p&gt;显示前几行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;head -n number  filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示后几行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tail -n number filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tail的-f参数可以不断刷新文件&lt;/p&gt;

&lt;h2 id=&#34;netstat和ifconfig&#34;&gt;netstat和ifconfig&lt;/h2&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install net-tools 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dig&#34;&gt;dig&lt;/h2&gt;

&lt;p&gt;dns解析的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dig google.com
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>