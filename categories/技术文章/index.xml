<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingjcy Blog</title>
    <link>http://kingjcy.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/index.xml</link>
    <description>Recent content on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <atom:link href="http://kingjcy.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>restful架构</title>
      <link>http://kingjcy.github.io/blog/2017/06/23/restful%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Fri, 23 Jun 2017 17:30:47 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/23/restful%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;p&gt;REST &amp;ndash; REpresentational State Transfer 直接翻译：表现层状态转移。&lt;/p&gt;

&lt;p&gt;经典定义：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：GET    用来获取资源，POST  用来新建资源（也可以用于更新资源），PUT    用来更新资源，DELETE  用来删除资源。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。当然还可以压缩HTTP传输时的数据（on-wire data compression）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要理解rest，需要先理解api，api就是接口，提供给外部进行互相交互的。那么现在了解rest，rest是一种架构风格，我们先来理解rest架构风格，这边需要web，web三个关键点：识别，表示，交互，对应的是URL识别资源，representation（html，xml）表示资源，通过协议（http）和资源进行交互，整合一下就是通过http协议和URL利用client／server models对资源进行CURD操作。&lt;/p&gt;

&lt;p&gt;我们提供restful类型的api有什么好处呢？因为rest有限制，可以是一个统一的规范。就具有通用性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用客户/服务器模型。客户和服务器之间通过一个统一的接口来互相通讯。&lt;/li&gt;
&lt;li&gt;层次化的系统。在一个REST系统中，客户端并不会固定地与一个服务器打交道。&lt;/li&gt;
&lt;li&gt;无状态。在一个REST系统中，服务端并不会保存有关客户的任何状态。也就是说，客户端自身负责用户状态的维持，并在每次发送请求时都需要提供足够的信息。&lt;/li&gt;
&lt;li&gt;可缓存。REST系统需要能够恰当地缓存请求，以尽量减少服务端和客户端之间的信息传输，以提高性能。&lt;/li&gt;
&lt;li&gt;统一的接口。一个REST系统需要使用一个统一的接口来完成子系统之间以及服务与用户之间的交互。这使得REST系统中的各个子系统可以独自完成演化。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>从harbor入手beego框架</title>
      <link>http://kingjcy.github.io/blog/2017/06/12/%E4%BB%8Eharbor%E5%85%A5%E6%89%8Bbeego%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 12 Jun 2017 10:34:15 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/12/%E4%BB%8Eharbor%E5%85%A5%E6%89%8Bbeego%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;p&gt;beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;beego 是基于八大独立的模块构建的，是一个高度解耦的框架。当初设计 beego 的时候就是考虑功能模块化，用户即使不使用 beego 的 HTTP 逻辑，也依旧可以使用这些独立模块&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;bee 工具的安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/beego/bee
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在命令行输入 bee，可以看到如下的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bee is a tool for managing beego framework.

Usage:

    bee command [arguments]

The commands are:

    new         create an application base on beego framework
    run         run the app which can hot compile
    pack        compress an beego project
    api         create an api application base on beego framework
    bale        packs non-Go files to Go source files
    version     show the bee &amp;amp; beego version
    generate    source code generator
    migrate     run database migrations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详解&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;new 命令是新建一个 Web 项目，我们在命令行下执行 bee new &amp;lt;项目名&amp;gt; 就可以创建一个新的项目。但是注意该命令必须在 $GOPATH/src 下执行。最后会在 $GOPATH/src 相应目录下生成如下目录结构的项目：&lt;/p&gt;

&lt;p&gt;├── conf
│   └── app.conf
├── controllers
│   ├── admin
│   └── default.go
├── main.go
├── models
│   └── models.go
├── static
│   ├── css
│   ├── ico
│   ├── img
│   └── js
└── views
    ├── admin
    └── index.tpl&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面的目录结构我们可以看出来 M（models 目录）、V（views 目录）和 C（controllers 目录）的结构， main.go 是入口文件。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;很多用户使用 beego 来开发 API 应用。所以这个 api 命令就是用来创建 API 应用的&lt;/p&gt;

&lt;p&gt;apiproject
├── conf
│   └── app.conf
├── controllers
│   └── object.go
│   └── user.go
├── docs
│   └── doc.go
├── main.go
├── models
│   └── object.go
│   └── user.go
├── routers
│   └── router.go
└── tests
    └── default_test.go&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面的目录我们可以看到和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试的。&lt;/p&gt;

&lt;p&gt;同时，该命令还支持一些自定义参数自动连接数据库创建相关 model 和 controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bee api [appname] [-tables=“”] [-driver=mysql] [-conn=root:@tcp(127.0.0.1:3306)/test]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 conn 参数为空则创建一个示例项目，否则将基于链接信息链接数据库创建项目。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;bee run 命令是运行监控 beego 的项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pack 目录用来发布应用的时候打包，会把项目打包成 zip 包，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;beego的安装&lt;/p&gt;

&lt;p&gt;go get github.com/astaxie/beego&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;项目&#34;&gt;项目&lt;/h2&gt;

&lt;p&gt;一、入口main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    _ &amp;quot;quickstart/routers&amp;quot;
    &amp;quot;github.com/astaxie/beego&amp;quot;
)

func main() {
    beego.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先beego.Run()&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;解析配置文件&lt;/li&gt;
&lt;li&gt;监听服务端口&lt;/li&gt;
&lt;li&gt;执行用户的 hookfunc，是否开启 session，是否编译模板，是否开启文档功能，是否启动管理模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;路由router&lt;/p&gt;

&lt;p&gt;引入了一个包 _ &amp;ldquo;quickstart/routers&amp;rdquo;,这个包只引入执行了里面的 init 函数&lt;/p&gt;

&lt;p&gt;路由包里面我们看到执行了路由注册 beego.Router, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 /，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑&lt;/p&gt;

&lt;p&gt;二、 路由&lt;/p&gt;

&lt;p&gt;MVC 结构执行时，beego 存在三种方式的路由:固定路由、正则路由、自动路由&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础路由&lt;/p&gt;

&lt;p&gt;beego.Get(router, beego.FilterFunc)
beego.Post(router, beego.FilterFunc)
beego.Put(router, beego.FilterFunc)
beego.Head(router, beego.FilterFunc)
beego.Options(router, beego.FilterFunc)
beego.Delete(router, beego.FilterFunc)
beego.Any(router, beego.FilterFunc)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本 GET 路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Get(&amp;quot;/&amp;quot;,func(ctx *context.Context){
     ctx.Output.Body([]byte(&amp;quot;hello world&amp;quot;))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册一个可以响应任何 HTTP 的路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Any(&amp;quot;/foo&amp;quot;,func(ctx *context.Context){
     ctx.Output.Body([]byte(&amp;quot;bar&amp;quot;))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;支持自定义的 handler 实现&lt;/p&gt;

&lt;p&gt;有些时候我们已经实现了一些 rpc 的应用,但是想要集成到 beego 中,或者其他的 httpserver 应用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s := rpc.NewServer()
s.RegisterCodec(json.NewCodec(), &amp;quot;application/json&amp;quot;)
s.RegisterService(new(HelloService), &amp;quot;&amp;quot;)
beego.Handler(&amp;quot;/rpc&amp;quot;, s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beego.Handler(router, http.Handler) 这个函数是关键,第一个参数表示路由 URI, 第二个就是你自己实现的 http.Handler, 注册之后就会把所有 rpc 作为前缀的请求分发到 http.Handler 中进行处理.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;固定路由也就是全匹配的路由&lt;/p&gt;

&lt;p&gt;beego.Router(&amp;ldquo;/&amp;rdquo;, &amp;amp;controllers.MainController{})
beego.Router(&amp;ldquo;/admin&amp;rdquo;, &amp;amp;admin.UserController{})
beego.Router(&amp;ldquo;/admin/index&amp;rdquo;, &amp;amp;admin.ArticleController{})
beego.Router(&amp;ldquo;/admin/addpkg&amp;rdquo;, &amp;amp;admin.AddController{})&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如上所示的路由就是我们最常用的路由方式，一个固定的路由，一个控制器，然后根据用户请求方法不同请求控制器中对应的方法，典型的 RESTful 方式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;正则路由&lt;/p&gt;

&lt;p&gt;beego.Router(“/api/?:id”, &amp;amp;controllers.RController{})&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;匹配 /api/123   :id = 123   可以匹配 /api/ 这个URL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Router(“/api/:id”, &amp;amp;controllers.RController{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配 /api/123   :id = 123   不可以匹配 /api/ 这个URL&lt;/p&gt;

&lt;p&gt;这样可以通过this.Ctx.Input.Param(&amp;rdquo;:id&amp;rdquo;)在controller获取url中的值。&lt;/p&gt;

&lt;p&gt;HTTP Method&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;默认方法&lt;/p&gt;

&lt;p&gt;*: 包含以下所有的函数
get: GET 请求
post: POST 请求
put: PUT 请求
delete: DELETE 请求
patch: PATCH 请求
options: OPTIONS 请求
head: HEAD 请求&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自定义方法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;请求的 method 和函数名一致，例如 GET 请求执行 Get 函数，POST 请求执行 Post 函数），如果用户期望自定义函数名，那么可以使用如下方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Router(&amp;quot;/&amp;quot;,&amp;amp;IndexController{},&amp;quot;*:Index&amp;quot;)

*表示任意的 method 都执行该函数
使用 httpmethod:funcname 格式来展示
多个不同的格式使用 ; 分割
多个 method 对应同一个 funcname，method 之间通过 , 来分割
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动匹配&lt;/p&gt;

&lt;p&gt;路由的控制器注册到自动路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.AutoRouter(&amp;amp;controllers.ObjectController{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么 beego 就会通过反射获取该结构体中所有的实现方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/object/login   调用 ObjectController 中的 Login 方法
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了前缀两个 /:controller/:method 的匹配之外，剩下的 url beego 会帮你自动化解析为参数，保存在 this.Ctx.Input.Params 当中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/object/blog/2013/09/12  调用 ObjectController 中的 Blog 方法，参数如下：map[0:2013 1:09 2:12]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注解路由&lt;/p&gt;

&lt;p&gt;从 beego 1.3 版本开始支持了注解路由，用户无需在 router 中注册路由，只需要 Include 相应地 controller，然后在 controller 的 method 方法上面写上 router 注释（// @router）就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CMS API
type CMSController struct {
    beego.Controller
}

func (c *CMSController) URLMapping() {
    c.Mapping(&amp;quot;StaticBlock&amp;quot;, c.StaticBlock)
    c.Mapping(&amp;quot;AllBlock&amp;quot;, c.AllBlock)
}


// @router /staticblock/:key [get]
func (this *CMSController) StaticBlock() {

}

// @router /all/:key [get]
func (this *CMSController) AllBlock() {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在 router.go 中通过如下方式注册路由&lt;/p&gt;

&lt;p&gt;beego.Include(&amp;amp;CMSController{})&lt;/p&gt;

&lt;p&gt;beego 自动会进行源码分析，注意只会在 dev 模式下进行生成，生成的路由放在 “/routers/commentsRouter.go” 文件中。&lt;/p&gt;

&lt;p&gt;这样上面的路由就支持了如下的路由：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /staticblock/:key
GET /all/:key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实效果和自己通过 Router 函数注册是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.Router(&amp;quot;/staticblock/:key&amp;quot;, &amp;amp;CMSController{}, &amp;quot;get:StaticBlock&amp;quot;)
beego.Router(&amp;quot;/all/:key&amp;quot;, &amp;amp;CMSController{}, &amp;quot;get:AllBlock&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时大家注意到新版本里面增加了 URLMapping 这个函数，这是新增加的函数，用户如果没有进行注册，那么就会通过反射来执行对应的函数，如果注册了就会通过 interface 来进行执行函数，性能上面会提升很多。&lt;/p&gt;

&lt;p&gt;namespace增加命令空间也就是在url中加一层&lt;/p&gt;

&lt;p&gt;接口如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NewNamespace(prefix string, funcs …interface{})

初始化 namespace 对象,下面这些函数都是 namespace 对象的方法,但是强烈推荐使用 NS 开头的相应函数注册，因为这样更容易通过 gofmt 工具看的更清楚路由的级别关系
NSCond(cond namespaceCond)

支持满足条件的就执行该 namespace, 不满足就不执行
NSBefore(filiterList …FilterFunc)
NSAfter(filiterList …FilterFunc)

上面分别对应 beforeRouter 和 FinishRouter 两个过滤器，可以同时注册多个过滤器
NSInclude(cList …ControllerInterface)
NSRouter(rootpath string, c ControllerInterface, mappingMethods …string)
NSGet(rootpath string, f FilterFunc)
NSPost(rootpath string, f FilterFunc)
NSDelete(rootpath string, f FilterFunc)
NSPut(rootpath string, f FilterFunc)
NSHead(rootpath string, f FilterFunc)
NSOptions(rootpath string, f FilterFunc)
NSPatch(rootpath string, f FilterFunc)
NSAny(rootpath string, f FilterFunc)
NSHandler(rootpath string, h http.Handler)
NSAutoRouter(c ControllerInterface)
NSAutoPrefix(prefix string, c ControllerInterface)

上面这些都是设置路由的函数,详细的使用和上面 beego 的对应函数是一样的
NSNamespace(prefix string, params …innnerNamespace)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、 controller&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package controllers

import (
        &amp;quot;github.com/astaxie/beego&amp;quot;
)

type MainController struct {
        beego.Controller
}

func (this *MainController) Get() {
        this.Data[&amp;quot;Website&amp;quot;] = &amp;quot;beego.me&amp;quot;
        this.Data[&amp;quot;Email&amp;quot;] = &amp;quot;astaxie@gmail.com&amp;quot;
        this.TplName = &amp;quot;index.tpl&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们声明了一个控制器 MainController，这个控制器里面内嵌了 beego.Controller，这就是 Go 的嵌入方式，也就是 MainController 自动拥有了所有 beego.Controller 的方法。&lt;/p&gt;

&lt;p&gt;beego.Controller 拥有很多方法，其中包括 Init、Prepare、Post、Get、Delete、Head 等方法。我们可以通过重写的方式来实现这些方法，而我们上面的代码就是重写了 Get 方法，没有重写就调用beego的方法。&lt;/p&gt;

&lt;p&gt;我们根据上面的路由重restful的请求中路由到这个控制器，并且执行get方法。get方法就是对业务逻辑流程的处理。&lt;/p&gt;

&lt;p&gt;this.Data这是一个用来存储输出数据的 map，可以赋值任意类型的值。可以直接用 this.Ctx.WriteString 输出字符串。&lt;/p&gt;

&lt;p&gt;最后一个就是需要去渲染的模板，this.TplName 就是需要渲染的模板，这里指定了 index.tpl，如果用户不设置该参数，那么默认会去到模板目录的 Controller/&amp;lt;方法名&amp;gt;.tpl 查找，例如上面的方法会去 maincontroller/get.tpl (文件、文件夹必须小写)。&lt;/p&gt;

&lt;p&gt;用户设置了模板之后系统会自动的调用 Render 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;beego 目前支持 INI、XML、JSON、YAML 格式的配置文件解析，但是默认采用了 INI 格式解析，用户可以通过简单的配置就可以获得很大的灵活性。&lt;/p&gt;

&lt;p&gt;eego 默认会解析当前应用下的 conf/app.conf 文件。&lt;/p&gt;

&lt;p&gt;可以直接通过beego.BConfig.AppName=&amp;ldquo;beepkg&amp;rdquo;来设置。&lt;/p&gt;

&lt;p&gt;可以通过如下的方式获取设置的配置信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.AppConfig.String(&amp;quot;mysqluser&amp;quot;)
beego.AppConfig.String(&amp;quot;mysqlpass&amp;quot;)
beego.AppConfig.String(&amp;quot;mysqlurls&amp;quot;)
beego.AppConfig.String(&amp;quot;mysqldb&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AppConfig提供好多方法需要时查阅使用。&lt;/p&gt;

&lt;p&gt;配置文件里面支持 section&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;runmode =&amp;quot;dev&amp;quot;
[dev]
httpport = 8080
[prod]
httpport = 8088
[test]
httpport = 8888
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同的runmode启动的端口不一样。&lt;/p&gt;

&lt;p&gt;INI 格式配置支持 include 方式，引用多个配置文件&lt;/p&gt;

&lt;p&gt;配置文件解析支持从环境变量中获取配置项，配置项格式：${环境变量}。&lt;/p&gt;

&lt;p&gt;配置里面的所有参数使用时可以去beego中查看，很详细。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于 beego 的 Controller 设计，只需要匿名组合 beego.Controller 就可以了，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type xxxController struct {
    beego.Controller
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beego.Controller实现了基本的方法，可以对它进行重写。&lt;/p&gt;

&lt;p&gt;可以使用 StopRun 来终止执行逻辑，可以在任意的地方执行。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;跨站请求伪造(Cross-site request forgery)， 简称为 XSRF&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;beego 有内建的 XSRF 的防范机制，要使用此机制，你需要在应用配置文件中加上 enablexsrf 设定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enablexsrf = true
xsrfkey = 61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o
xsrfexpire = 3600
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接在 main 入口处这样设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.EnableXSRF = true
beego.XSRFKEY = &amp;quot;61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o&amp;quot;
beego.XSRFExpire = 3600  //过期时间，默认1小时
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果开启了 XSRF，那么 beego 的 Web 应用将对所有用户设置一个 _xsrf 的 cookie 值（默认过期 1 小时），如果 POST PUT DELET 请求中没有这个 cookie 值，那么这个请求会被直接拒绝。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取参数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们经常需要获取用户传递的数据，包括 Get、POST 等方式的请求，beego 里面会自动解析这些数据，你可以通过如下方式获取数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GetString(key string) string
GetStrings(key string) []string
GetInt(key string) (int64, error)
GetBool(key string) (bool, error)
GetFloat(key string) (float64, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *MainController) Post() {
    jsoninfo := this.GetString(&amp;quot;jsoninfo&amp;quot;)  ----这个jsoninfo是在post请求中body中发送的字符串，还是key/value格式，key就是jsoninfo
    if jsoninfo == &amp;quot;&amp;quot; {
        this.Ctx.WriteString(&amp;quot;jsoninfo is empty&amp;quot;)
        return
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要的数据可能是其他类型的，例如是 int 类型而不是 int64，那么你需要这样处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *MainController) Post() {
    id := this.Input().Get(&amp;quot;id&amp;quot;)
    intid, err := strconv.Atoi(id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多其他的 request 的信息，用户可以通过 this.Ctx.Request 获取请求信息&lt;/p&gt;

&lt;p&gt;如果要把表单里的内容赋值到一个 struct 里，除了用上面的方法一个一个获取再赋值外，beego 提供了通过另外一个更便捷的方式，就是通过 struct 的字段名或 tag 与表单字段对应直接解析到 struct。&lt;/p&gt;

&lt;p&gt;定义 struct：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type user struct {
    Id    int         `form:&amp;quot;-&amp;quot;`
    Name  interface{} `form:&amp;quot;username&amp;quot;`
    Age   int         `form:&amp;quot;age&amp;quot;`
    Email string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;user&amp;quot;&amp;gt;
    名字：&amp;lt;input name=&amp;quot;username&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
    年龄：&amp;lt;input name=&amp;quot;age&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
    邮箱：&amp;lt;input name=&amp;quot;Email&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Controller 里解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *MainController) Post() {
    u := user{}
    if err := this.ParseForm(&amp;amp;u); err != nil {
        //handle error
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取 Request Body 里的内容&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在配置文件里设置 copyrequestbody = true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 Controller 中&lt;/p&gt;

&lt;p&gt;func (this *ObjectController) Post() {
    var ob models.Object
    json.Unmarshal(this.Ctx.Input.RequestBody, &amp;amp;ob)
}&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unmarshal和marshal就是将json和[] byte进行互换。&lt;/p&gt;

&lt;p&gt;文件上传&lt;/p&gt;

&lt;p&gt;在你的 form 表单中增加这个属性 enctype=&amp;ldquo;multipart/form-data&amp;rdquo;，否则你的浏览器不会传输你的上传文件。&lt;/p&gt;

&lt;p&gt;Beego 提供了两个很方便的方法来处理文件上传：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GetFile(key string) (multipart.File, *multipart.FileHeader, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法主要用于用户读取表单中的文件名 the_file，然后返回相应的信息，用户根据这些变量来处理文件上传：过滤、保存文件等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SaveToFile(fromfile, tofile string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法是在 GetFile 的基础上实现了快速保存的功能&lt;/p&gt;

&lt;p&gt;数据绑定-这个使用于指定的数据&lt;/p&gt;

&lt;p&gt;支持从用户请求中直接数据 bind 到指定的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;URL：?id=123&amp;amp;isok=true&amp;amp;ft=1.2&amp;amp;ol[0]=1&amp;amp;ol[1]=2&amp;amp;ul[]=str&amp;amp;ul[]=array&amp;amp;user.Name=astaxie

var id int
this.Ctx.Input.Bind(&amp;amp;id, &amp;quot;id&amp;quot;)  //id ==123

var isok bool
this.Ctx.Input.Bind(&amp;amp;isok, &amp;quot;isok&amp;quot;)  //isok ==true

var ft float64
this.Ctx.Input.Bind(&amp;amp;ft, &amp;quot;ft&amp;quot;)  //ft ==1.2

ol := make([]int, 0, 2)
this.Ctx.Input.Bind(&amp;amp;ol, &amp;quot;ol&amp;quot;)  //ol ==[1 2]

ul := make([]string, 0, 2)
this.Ctx.Input.Bind(&amp;amp;ul, &amp;quot;ul&amp;quot;)  //ul ==[str array]

user struct{Name}
this.Ctx.Input.Bind(&amp;amp;user, &amp;quot;user&amp;quot;)  //user =={Name:&amp;quot;astaxie&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;session 控制&lt;/p&gt;

&lt;p&gt;session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。&lt;/p&gt;

&lt;p&gt;当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。&lt;/p&gt;

&lt;p&gt;保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID。&lt;/p&gt;

&lt;p&gt;beego 内置了 session 模块，目前 session 模块支持的后端引擎包括 memory、cookie、file、mysql、redis、couchbase、memcache、postgres，用户也可以根据相应的 interface 实现自己的引擎。&lt;/p&gt;

&lt;p&gt;beego 中使用 session 相当方便，只要在 main 入口函数中设置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.BConfig.WebConfig.Session.SessionOn = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者通过配置文件配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sessionon = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过滤器&lt;/p&gt;

&lt;p&gt;beego 支持自定义过滤中间件，例如安全验证，强制跳转等。&lt;/p&gt;

&lt;p&gt;过滤器函数如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.InsertFilter(pattern string, postion int, filter FilterFunc, params ...bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;InsertFilter 函数的三个必填参数，一个可选参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pattern 路由规则，可以根据一定的规则进行路由，如果你全匹配可以用 *
postion 执行 Filter 的地方，四个固定参数如下，分别表示不同的执行过程
BeforeStatic 静态地址之前
BeforeRouter 寻找路由之前
BeforeExec 找到路由之后，开始执行相应的 Controller 之前
AfterExec 执行完 Controller 逻辑之后执行的过滤器
FinishRouter 执行完逻辑之后执行的过滤器
filter filter 函数 type FilterFunc func(*context.Context)
params
设置 returnOnOutput 的值(默认 true), 是否允许如果有输出是否跳过其他 filters，默认只要有输出就不再执行其他 filters
是否重置 filters 的参数，默认是 false，因为在 filters 的 pattern 和本身的路由的 pattern 冲突的时候，可以把 filters 的参数重置，这样可以保证在后续的逻辑中获取到正确的参数，例如设置了 /api/* 的 filter，同时又设置了 /api/docs/* 的 router，那么在访问 /api/docs/swagger/abc.js 的时候，在执行 filters 的时候设置 :splat 参数为 docs/swagger/abc.js，但是如果不清楚 filter 的这个路由参数，就会在执行路由逻辑的时候保持 docs/swagger/abc.js，如果设置了 true，就会重置 :splat 参数.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flash数据在两个逻辑间传递临时数据。&lt;/p&gt;

&lt;p&gt;flash 对象有三个级别的设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Notice 提示信息
Warning 警告信息
Error 错误信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;URL&lt;/p&gt;

&lt;p&gt;beego中可以匹配url 也可以通过UrlFor() 函数就是用于获取指定函数的 URL 的&lt;/p&gt;

&lt;p&gt;各种数据模式的输出&lt;/p&gt;

&lt;p&gt;JSON 数据直接输出：&lt;/p&gt;

&lt;p&gt;func (this *AddController) Get() {
    mystruct := { &amp;hellip; }
    this.Data[&amp;ldquo;json&amp;rdquo;] = &amp;amp;mystruct
    this.ServeJSON()
}
调用 ServeJSON 之后，会设置 content-type 为 application/json，然后同时把数据进行 JSON 序列化输出。
XML 数据直接输出：&lt;/p&gt;

&lt;p&gt;func (this *AddController) Get() {
    mystruct := { &amp;hellip; }
    this.Data[&amp;ldquo;xml&amp;rdquo;]=&amp;amp;mystruct
    this.ServeXML()
}
调用 ServeXML 之后，会设置 content-type 为 application/xml，同时数据会进行 XML 序列化输出。
jsonp 调用&lt;/p&gt;

&lt;p&gt;func (this *AddController) Get() {
    mystruct := { &amp;hellip; }
    this.Data[&amp;ldquo;jsonp&amp;rdquo;] = &amp;amp;mystruct
    this.ServeJSONP()
}
调用 ServeJSONP 之后，会设置 content-type 为 application/javascript，然后同时把数据进行 JSON 序列化，然后根据请求的 callback 参数设置 jsonp 输出。&lt;/p&gt;

&lt;p&gt;validation表单验证&lt;/p&gt;

&lt;p&gt;获取包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/astaxie/beego/validation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常通过 StructTag 使用，也可以直接用对应函数使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type user struct {
    Id     int
    Name   string `valid:&amp;quot;Required;Match(/^Bee.*/)&amp;quot;` // Name 不能为空并且以 Bee 开头
    Age    int    `valid:&amp;quot;Range(1, 140)&amp;quot;` // 1 &amp;lt;= Age &amp;lt;= 140，超出此范围即为不合法
    Email  string `valid:&amp;quot;Email; MaxSize(100)&amp;quot;` // Email 字段需要符合邮箱格式，并且最大长度不能大于 100 个字符
    Mobile string `valid:&amp;quot;Mobile&amp;quot;` // Mobile 必须为正确的手机号
    IP     string `valid:&amp;quot;IP&amp;quot;` // IP 必须为一个正确的 IPv4 地址
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StructTag 可用的验证函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Required 不为空，即各个类型要求不为其零值
Min(min int) 最小值，有效类型：int，其他类型都将不能通过验证)
Max(max int) 最大值，有效类型：int，其他类型都将不能通过验证
Range(min, max int) 数值的范围，有效类型：int，他类型都将不能通过验证
MinSize(min int) 最小长度，有效类型：string slice，其他类型都将不能通过验证
MaxSize(max int) 最大长度，有效类型：string slice，其他类型都将不能通过验证
Length(length int) 指定长度，有效类型：string slice，其他类型都将不能通过验证
Alpha alpha字符，有效类型：string，其他类型都将不能通过验证
Numeric 数字，有效类型：string，其他类型都将不能通过验证
AlphaNumeric alpha 字符或数字，有效类型：string，其他类型都将不能通过验证
Match(pattern string) 正则匹配，有效类型：string，其他类型都将被转成字符串再匹配(fmt.Sprintf(“%v”, obj).Match)
AlphaDash alpha 字符或数字或横杠 -_，有效类型：string，其他类型都将不能通过验证
Email 邮箱格式，有效类型：string，其他类型都将不能通过验证
IP IP 格式，目前只支持 IPv4 格式验证，有效类型：string，其他类型都将不能通过验证
Base64 base64 编码，有效类型：string，其他类型都将不能通过验证
Mobile 手机号，有效类型：string，其他类型都将不能通过验证
Tel 固定电话号，有效类型：string，其他类型都将不能通过验证
Phone 手机号或固定电话号，有效类型：string，其他类型都将不能通过验证
ZipCode 邮政编码，有效类型：string，其他类型都将不能通过验证
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误处理&lt;/p&gt;

&lt;p&gt;跳转&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (this *AddController) Get() {
    this.Redirect(&amp;quot;/&amp;quot;, 302)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中止&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.Abort(&amp;quot;401&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beego 框架默认支持 401、403、404、500、503 这几种错误的处理。用户可以自定义相应的错误处理，例如下面重新定义 404 页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func page_not_found(rw http.ResponseWriter, r *http.Request){
    t,_:= template.New(&amp;quot;404.html&amp;quot;).ParseFiles(beego.ViewsPath+&amp;quot;/404.html&amp;quot;)
    data :=make(map[string]interface{})
    data[&amp;quot;content&amp;quot;] = &amp;quot;page not found&amp;quot;
    t.Execute(rw, data)
}

func main() {
    beego.ErrorHandler(&amp;quot;404&amp;quot;,page_not_found)
    beego.Router(&amp;quot;/&amp;quot;, &amp;amp;controllers.MainController{})
    beego.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 1.4.3 版本开始，支持 Controller 方式定义 Error 错误处理函数，这样就可以充分利用系统自带的模板处理，以及 context 等方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package controllers

import (
    &amp;quot;github.com/astaxie/beego&amp;quot;
)

type ErrorController struct {
    beego.Controller
}

func (c *ErrorController) Error404() {
    c.Data[&amp;quot;content&amp;quot;] = &amp;quot;page not found&amp;quot;
    c.TplName = &amp;quot;404.tpl&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的例子我们可以看到，所有的函数都是有一定规律的，都是 Error 开头，后面的名字就是我们调用 Abort 的名字，例如 Error404 函数其实调用对应的就是 Abort(&amp;ldquo;404&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;我们就只要在 beego.Run 之前采用 beego.ErrorController 注册这个错误处理函数就可以了&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import (
    _ &amp;quot;btest/routers&amp;quot;
    &amp;quot;btest/controllers&amp;quot;

    &amp;quot;github.com/astaxie/beego&amp;quot;
)

func main() {
    beego.ErrorController(&amp;amp;controllers.ErrorController{})
    beego.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;日志处理&lt;/p&gt;

&lt;p&gt;beego 的日志处理是基于 logs 模块搭建的，内置了一个变量 BeeLogger，默认已经是 logs.BeeLogger 类型，初始化了 console，也就是默认输出到 console。&lt;/p&gt;

&lt;p&gt;一般在程序中我们使用如下的方式进行输出：&lt;/p&gt;

&lt;p&gt;beego.Emergency(&amp;ldquo;this is emergency&amp;rdquo;)
beego.Alert(&amp;ldquo;this is alert&amp;rdquo;)
beego.Critical(&amp;ldquo;this is critical&amp;rdquo;)
beego.Error(&amp;ldquo;this is error&amp;rdquo;)
beego.Warning(&amp;ldquo;this is warning&amp;rdquo;)
beego.Notice(&amp;ldquo;this is notice&amp;rdquo;)
beego.Informational(&amp;ldquo;this is informational&amp;rdquo;)
beego.Debug(&amp;ldquo;this is debug&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;设置输出到文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.SetLogger(&amp;quot;file&amp;quot;, `{&amp;quot;filename&amp;quot;:&amp;quot;logs/test.log&amp;quot;}`)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个默认情况就会同时输出到两个地方，一个 console，一个 file，如果只想输出到文件，就需要调用删除操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.BeeLogger.DelLogger(&amp;quot;console&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过设置级别设置日志级别&lt;/p&gt;

&lt;p&gt;beego.SetLevel(beego.LevelInformational)&lt;/p&gt;

&lt;p&gt;日志的级别如上所示的代码这样分为八个级别：&lt;/p&gt;

&lt;p&gt;LevelEmergency
LevelAlert
LevelCritical
LevelError
LevelWarning
LevelNotice
LevelInformational
LevelDebug&lt;/p&gt;

&lt;p&gt;输出文件名和行号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beego.SetLogFuncCall(true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启传入参数 true, 关闭传入参数 false, 默认是关闭的.&lt;/p&gt;

&lt;p&gt;四、 Model&lt;/p&gt;

&lt;p&gt;Model 就是逐步抽象的过程，一般我们会在 Model 里面处理一些数据读取。在beego中主要是orm。&lt;/p&gt;

&lt;p&gt;ORM 使用方法&lt;/p&gt;

&lt;p&gt;目前 ORM 支持三种数据库，以下为测试过的 driver&lt;/p&gt;

&lt;p&gt;将你需要使用的 driver 加入 import 中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import (
    _ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
    _ &amp;quot;github.com/lib/pq&amp;quot;
    _ &amp;quot;github.com/mattn/go-sqlite3&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注册&lt;/p&gt;

&lt;p&gt;orm.RegisterDriver(&amp;ldquo;mysql&amp;rdquo;, orm.DRMySQL)&lt;/p&gt;

&lt;p&gt;// For version 1.6
orm.DRMySQL
orm.DRSqlite
orm.DRPostgres&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mysql / sqlite3 / postgres 这三种是默认已经注册过的，所以可以无需设置&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ORM 必须注册一个别名为 default 的数据库，作为默认使用。&lt;/p&gt;

&lt;p&gt;ORM 使用 golang 自己的连接池&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 参数1        数据库的别名，用来在 ORM 中切换数据库使用
// 参数2        driverName
// 参数3        对应的链接字符串
orm.RegisterDataBase(&amp;quot;default&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_test?charset=utf8&amp;quot;)

// 参数4(可选)  设置最大空闲连接
// 参数5(可选)  设置最大数据库连接 (go &amp;gt;= 1.2)
maxIdle := 30
maxConn := 30
orm.RegisterDataBase(&amp;quot;default&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_test?charset=utf8&amp;quot;, maxIdle, maxConn)


根据数据库的别名，设置数据库的最大空闲连接

orm.SetMaxIdleConns(&amp;quot;default&amp;quot;, 30)

根据数据库的别名，设置数据库的最大数据库连接 (go &amp;gt;= 1.2)

orm.SetMaxOpenConns(&amp;quot;default&amp;quot;, 30)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册模型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;orm.RegisterModel(new(User), new(Profile), new(Post))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将你定义的 Model 进行注册，最佳设计是有单独的 models.go 文件，在他的 init 函数中进行注册。&lt;/p&gt;

&lt;p&gt;使用表名前缀&lt;/p&gt;

&lt;p&gt;orm.RegisterModelWithPrefix(&amp;ldquo;prefix_&amp;ldquo;, new(User))
创建后的表名为 prefix_user&lt;/p&gt;

&lt;p&gt;从已注册的数据库返回 *sql.DB 对象，默认返回别名为 default 的数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db, err := orm.GetDB()
if err != nil {
    fmt.Println(&amp;quot;get default DataBase&amp;quot;)
}

db, err := orm.GetDB(&amp;quot;alias&amp;quot;)
if err != nil {
    fmt.Println(&amp;quot;get alias DataBase&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用&lt;/p&gt;

&lt;p&gt;var o Ormer
o = orm.NewOrm() // 创建一个 Ormer
// NewOrm 的同时会执行 orm.BootStrap (整个 app 只执行一次)，用以验证模型之间的定义并缓存。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;切换数据库，或者，进行事务处理，都会作用于这个 Ormer 对象，以及其进行的任何查询。&lt;/p&gt;

&lt;p&gt;ormer对象提供了封装好的操作方法&lt;/p&gt;

&lt;p&gt;QueryTable&lt;/p&gt;

&lt;p&gt;传入表名，或者 Model 对象，返回一个 QuerySeter&lt;/p&gt;

&lt;p&gt;o := orm.NewOrm()&lt;/p&gt;

&lt;p&gt;// 获取 QuerySeter 对象，user 为表名
qs := o.QueryTable(&amp;ldquo;user&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// 也可以直接使用对象作为表名
user := new(User)
qs = o.QueryTable(user) // 返回 QuerySeter&lt;/p&gt;

&lt;p&gt;Using&lt;/p&gt;

&lt;p&gt;切换为其他数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;orm.RegisterDataBase(&amp;quot;db1&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_db2?charset=utf8&amp;quot;)
orm.RegisterDataBase(&amp;quot;db2&amp;quot;, &amp;quot;sqlite3&amp;quot;, &amp;quot;data.db&amp;quot;)

o1 := orm.NewOrm()
o1.Using(&amp;quot;db1&amp;quot;)

o2 := orm.NewOrm()
o2.Using(&amp;quot;db2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认使用 default 数据库，无需调用 Using&lt;/p&gt;

&lt;p&gt;Raw&lt;/p&gt;

&lt;p&gt;使用 sql 语句直接进行操作&lt;/p&gt;

&lt;p&gt;Raw 函数，返回一个 RawSeter 用以对设置的 sql 语句和参数进行操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := NewOrm()
var r RawSeter
r = o.Raw(&amp;quot;UPDATE user SET name = ? WHERE name = ?&amp;quot;, &amp;quot;testing&amp;quot;, &amp;quot;slene&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Driver&lt;/p&gt;

&lt;p&gt;返回当前 ORM 使用的 db 信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Driver interface {
    Name() string
    Type() DriverType
}

orm.RegisterDataBase(&amp;quot;db1&amp;quot;, &amp;quot;mysql&amp;quot;, &amp;quot;root:root@/orm_db2?charset=utf8&amp;quot;)
orm.RegisterDataBase(&amp;quot;db2&amp;quot;, &amp;quot;sqlite3&amp;quot;, &amp;quot;data.db&amp;quot;)

o1 := orm.NewOrm()
o1.Using(&amp;quot;db1&amp;quot;)
dr := o1.Driver()
fmt.Println(dr.Name() == &amp;quot;db1&amp;quot;) // true
fmt.Println(dr.Type() == orm.DRMySQL) // true

o2 := orm.NewOrm()
o2.Using(&amp;quot;db2&amp;quot;)
dr = o2.Driver()
fmt.Println(dr.Name() == &amp;quot;db2&amp;quot;) // true
fmt.Println(dr.Type() == orm.DRSqlite) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调试模式打印查询语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;orm.Debug = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CRUD&lt;/p&gt;

&lt;p&gt;如果已知主键的值，那么可以使用这些方法进行 CRUD 操作&lt;/p&gt;

&lt;p&gt;Read&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := orm.NewOrm()
user := User{Id: 1}

err = o.Read(&amp;amp;user)

if err == orm.ErrNoRows {
    fmt.Println(&amp;quot;查询不到&amp;quot;)
} else if err == orm.ErrMissPK {
    fmt.Println(&amp;quot;找不到主键&amp;quot;)
} else {
    fmt.Println(user.Id, user.Name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read 默认通过查询主键赋值，可以使用指定的字段进行查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user := User{Name: &amp;quot;slene&amp;quot;}
err = o.Read(&amp;amp;user, &amp;quot;Name&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReadOrCreate&lt;/p&gt;

&lt;p&gt;尝试从数据库读取，不存在的话就创建一个&lt;/p&gt;

&lt;p&gt;Insert&lt;/p&gt;

&lt;p&gt;第一个返回值为自增健 Id 的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := orm.NewOrm()
var user User
user.Name = &amp;quot;slene&amp;quot;
user.IsActive = true

id, err := o.Insert(&amp;amp;user)
if err == nil {
    fmt.Println(id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建后会自动对 auto 的 field 赋值&lt;/p&gt;

&lt;p&gt;InsertMulti&lt;/p&gt;

&lt;p&gt;同时插入多个对象&lt;/p&gt;

&lt;p&gt;类似sql语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insert into table (name, age) values(&amp;quot;slene&amp;quot;, 28),(&amp;quot;astaxie&amp;quot;, 30),(&amp;quot;unknown&amp;quot;, 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数 bulk 为并列插入的数量，第二个为对象的slice&lt;/p&gt;

&lt;p&gt;返回值为成功插入的数量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;users := []User{
    {Name: &amp;quot;slene&amp;quot;},
    {Name: &amp;quot;astaxie&amp;quot;},
    {Name: &amp;quot;unknown&amp;quot;},
    ...
}
successNums, err := o.InsertMulti(100, users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bulk 为 1 时，将会顺序插入 slice 中的数据&lt;/p&gt;

&lt;p&gt;Update&lt;/p&gt;

&lt;p&gt;第一个返回值为影响的行数&lt;/p&gt;

&lt;p&gt;o := orm.NewOrm()
user := User{Id: 1}
if o.Read(&amp;amp;user) == nil {
    user.Name = &amp;ldquo;MyName&amp;rdquo;
    if num, err := o.Update(&amp;amp;user); err == nil {
        fmt.Println(num)
    }
}
Update 默认更新所有的字段，可以更新指定的字段：&lt;/p&gt;

&lt;p&gt;// 只更新 Name
o.Update(&amp;amp;user, &amp;ldquo;Name&amp;rdquo;)
// 指定多个字段
// o.Update(&amp;amp;user, &amp;ldquo;Field1&amp;rdquo;, &amp;ldquo;Field2&amp;rdquo;, &amp;hellip;)&lt;/p&gt;

&lt;p&gt;Delete&lt;/p&gt;

&lt;p&gt;第一个返回值为影响的行数&lt;/p&gt;

&lt;p&gt;o := orm.NewOrm()
if num, err := o.Delete(&amp;amp;User{Id: 1}); err == nil {
    fmt.Println(num)
}&lt;/p&gt;

&lt;p&gt;expr&lt;/p&gt;

&lt;p&gt;User 表查询对应的 Profile.Age 为条件，则使用 Profile__Age 注意，字段的分隔符号使用双下划线 &lt;strong&gt;，除了描述字段， expr 的尾部可以增加操作符以执行对应的 sql 操作。比如 Profile&lt;/strong&gt;Age__gt 代表 Profile.Age &amp;gt; 18 的条件查询。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;id&amp;quot;, 1) // WHERE id = 1
qs.Filter(&amp;quot;profile__age&amp;quot;, 18) // WHERE profile.age = 18
qs.Filter(&amp;quot;Profile__Age&amp;quot;, 18) // 使用字段名和 Field 名都是允许的
qs.Filter(&amp;quot;profile__age&amp;quot;, 18) // WHERE profile.age = 18
qs.Filter(&amp;quot;profile__age__gt&amp;quot;, 18) // WHERE profile.age &amp;gt; 18
qs.Filter(&amp;quot;profile__age__gte&amp;quot;, 18) // WHERE profile.age &amp;gt;= 18
qs.Filter(&amp;quot;profile__age__in&amp;quot;, 18, 20) // WHERE profile.age IN (18, 20)

qs.Filter(&amp;quot;profile__age__in&amp;quot;, 18, 20).Exclude(&amp;quot;profile__lt&amp;quot;, 1000)
// WHERE profile.age IN (18, 20) AND NOT profile_id &amp;lt; 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operators&lt;/p&gt;

&lt;p&gt;exact&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name&amp;quot;, &amp;quot;slene&amp;quot;) // WHERE name = &#39;slene&#39;
qs.Filter(&amp;quot;name__exact&amp;quot;, &amp;quot;slene&amp;quot;) // WHERE name = &#39;slene&#39;

// 使用 = 匹配，大小写是否敏感取决于数据表使用的 collation

qs.Filter(&amp;quot;profile_id&amp;quot;, nil) // WHERE profile_id IS NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iexact&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__iexact&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;slene&#39;
// 大小写不敏感，匹配任意 &#39;Slene&#39; &#39;sLENE&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contains&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__contains&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE BINARY &#39;%slene%&#39;
// 大小写敏感, 匹配包含 slene 的字符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;icontains&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__icontains&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;%slene%&#39;
// 大小写不敏感, 匹配任意 &#39;im Slene&#39;, &#39;im sLENE&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__age__in&amp;quot;, 17, 18, 19, 20)
// WHERE profile.age IN (17, 18, 19, 20)


ids:=[]int{17,18,19,20}
qs.Filter(&amp;quot;profile__age__in&amp;quot;, ids)
// WHERE profile.age IN (17, 18, 19, 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gt / gte&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__age__gt&amp;quot;, 17)
// WHERE profile.age &amp;gt; 17

qs.Filter(&amp;quot;profile__age__gte&amp;quot;, 18)
// WHERE profile.age &amp;gt;= 18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lt / lte&lt;/p&gt;

&lt;p&gt;qs.Filter(&amp;ldquo;profile&lt;strong&gt;age&lt;/strong&gt;lt&amp;rdquo;, 17)
    // WHERE profile.age &amp;lt; 17&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__age__lte&amp;quot;, 18)
// WHERE profile.age &amp;lt;= 18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;startswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__startswith&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE BINARY &#39;slene%&#39;
// 大小写敏感, 匹配以 &#39;slene&#39; 起始的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;istartswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__istartswith&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;slene%&#39;
// 大小写不敏感, 匹配任意以 &#39;slene&#39;, &#39;Slene&#39; 起始的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;endswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__endswith&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE BINARY &#39;%slene&#39;
// 大小写敏感, 匹配以 &#39;slene&#39; 结束的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iendswith&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;name__iendswithi&amp;quot;, &amp;quot;slene&amp;quot;)
// WHERE name LIKE &#39;%slene&#39;
// 大小写不敏感, 匹配任意以 &#39;slene&#39;, &#39;Slene&#39; 结束的字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isnull&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qs.Filter(&amp;quot;profile__isnull&amp;quot;, true)
qs.Filter(&amp;quot;profile_id__isnull&amp;quot;, true)
// WHERE profile_id IS NULL

qs.Filter(&amp;quot;profile__isnull&amp;quot;, false)
// WHERE profile_id IS NOT NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QuerySeter高级查询接口&lt;/p&gt;

&lt;p&gt;Filter&lt;/p&gt;

&lt;p&gt;用来过滤查询结果，起到 包含条件 的作用&lt;/p&gt;

&lt;p&gt;多个 Filter 之间使用 AND 连接&lt;/p&gt;

&lt;p&gt;qs.Filter(&amp;ldquo;profile__isnull&amp;rdquo;, true).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;)
// WHERE profile_id IS NULL AND name = &amp;lsquo;slene&amp;rsquo;
Exclude&lt;/p&gt;

&lt;p&gt;用来过滤查询结果，起到 排除条件 的作用&lt;/p&gt;

&lt;p&gt;使用 NOT 排除条件&lt;/p&gt;

&lt;p&gt;多个 Exclude 之间使用 AND 连接&lt;/p&gt;

&lt;p&gt;qs.Exclude(&amp;ldquo;profile__isnull&amp;rdquo;, true).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;)
// WHERE NOT profile_id IS NULL AND name = &amp;lsquo;slene&amp;rsquo;
SetCond&lt;/p&gt;

&lt;p&gt;自定义条件表达式&lt;/p&gt;

&lt;p&gt;cond := orm.NewCondition()
cond1 := cond.And(&amp;ldquo;profile&lt;strong&gt;isnull&amp;rdquo;, false).AndNot(&amp;ldquo;status&lt;/strong&gt;in&amp;rdquo;, 1).Or(&amp;ldquo;profile&lt;strong&gt;age&lt;/strong&gt;gt&amp;rdquo;, 2000)&lt;/p&gt;

&lt;p&gt;qs := orm.QueryTable(&amp;ldquo;user&amp;rdquo;)
qs = qs.SetCond(cond1)
// WHERE &amp;hellip; AND &amp;hellip; AND NOT &amp;hellip; OR &amp;hellip;&lt;/p&gt;

&lt;p&gt;cond2 := cond.AndCond(cond1).OrCond(cond.And(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;))
qs = qs.SetCond(cond2).Count()
// WHERE (&amp;hellip; AND &amp;hellip; AND NOT &amp;hellip; OR &amp;hellip;) OR ( &amp;hellip; )
Limit&lt;/p&gt;

&lt;p&gt;限制最大返回数据行数，第二个参数可以设置 Offset&lt;/p&gt;

&lt;p&gt;var DefaultRowsLimit = 1000 // ORM 默认的 limit 值为 1000&lt;/p&gt;

&lt;p&gt;// 默认情况下 select 查询的最大行数为 1000
// LIMIT 1000&lt;/p&gt;

&lt;p&gt;qs.Limit(10)
// LIMIT 10&lt;/p&gt;

&lt;p&gt;qs.Limit(10, 20)
// LIMIT 10 OFFSET 20 注意跟 SQL 反过来的&lt;/p&gt;

&lt;p&gt;qs.Limit(-1)
// no limit&lt;/p&gt;

&lt;p&gt;qs.Limit(-1, 100)
// LIMIT 18446744073709551615 OFFSET 100
// 18446744073709551615 是 1&amp;lt;&amp;lt;64 - 1 用来指定无 limit 限制 但有 offset 偏移的情况
Offset&lt;/p&gt;

&lt;p&gt;设置 偏移行数&lt;/p&gt;

&lt;p&gt;qs.Offset(20)
// LIMIT 1000 OFFSET 20
GroupBy&lt;/p&gt;

&lt;p&gt;qs.GroupBy(&amp;ldquo;id&amp;rdquo;, &amp;ldquo;age&amp;rdquo;)
// GROUP BY id,age
OrderBy&lt;/p&gt;

&lt;p&gt;参数使用 expr&lt;/p&gt;

&lt;p&gt;在 expr 前使用减号 - 表示 DESC 的排列&lt;/p&gt;

&lt;p&gt;qs.OrderBy(&amp;ldquo;id&amp;rdquo;, &amp;ldquo;-profile__age&amp;rdquo;)
// ORDER BY id ASC, profile.age DESC&lt;/p&gt;

&lt;p&gt;qs.OrderBy(&amp;ldquo;-profile__age&amp;rdquo;, &amp;ldquo;profile&amp;rdquo;)
// ORDER BY profile.age DESC, profile_id ASC
Distinct&lt;/p&gt;

&lt;p&gt;对应 sql 的 distinct 语句, 返回不重复的值.&lt;/p&gt;

&lt;p&gt;qs.Distinct()
// SELECT DISTINCT
RelatedSel&lt;/p&gt;

&lt;p&gt;关系查询，参数使用 expr&lt;/p&gt;

&lt;p&gt;var DefaultRelsDepth = 5 // 默认情况下直接调用 RelatedSel 将进行最大 5 层的关系查询&lt;/p&gt;

&lt;p&gt;qs := o.QueryTable(&amp;ldquo;post&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;qs.RelatedSel()
// INNER JOIN user &amp;hellip; LEFT OUTER JOIN profile &amp;hellip;&lt;/p&gt;

&lt;p&gt;qs.RelatedSel(&amp;ldquo;user&amp;rdquo;)
// INNER JOIN user &amp;hellip;
// 设置 expr 只对设置的字段进行关系查询&lt;/p&gt;

&lt;p&gt;// 对设置 null 属性的 Field 将使用 LEFT OUTER JOIN
Count&lt;/p&gt;

&lt;p&gt;依据当前的查询条件，返回结果行数&lt;/p&gt;

&lt;p&gt;cnt, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Count() // SELECT COUNT(*) FROM USER
fmt.Printf(&amp;ldquo;Count Num: %s, %s&amp;rdquo;, cnt, err)
Exist&lt;/p&gt;

&lt;p&gt;exist := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;UserName&amp;rdquo;, &amp;ldquo;Name&amp;rdquo;).Exist()
fmt.Printf(&amp;ldquo;Is Exist: %s&amp;rdquo;, exist)
Update&lt;/p&gt;

&lt;p&gt;依据当前查询条件，进行批量更新操作&lt;/p&gt;

&lt;p&gt;num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).Update(orm.Params{
    &amp;ldquo;name&amp;rdquo;: &amp;ldquo;astaxie&amp;rdquo;,
})
fmt.Printf(&amp;ldquo;Affected Num: %s, %s&amp;rdquo;, num, err)
// SET name = &amp;ldquo;astaixe&amp;rdquo; WHERE name = &amp;ldquo;slene&amp;rdquo;
原子操作增加字段值&lt;/p&gt;

&lt;p&gt;// 假设 user struct 里有一个 nums int 字段
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Update(orm.Params{
    &amp;ldquo;nums&amp;rdquo;: orm.ColValue(orm.ColAdd, 100),
})
// SET nums = nums + 100
orm.ColValue 支持以下操作&lt;/p&gt;

&lt;p&gt;ColAdd      // 加
ColMinus    // 减
ColMultiply // 乘
ColExcept   // 除
Delete&lt;/p&gt;

&lt;p&gt;依据当前查询条件，进行批量删除操作&lt;/p&gt;

&lt;p&gt;num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).Delete()
fmt.Printf(&amp;ldquo;Affected Num: %s, %s&amp;rdquo;, num, err)
// DELETE FROM user WHERE name = &amp;ldquo;slene&amp;rdquo;
PrepareInsert&lt;/p&gt;

&lt;p&gt;用于一次 prepare 多次 insert 插入，以提高批量插入的速度。&lt;/p&gt;

&lt;p&gt;var users []*User
&amp;hellip;
qs := o.QueryTable(&amp;ldquo;user&amp;rdquo;)
i, _ := qs.PrepareInsert()
for _, user := range users {
    id, err := i.Insert(user)
    if err == nil {
        &amp;hellip;
    }
}
// PREPARE INSERT INTO user (&lt;code&gt;name&lt;/code&gt;, &amp;hellip;) VALUES (?, &amp;hellip;)
// EXECUTE INSERT INTO user (&lt;code&gt;name&lt;/code&gt;, &amp;hellip;) VALUES (&amp;ldquo;slene&amp;rdquo;, &amp;hellip;)
// EXECUTE &amp;hellip;
// &amp;hellip;
i.Close() // 别忘记关闭 statement
All&lt;/p&gt;

&lt;p&gt;返回对应的结果集对象&lt;/p&gt;

&lt;p&gt;All 的参数支持 *[]Type 和 *[]*Type 两种形式的 slice&lt;/p&gt;

&lt;p&gt;var users []*User
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).All(&amp;amp;users)
fmt.Printf(&amp;ldquo;Returned Rows Num: %s, %s&amp;rdquo;, num, err)
All / Values / ValuesList / ValuesFlat 受到 Limit 的限制，默认最大行数为 1000&lt;/p&gt;

&lt;p&gt;可以指定返回的字段：&lt;/p&gt;

&lt;p&gt;type Post struct {
    Id      int
    Title   string
    Content string
    Status  int
}&lt;/p&gt;

&lt;p&gt;// 只返回 Id 和 Title
var posts []Post
o.QueryTable(&amp;ldquo;post&amp;rdquo;).Filter(&amp;ldquo;Status&amp;rdquo;, 1).All(&amp;amp;posts, &amp;ldquo;Id&amp;rdquo;, &amp;ldquo;Title&amp;rdquo;)
对象的其他字段值将会是对应类型的默认值&lt;/p&gt;

&lt;p&gt;One&lt;/p&gt;

&lt;p&gt;尝试返回单条记录&lt;/p&gt;

&lt;p&gt;var user User
err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Filter(&amp;ldquo;name&amp;rdquo;, &amp;ldquo;slene&amp;rdquo;).One(&amp;amp;user)
if err == orm.ErrMultiRows {
    // 多条的时候报错
    fmt.Printf(&amp;ldquo;Returned Multi Rows Not One&amp;rdquo;)
}
if err == orm.ErrNoRows {
    // 没有找到记录
    fmt.Printf(&amp;ldquo;Not row found&amp;rdquo;)
}
可以指定返回的字段：&lt;/p&gt;

&lt;p&gt;// 只返回 Id 和 Title
var post Post
o.QueryTable(&amp;ldquo;post&amp;rdquo;).Filter(&amp;ldquo;Content__istartswith&amp;rdquo;, &amp;ldquo;prefix string&amp;rdquo;).One(&amp;amp;post, &amp;ldquo;Id&amp;rdquo;, &amp;ldquo;Title&amp;rdquo;)
对象的其他字段值将会是对应类型的默认值&lt;/p&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;p&gt;返回结果集的 key =&amp;gt; value 值&lt;/p&gt;

&lt;p&gt;key 为 Model 里的 Field name，value 的值 以 string 保存&lt;/p&gt;

&lt;p&gt;var maps []orm.Params
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Values(&amp;amp;maps)
if err == nil {
    fmt.Printf(&amp;ldquo;Result Nums: %d\n&amp;rdquo;, num)
    for _, m := range maps {
        fmt.Println(m[&amp;ldquo;Id&amp;rdquo;], m[&amp;ldquo;Name&amp;rdquo;])
    }
}
返回指定的 Field 数据&lt;/p&gt;

&lt;p&gt;TODO: 暂不支持级联查询 RelatedSel 直接返回 Values&lt;/p&gt;

&lt;p&gt;但可以直接指定 expr 级联返回需要的数据&lt;/p&gt;

&lt;p&gt;var maps []orm.Params
num, err := o.QueryTable(&amp;ldquo;user&amp;rdquo;).Values(&amp;amp;maps, &amp;ldquo;id&amp;rdquo;, &amp;ldquo;name&amp;rdquo;, &amp;ldquo;profile&amp;rdquo;, &amp;ldquo;profile&lt;strong&gt;age&amp;rdquo;)
if err == nil {
    fmt.Printf(&amp;ldquo;Result Nums: %d\n&amp;rdquo;, num)
    for _, m := range maps {
        fmt.Println(m[&amp;ldquo;Id&amp;rdquo;], m[&amp;ldquo;Name&amp;rdquo;], m[&amp;ldquo;Profile&amp;rdquo;], m[&amp;ldquo;Profile&lt;/strong&gt;Age&amp;rdquo;])
        // map 中的数据都是展开的，没有复杂的嵌套
    }
}&lt;/p&gt;

&lt;p&gt;ValuesList&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;顾名思义，返回的结果集以slice存储

结果的排列与 Model 中定义的 Field 顺序一致

返回的每个元素值以 string 保存

var lists []orm.ParamsList
num, err := o.QueryTable(&amp;quot;user&amp;quot;).ValuesList(&amp;amp;lists)
if err == nil {
    fmt.Printf(&amp;quot;Result Nums: %d\n&amp;quot;, num)
    for _, row := range lists {
        fmt.Println(row)
    }
}
当然也可以指定 expr 返回指定的 Field

var lists []orm.ParamsList
num, err := o.QueryTable(&amp;quot;user&amp;quot;).ValuesList(&amp;amp;lists, &amp;quot;name&amp;quot;, &amp;quot;profile__age&amp;quot;)
if err == nil {
    fmt.Printf(&amp;quot;Result Nums: %d\n&amp;quot;, num)
    for _, row := range lists {
        fmt.Printf(&amp;quot;Name: %s, Age: %s\m&amp;quot;, row[0], row[1])
    }
}
ValuesFlat

只返回特定的 Field 值，将结果集展开到单个 slice 里

var list orm.ParamsList
num, err := o.QueryTable(&amp;quot;user&amp;quot;).ValuesFlat(&amp;amp;list, &amp;quot;name&amp;quot;)
if err == nil {
    fmt.Printf(&amp;quot;Result Nums: %d\n&amp;quot;, num)
    fmt.Printf(&amp;quot;All User Names: %s&amp;quot;, strings.Join(list, &amp;quot;, &amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关联查询&lt;/p&gt;

&lt;p&gt;使用具体的sql语句查询&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 Raw SQL 查询，无需使用 ORM 表定义&lt;/li&gt;
&lt;li&gt;多数据库，都可直接使用占位符号 ?，自动转换&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查询时的参数，支持使用 Model Struct 和 Slice, Array&lt;/p&gt;

&lt;p&gt;ids := []int{1, 2, 3}
p.Raw(&amp;ldquo;SELECT name FROM user WHERE id IN (?, ?, ?)&amp;rdquo;, ids)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;返回一个 RawSeter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := orm.NewOrm()
var r RawSeter
r = o.Raw(&amp;quot;UPDATE user SET name = ? WHERE name = ?&amp;quot;, &amp;quot;testing&amp;quot;, &amp;quot;slene&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exec&lt;/p&gt;

&lt;p&gt;执行 sql 语句，返回 sql.Result 对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res, err := o.Raw(&amp;quot;UPDATE user SET name = ?&amp;quot;, &amp;quot;your&amp;quot;).Exec()
if err == nil {
    num, _ := res.RowsAffected()
    fmt.Println(&amp;quot;mysql row affected nums: &amp;quot;, num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QueryRow&lt;/p&gt;

&lt;p&gt;QueryRow 和 QueryRows 提供高级 sql mapper 功能&lt;/p&gt;

&lt;p&gt;支持 struct&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
    Id       int
    UserName string
}

var user User
err := o.Raw(&amp;quot;SELECT id, user_name FROM user WHERE id = ?&amp;quot;, 1).QueryRow(&amp;amp;user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;from beego 1.1.0 取消了多个对象支持&lt;/p&gt;

&lt;p&gt;QueryRows&lt;/p&gt;

&lt;p&gt;QueryRows 支持的对象还有 map 规则是和 QueryRow 一样的，但都是 slice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
    Id       int
    UserName string
}

var users []User
num, err := o.Raw(&amp;quot;SELECT id, user_name FROM user WHERE id = ?&amp;quot;, 1).QueryRows(&amp;amp;users)
if err == nil {
    fmt.Println(&amp;quot;user nums: &amp;quot;, num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;from beego 1.1.0 取消了多个对象支持&lt;/p&gt;

&lt;p&gt;SetArgs&lt;/p&gt;

&lt;p&gt;改变 Raw(sql, args…) 中的 args 参数，返回一个新的 RawSeter&lt;/p&gt;

&lt;p&gt;用于单条 sql 语句，重复利用，替换参数然后执行。&lt;/p&gt;

&lt;p&gt;res, err := r.SetArgs(&amp;ldquo;arg1&amp;rdquo;, &amp;ldquo;arg2&amp;rdquo;).Exec()
res, err := r.SetArgs(&amp;ldquo;arg1&amp;rdquo;, &amp;ldquo;arg2&amp;rdquo;).Exec()&lt;/p&gt;

&lt;p&gt;Values / ValuesList / ValuesFlat&lt;/p&gt;

&lt;p&gt;Raw SQL 查询获得的结果集 Value 为 string 类型，NULL 字段的值为空 ``&lt;/p&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;p&gt;返回结果集的 key =&amp;gt; value 值&lt;/p&gt;

&lt;p&gt;var maps []orm.Params
num, err = o.Raw(&amp;ldquo;SELECT user_name FROM user WHERE status = ?&amp;ldquo;, 1).Values(&amp;amp;maps)
if err == nil &amp;amp;&amp;amp; num &amp;gt; 0 {
    fmt.Println(maps[0][&amp;ldquo;user_name&amp;rdquo;]) // slene
}&lt;/p&gt;

&lt;p&gt;ValuesList&lt;/p&gt;

&lt;p&gt;返回结果集 slice&lt;/p&gt;

&lt;p&gt;var lists []orm.ParamsList
num, err = o.Raw(&amp;ldquo;SELECT user_name FROM user WHERE status = ?&amp;ldquo;, 1).ValuesList(&amp;amp;lists)
if err == nil &amp;amp;&amp;amp; num &amp;gt; 0 {
    fmt.Println(lists[0][0]) // slene
}&lt;/p&gt;

&lt;p&gt;ValuesFlat&lt;/p&gt;

&lt;p&gt;返回单一字段的平铺 slice 数据&lt;/p&gt;

&lt;p&gt;var list orm.ParamsList
num, err = o.Raw(&amp;ldquo;SELECT id FROM user WHERE id &amp;lt; ?&amp;ldquo;, 10).ValuesFlat(&amp;amp;list)
if err == nil &amp;amp;&amp;amp; num &amp;gt; 0 {
    fmt.Println(list) // []{&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;hellip;}
}&lt;/p&gt;

&lt;p&gt;RowsToMap&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res := make(orm.Params)
nums, err := o.Raw(&amp;quot;SELECT name, value FROM options_table&amp;quot;).RowsToMap(&amp;amp;res, &amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
// res is a map[string]interface{}{
//  &amp;quot;total&amp;quot;: 100,
//  &amp;quot;found&amp;quot;: 200,
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RowsToStruct&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Options struct {
    Total int
    Found int
}

res := new(Options)
nums, err := o.Raw(&amp;quot;SELECT name, value FROM options_table&amp;quot;).RowsToStruct(res, &amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
fmt.Println(res.Total) // 100
fmt.Println(res.Found) // 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare&lt;/p&gt;

&lt;p&gt;用于一次 prepare 多次 exec，以提高批量执行的速度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p, err := o.Raw(&amp;quot;UPDATE user SET name = ? WHERE name = ?&amp;quot;).Prepare()
res, err := p.Exec(&amp;quot;testing&amp;quot;, &amp;quot;slene&amp;quot;)
res, err  = p.Exec(&amp;quot;testing&amp;quot;, &amp;quot;astaxie&amp;quot;)
...
...
p.Close() // 别忘记关闭 statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造查询&lt;/p&gt;

&lt;p&gt;QueryBuilder 提供了一个简便，流畅的 SQL 查询构造器。在不影响代码可读性的前提下用来快速的建立 SQL 语句。&lt;/p&gt;

&lt;p&gt;QueryBuilder 在功能上与 ORM 重合， 但是各有利弊。ORM 更适用于简单的 CRUD 操作，而 QueryBuilder 则更适用于复杂的查询，例如查询中包含子查询和多重联结。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// User 包装了下面的查询结果
type User struct {
    Name string
    Age  int
}
var users []User

// 获取 QueryBuilder 对象. 需要指定数据库驱动参数。
// 第二个返回值是错误对象，在这里略过
qb, _ := orm.NewQueryBuilder(&amp;quot;mysql&amp;quot;)

// 构建查询对象
qb.Select(&amp;quot;user.name&amp;quot;,
    &amp;quot;profile.age&amp;quot;).
    From(&amp;quot;user&amp;quot;).
    InnerJoin(&amp;quot;profile&amp;quot;).On(&amp;quot;user.id_user = profile.fk_user&amp;quot;).
    Where(&amp;quot;age &amp;gt; ?&amp;quot;).
    OrderBy(&amp;quot;name&amp;quot;).Desc().
    Limit(10).Offset(0)

// 导出 SQL 语句
sql := qb.String()

// 执行 SQL 语句
o := orm.NewOrm()
o.Raw(sql, 20).QueryRows(&amp;amp;users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整 API 接口:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type QueryBuilder interface {
    Select(fields ...string) QueryBuilder
    From(tables ...string) QueryBuilder
    InnerJoin(table string) QueryBuilder
    LeftJoin(table string) QueryBuilder
    RightJoin(table string) QueryBuilder
    On(cond string) QueryBuilder
    Where(cond string) QueryBuilder
    And(cond string) QueryBuilder
    Or(cond string) QueryBuilder
    In(vals ...string) QueryBuilder
    OrderBy(fields ...string) QueryBuilder
    Asc() QueryBuilder
    Desc() QueryBuilder
    Limit(limit int) QueryBuilder
    Offset(offset int) QueryBuilder
    GroupBy(fields ...string) QueryBuilder
    Having(cond string) QueryBuilder
    Subquery(sub string, alias string) string
    String() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事务处理&lt;/p&gt;

&lt;p&gt;ORM 可以简单的进行事务操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o := NewOrm()
err := o.Begin()
// 事务处理过程
...
...
// 此过程中的所有使用 o Ormer 对象的查询都在事务处理范围内
if SomeError {
    err = o.Rollback()
} else {
    err = o.Commit()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模型定义&lt;/p&gt;

&lt;p&gt;复杂的模型定义不是必须的，此功能用作数据库数据转换和自动建表，在数据库操作中是重要&lt;/p&gt;

&lt;p&gt;默认的表名规则，使用驼峰转蛇形：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AuthUser -&amp;gt; auth_user
Auth_User -&amp;gt; auth__user
DB_AuthUser -&amp;gt; d_b__auth_user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了开头的大写字母以外，遇到大写会增加 _，原名称中的下划线保留。&lt;/p&gt;

&lt;p&gt;还可以自定义，设置参数，具体使用时到官方文档查询。&lt;/p&gt;

&lt;p&gt;五、 view&lt;/p&gt;

&lt;p&gt;在前面编写 Controller 的时候，我们在 Get 里面写过这样的语句 this.TplName = &amp;ldquo;index.tpl&amp;rdquo;，设置显示的模板文件，默认支持 tpl 和 html 的后缀名，如果想设置其他后缀你可以调用 beego.AddTemplateExt 接口设置&lt;/p&gt;

&lt;p&gt;主要是模版语言语法，先去了解然后查阅文档使用。&lt;/p&gt;

&lt;p&gt;beego 的模块设计&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session 模块
grace 模块
cache 模块
logs 模块
httplib 模块
context 模块
toolbox 模块
config 模块
i18n 模块
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些模块都可以单独import使用，在beego也有相应的封装，具体使用查看文档。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>chrome的开发者工具</title>
      <link>http://kingjcy.github.io/blog/2017/06/07/chrome%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 07 Jun 2017 15:56:36 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/07/chrome%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;chrome的开发者工具在开发过程中是十分常用的，这边整理一些。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Elements: 允许我们从浏览器的角度看页面，也就是说我们可以看到chrome渲染页面所需要的的HTML、CSS和DOM(Document Object Model)对象。此外，还可以编辑这些内容更改页面显示效果；
Network: 可以看到页面向服务器请求了哪些资源、资源的大小以及加载资源花费的时间，当然也能看到哪些资源不能成功加载。此外，还可以查看HTTP的请求头，返回内容等；
Sources: 主要用来调试js；
Timeline: 提供了加载页面时花费时间的完整分析，所有事件，从下载资源到处理Javascript，计算CSS样式等花费的时间都展示在Timeline中；
Profiles: 分析web应用或者页面的执行时间以及内存使用情况；
Resources: 对本地缓存（IndexedDB、Web SQL、Cookie、应用程序缓存、Web Storage）中的数据进行确认及编辑；
Audits: 分析页面加载的过程，进而提供减少页面加载时间、提升响应速度的方案；
Console: 显示各种警告与错误信息，并且提供了shell用来和文档、开发者工具交互。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;快速编辑HTML元素&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;选择开发工具面板的Elements
在Elements下的元素编辑器中选择一个DOM元素
右击选择edit as html，然后进行编辑&lt;/p&gt;

&lt;p&gt;右击的辅助功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Add Attribute: 在标签中增加新的属性；
Force Element State: 有时候我们为页面元素添加一些动态的样式，比如当鼠标悬停在元素上时的样式，这种动态样式很难调试。我们可以使用Force Element State强制元素状态，便于调试，如下图：
![图4. 强制元素状态][4]
Edit as HTML: 以HTML形式更改页面元素；
Copy XPath: 复制XPath；
Delete Node: 删除DOM节点；
Break On: 设置DOM 断点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elements右面展示的是css属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Styles: 显示用户定义的样式，比如请求的default.css中的样式，和通过Javasript生成的样式，还有开发者工具添加的样式；
Computed: 显示开发者工具计算好的元素样式；
Event Listeners: 显示当前HTML DOM节点和其祖先节点的所有JavaScript事件监听器，这里的监听脚本可以来自Chrome的插件。可以点击右边小漏斗形状(filter)选择只显示当前节点的事件监听器。
DOM Breakpoints: 列出所有的DOM 断点；
Properties: 超级全面地列出当前选中内容的属性，不过基本很少用到。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;network&lt;/p&gt;

&lt;p&gt;请求的每个资源在Network表格中显示为一行，每个资源都有许多列的内容(如红色区块1)，不过默认情况下不是所有列都显示出来，可以右击来选择，每一个文件点击都有具体的传输过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Headers 该资源的HTTP头信息。
Preview 根据你所选择的资源类型（JSON、图片、文本）显示相应的预览。
Response 显示HTTP的Response信息。
Cookies 显示资源HTTP的Request和Response过程中的Cookies信息。
Timing 显示资源在整个请求生命周期过程中各部分花费的时间。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;快速获取curl，network获取的资源上右击copy-&amp;gt;copy as cURL&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gulp</title>
      <link>http://kingjcy.github.io/blog/2017/06/06/gulp/</link>
      <pubDate>Tue, 06 Jun 2017 10:56:22 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/06/gulp/</guid>
      <description>&lt;p&gt;编译工具gulp&lt;/p&gt;

&lt;p&gt;Gulp 是一个构建工具，一个 streaming 构建工具，一个 nodejs 写的构建工具，类似于make的工具，gulpfile.js类似于makefile由一个个task组成.可以用于很多类型工程的编译。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install —global gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但最多的是作为项目的开发依赖（devDependencies）安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install —save-dev gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建gulpfile.js文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&amp;quot;gulp&amp;quot;);
var ts = require(&amp;quot;gulp-typescript&amp;quot;);
var tsProject = ts.createProject(&amp;quot;tsconfig.json&amp;quot;);

gulp.task(&amp;quot;default&amp;quot;, function () {
    return tsProject.src()
            .pipe(tsProject())
                    .js.pipe(gulp.dest(&amp;quot;dist&amp;quot;));
                    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后直接运行gulp就默认执行default的task。&lt;/p&gt;

&lt;p&gt;也可以指定task&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般task 有 3 个参数。&lt;/p&gt;

&lt;p&gt;默认default 是方法名称，可以自定义方法名称，直接用gulp编译或者在依赖中调用。可以说这个是入口，看ts项目的时候可以重这边开始看。&lt;/p&gt;

&lt;p&gt;[‘watch’] 这是依赖的作业列表，它们是由顺序的，按数组顺序依次执行。&lt;/p&gt;

&lt;p&gt;第三个参数是成功执行完上面的依赖作业后执行的回调函数。&lt;/p&gt;

&lt;p&gt;流式处理&lt;/p&gt;

&lt;p&gt;src 是输入&lt;/p&gt;

&lt;p&gt;dest 是输出&lt;/p&gt;

&lt;p&gt;pipe 是管道的意思，也是 stream 里核心概念，也就是说：上一个的输出，是下一个的输入&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>typescript</title>
      <link>http://kingjcy.github.io/blog/2017/06/05/typescript/</link>
      <pubDate>Mon, 05 Jun 2017 15:11:46 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/05/typescript/</guid>
      <description>&lt;p&gt;ts是js的一个超集。将ts编译成js，让js更加容易书写和表达。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g typescript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tsc helloworld.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本语法&lt;/p&gt;

&lt;p&gt;基础类型&lt;/p&gt;

&lt;p&gt;布尔&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isDone: boolean = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数字:和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，Typescript还支持ECMAScript 2015中引入的二进制和八进制字面量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串:可以使用双引号（ &amp;ldquo;）或单引号（&amp;rsquo;）表示字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let name: string = &amp;quot;bob&amp;quot;;

你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式

let name: string = `Gene`;
let sentence: string = `Hello, my name is ${ name }.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. let list: number[] = [1, 2, 3];
2. let list: Array&amp;lt;number&amp;gt; = [1, 2, 3];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元组 Tuple&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Declare a tuple type
let x: [string, number];
// Initialize it
x = [&#39;hello&#39;, 10]; // OK
// Initialize it incorrectly
x = [10, &#39;hello&#39;]; // Error


当访问一个越界的元素，会使用联合类型替代：

x[3] = &#39;world&#39;; // OK, 字符串可以赋值给(string | number)类型

console.log(x[5].toString()); // OK, &#39;string&#39; 和 &#39;number&#39; 都有 toString

x[6] = true; // Error, 布尔不是(string | number)类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;枚举&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Color {Red, Green, Blue};
let c: Color = Color.Green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值&lt;/p&gt;

&lt;p&gt;任意值：可以表示任何类型的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let notSure: any 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空值&lt;/p&gt;

&lt;p&gt;声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null&lt;/p&gt;

&lt;p&gt;变量声明&lt;/p&gt;

&lt;p&gt;let和const是JavaScript里相对较新的变量声明方式。&lt;/p&gt;

&lt;p&gt;var是js中使用的变量声明的关键字，在作用域上会出现问题，所以在ts中使用let声明，const声明的变量不能改变。&lt;/p&gt;

&lt;p&gt;interface&lt;/p&gt;

&lt;p&gt;可选属性：&lt;/p&gt;

&lt;p&gt;带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。&lt;/p&gt;

&lt;p&gt;只读属性：&lt;/p&gt;

&lt;p&gt;一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:&lt;/p&gt;

&lt;p&gt;class&lt;/p&gt;

&lt;p&gt;继承&lt;/p&gt;

&lt;p&gt;我们使用 extends关键字来创建子类，有公共，私有与受保护的修饰符&lt;/p&gt;

&lt;p&gt;函数&lt;/p&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x+y; };

let myAdd: (x:number, y:number)=&amp;gt;number =
    function(x: number, y: number): number { return x+y; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块&lt;/p&gt;

&lt;p&gt;“内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”&lt;/p&gt;

&lt;p&gt;模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export形式之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 import形式之一。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module X {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;export导出，同模块内，其实就是声明，因为定义在内部的，对于当前是不可见的。&lt;/p&gt;

&lt;p&gt;import 不同模块的需要导入。&lt;/p&gt;

&lt;p&gt;每个模块都有dafaul是默认导出的，设置标记后不需要专门导出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export default XXX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若要导入一个使用了export =的模块时，必须使用TypeScript提供的特定语法import let = require(&amp;ldquo;module&amp;rdquo;)。&lt;/p&gt;

&lt;p&gt;要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。&lt;/p&gt;

&lt;p&gt;我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在 .d.ts文件里定义的。 如果你熟悉C/C++，你可以把它们当做 .h文件。&lt;/p&gt;

&lt;p&gt;在Node.js里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的 export声明来为每个模块都定义一个.d.ts文件，但最好还是写在一个大的.d.ts文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用 module关键字并且把名字用引号括起来，方便之后import。 例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node.d.ts 
declare module &amp;quot;url&amp;quot; {
    export interface Url {
        protocol?: string;
        hostname?: string;
        pathname?: string;
    }

    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以/// &lt;reference&gt; node.d.ts并且使用import url = require(&amp;ldquo;url&amp;rdquo;);加载模块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// &amp;lt;reference path=&amp;quot;node.d.ts&amp;quot;/&amp;gt;
import * as URL from &amp;quot;url&amp;quot;;
let myUrl = URL.parse(&amp;quot;http://www.typescriptlang.org&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// &amp;lt;reference path=&amp;quot;../../includes.ts&amp;quot;/&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用标签指定它的命名空间，可以是一个命名空间分割成多个文件,也可以是多个命名空间，相当于引用模块&lt;/p&gt;

&lt;p&gt;装饰器
装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>web</title>
      <link>http://kingjcy.github.io/blog/2017/06/01/web/</link>
      <pubDate>Thu, 01 Jun 2017 11:26:04 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/06/01/web/</guid>
      <description>

&lt;p&gt;JavaScript web 开发人员必须学习的 3 门语言中的一门：
HTML 定义了网页的内容
CSS 描述了网页的布局
JavaScript 网页的行为&lt;/p&gt;

&lt;p&gt;前端归根到底是生成一个html文件来给浏览器渲染展示，js只不过增加来动态交互，什么mvc框架增加了开发便捷，简单实现。&lt;/p&gt;

&lt;h2 id=&#34;js&#34;&gt;js&lt;/h2&gt;

&lt;p&gt;JavaScript代码可以直接嵌在网页的任何地方,由&lt;script&gt;&amp;hellip;&lt;/script&gt;包含的代码就是JavaScript代码，它将直接被浏览器执行。&lt;/p&gt;

&lt;p&gt;第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过&lt;script src=&#34;...&#34;&gt;&lt;/script&gt;引入这个文件&lt;/p&gt;

&lt;p&gt;当然可以在chrom的开发者工具中开发js运行来当调试查看结果。&lt;/p&gt;

&lt;p&gt;基本语法：&lt;/p&gt;

&lt;p&gt;以；结尾，不加会自动补上,最好是加上，不然你一个语句写成两行会自动分成两个语句，这样就会出问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;number&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;字符串是以单引号&amp;rsquo;或双引号&amp;rdquo;括起来的任意文本&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 &lt;code&gt;...&lt;/code&gt; 表示&lt;/p&gt;

&lt;p&gt;要把多个字符串连接起来，可以用+号连接&lt;/p&gt;

&lt;p&gt;支持下标操作，支持length，toUpperCase，toLowerCase，indexOf，substring等函数。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运算符&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JavaScript在设计时，有两种比较运算符：&lt;/p&gt;

&lt;p&gt;第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；&lt;/p&gt;

&lt;p&gt;第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。&lt;/p&gt;

&lt;p&gt;由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。&lt;/p&gt;

&lt;p&gt;另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：&lt;/p&gt;

&lt;p&gt;NaN === NaN; // false&lt;/p&gt;

&lt;p&gt;唯一能判断NaN的方法是通过isNaN()函数：&lt;/p&gt;

&lt;p&gt;isNaN(NaN); // true&lt;/p&gt;

&lt;p&gt;null表示一个“空”的值，它和0以及空字符串&amp;rdquo;不同，0是一个数值，&amp;rdquo;表示长度为0的字符串，而null表示“空”。&lt;/p&gt;

&lt;p&gt;还有一个和null类似的undefined，它表示“未定义”。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JavaScript的数组可以包括任意数据类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3.14, &#39;Hello&#39;, null, true];
arr[0]; // 返回索引为0的元素，即1
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接给Array的length赋一个新的值会导致Array大小的变化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array&lt;/p&gt;

&lt;p&gt;push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉&lt;/p&gt;

&lt;p&gt;与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置&lt;/p&gt;

&lt;p&gt;如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉&lt;/p&gt;

&lt;p&gt;sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序&lt;/p&gt;

&lt;p&gt;reverse()把整个Array的元素给掉个个，也就是反转&lt;/p&gt;

&lt;p&gt;splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); // 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]
// 只删除,不添加:
arr.splice(2, 2); // [&#39;Google&#39;, &#39;Facebook&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]
// 只添加,不删除:
arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); // 返回[],因为没有删除任何元素
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array&lt;/p&gt;

&lt;p&gt;join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3];
arr.join(&#39;-&#39;); // &#39;A-B-C-1-2-3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;javaScript的对象是一组由键-值组成的无序集合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var person = {
    name: &#39;Bob&#39;,
    age: 20,
    tags: [&#39;js&#39;, &#39;web&#39;, &#39;mobile&#39;],
    city: &#39;Beijing&#39;,
    hasCar: true,
    zipcode: null
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var xiaoming = {
    name: &#39;小明&#39;
    };
    xiaoming.age; // undefined
    xiaoming.age = 18; // 新增一个age属性
    xiaoming.age; // 18
    delete xiaoming.age; // 删除age属性
    xiaoming.age; // undefined
    delete xiaoming[&#39;name&#39;]; // 删除name属性
    xiaoming.name; // undefined
    delete xiaoming.school; // 删除一个不存在的school属性也不会报错&#39;&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a; // 申明了变量a，此时a的值为undefined
var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
var s_007 = &#39;007&#39;; // s_007是一个字符串
var Answer = true; // Answer是一个布尔值true
var t = null; // t的值是null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以隐式声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = 1；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js是一种无类型、弱检测的语言，在函数中使用var关键字进行显式申明的变量是做为局部变量，而没有用var关键字，使用直接赋值方式声明的是全局变量。&lt;/p&gt;

&lt;p&gt;在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。&lt;/p&gt;

&lt;p&gt;JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。&lt;/p&gt;

&lt;p&gt;它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部&lt;/p&gt;

&lt;p&gt;不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;条件语句&lt;/p&gt;

&lt;p&gt;var age = 20;
if (age &amp;gt;= 18) { // 如果age &amp;gt;= 18为true，则执行if语句块
    alert(&amp;lsquo;adult&amp;rsquo;);
    } else { // 否则执行else语句块
        alert(&amp;lsquo;teenager&amp;rsquo;);
        }&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;循环语句&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 0;
var i;
for (i=1; i&amp;lt;=10000; i++) {
    x = x + i;
    }
    x; // 50005000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 0;
var n = 99;
while (n &amp;gt; 0) {
    x = x + n;
    n = n - 2;
}
x; // 2500
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Map是一组键值对的结构，具有极快的查找速度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]);
m.get(&#39;Michael&#39;); // 95


var m = new Map(); // 空Map
m.set(&#39;Adam&#39;, 67); // 添加新的key-value
m.set(&#39;Bob&#39;, 59);
m.has(&#39;Adam&#39;); // 是否存在key &#39;Adam&#39;: true
m.get(&#39;Adam&#39;); // 67
m.delete(&#39;Adam&#39;); // 删除key &#39;Adam&#39;
m.get(&#39;Adam&#39;); // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重复元素在Set中自动被过滤&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s = new Set([1, 2, 3, 3, &#39;3&#39;]);
s; // Set {1, 2, 3, &amp;quot;3&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果,通过delete(key)方法可以删除元素&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;iterable&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用for &amp;hellip; of循环遍历集合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
var s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);
var m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);
for (var x of a) { // 遍历Array
    alert(x);
}
for (var x of s) { // 遍历Set
    alert(x);
}
for (var x of m) { // 遍历Map
    alert(x[0] + &#39;=&#39; + x[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.function functionName(arg0, arg1, ... argN) { statements }//function语句 
2.var function_name = new Function(arg1, arg2, ..., argN, function_body);//Function()构造函数 
3.var func = function(arg0, arg1, ... argN) { statements };//函数直接量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;p&gt;由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数&lt;/p&gt;

&lt;p&gt;JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(x) {
    alert(x); // 10
    for (var i=0; i&amp;lt;arguments.length; i++) {
        alert(arguments[i]); // 10, 20, 30
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用函数：map，reduce filter，sort&lt;/p&gt;

&lt;p&gt;JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。&lt;/p&gt;

&lt;p&gt;它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部&lt;/p&gt;

&lt;p&gt;不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性&lt;/p&gt;

&lt;p&gt;JavaScript 显示数据&lt;/p&gt;

&lt;p&gt;JavaScript 可以通过不同的方式来输出数据：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 window.alert() 弹出警告框。&lt;/p&gt;

&lt;p&gt;window.alert(5 + 6);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 document.write() 方法将内容写到 HTML 文档中。&lt;/p&gt;

&lt;p&gt;document.write(Date());&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 innerHTML 写入到 HTML 元素。&lt;/p&gt;

&lt;p&gt;document.getElementById(&amp;ldquo;demo&amp;rdquo;).innerHTML = &amp;ldquo;段落已修改。&amp;rdquo;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 console.log() 写入到浏览器的控制台。&lt;/p&gt;

&lt;p&gt;console.log&amp;copy;;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（）
是运算符&lt;/p&gt;

&lt;p&gt;（表达式）则表达式的结果将会返回&lt;/p&gt;

&lt;p&gt;（function(){&amp;hellip;}）这样就返回了一个函数&lt;/p&gt;

&lt;p&gt;但是 当 （）和函数连接在一起的时候 则表示 函数运算&lt;/p&gt;

&lt;p&gt;（function(){&amp;hellip;}）()  一前一后2个括号 就是调用里面的函数让他执行&lt;/p&gt;

&lt;p&gt;var a=a||{};这种语法一般会在初始化的时候使用意思就是:假如a要是未定义或者null的时候就赋值一个{}空对象。&lt;/p&gt;

&lt;h2 id=&#34;ts&#34;&gt;ts&lt;/h2&gt;

&lt;p&gt;typescript就是用于将编程语言转化为js脚本语言的工具，但是它是在js基础上进行了向工程性语言的一种扩张，包含了类模板等面向对象的编程。高级语言编程，用tsc编译，编译结果不是可执行程序而是js文件，然后给html使用。&lt;/p&gt;

&lt;p&gt;基本语法类似于js，在其基础上有了扩张。&lt;/p&gt;

&lt;p&gt;具体可以参考另一篇博文ts入门。&lt;/p&gt;

&lt;h2 id=&#34;nodejs&#34;&gt;nodejs&lt;/h2&gt;

&lt;p&gt;Node.js，或者 Node，是一个可以让 JavaScript 运行在服务器端的平台。它可以让 JavaScript脱离浏览器的束缚运行在的服务器环境下，也就是起到了js后端开发的作用。&lt;/p&gt;

&lt;p&gt;JavaScript 为客户端而生，Node.js 为网络而生&lt;/p&gt;

&lt;p&gt;nodejs的包管理器npm提供很多第三方框架使用，加上模块使得它更加的适合于后台编程。&lt;/p&gt;

&lt;p&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。
Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。
Node.js 的包管理器 npm，是全球最大的开源库生态系统。&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;p&gt;正常可以直接下载二进制包运行，当然也可以下载nodejs源码包编译安装，时间比较长，安装与正常源码安装步骤一样。&lt;/p&gt;

&lt;p&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。
Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。
Node.js 的包管理器 npm，是全球最大的开源库生态系统。&lt;/p&gt;

&lt;p&gt;使用淘宝 NPM 镜像&lt;/p&gt;

&lt;p&gt;大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。
淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。
你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以使用 cnpm 命令来安装模块了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install [name]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;npm init可以初始化一个npm项目。&lt;/p&gt;

&lt;h2 id=&#34;框架angularjs&#34;&gt;框架angularjs&lt;/h2&gt;

&lt;p&gt;AngularJS 是一个 JavaScript 框架。它是一个以 JavaScript 编写的库&lt;/p&gt;

&lt;p&gt;它可通过 &lt;script&gt; 标签添加到 HTML 页面。
AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指令：AngularJS 指令是以 ng 作为前缀的 HTML 属性。&lt;/p&gt;

&lt;p&gt;ng-app 指令定义一个 AngularJS 应用程序。
ng-model 指令把元素值（比如输入域的值）绑定到应用程序。
ng-bind 指令把应用程序数据绑定到 HTML 视图。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

 &amp;lt;div ng-app=&amp;quot;&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;名字 : &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
           &amp;lt;h1&amp;gt;Hello {{name}}&amp;lt;/h1&amp;gt;
           &amp;lt;/div&amp;gt;

            &amp;lt;/body&amp;gt;
            &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当网页加载完毕，AngularJS 自动开启。
ng-app 指令告诉 AngularJS，&lt;div&gt; 元素是 AngularJS 应用程序 的&amp;rdquo;所有者&amp;rdquo;。
ng-model 指令把输入域的值绑定到应用程序变量 name。
ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。&lt;/p&gt;

&lt;p&gt;ng-init 指令初始化 AngularJS 应用程序变量。&lt;/p&gt;

&lt;p&gt;ng-click 指令告诉了 AngularJS HTML 元素被点击后需要执行的操作，ng-init初始化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button ng-click=&amp;quot;count = count + 1&amp;quot; ng-init=&amp;quot;count=0&amp;quot;&amp;gt;OK&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ng-hide 指令在表达式为 true 时隐藏 HTML 元素，ng-show显示，和hide相反。&lt;/p&gt;

&lt;p&gt;ng-href 指令覆盖了原生的 &lt;a&gt; 元素 href 属性。如果在 href 的值中有 AngularJS 代码，则需要使用 ng-href 而不是 href。ng-href 指令确保了链接是正常的，即使在 AngularJS 执行代码前点击链接。&lt;/p&gt;

&lt;p&gt;ng-if 指令用于在表达式为 false 时移除 HTML 元素。如果 if 语句执行的结果为 true，会添加移除元素，并显示。ng-if 指令不同于 ng-hide， ng-hide 隐藏元素，而 ng-if 是从 DOM 中移除元素。&lt;/p&gt;

&lt;p&gt;ng-repeat 指令用于循环输出指定次数的 HTML 元素。ng-repeat 指令是通过数组来循环 HTML 代码来创建下拉列表，但 ng-options 指令更适合创建下拉列表，它有以下优势：
使用 ng-options 的选项的一个对象， ng-repeat 是一个字符串。ng-repeat 指令可以完美的显示表格。&lt;/p&gt;

&lt;p&gt;ngView 指令&lt;/p&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-view&amp;gt;&amp;lt;/div&amp;gt;
该 div 内的 HTML 内容会根据路由的变化而变化。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建自定义的指令&lt;/p&gt;

&lt;p&gt;除了 AngularJS 内置的指令外，我们还可以创建自定义指令。
你可以使用 .directive 函数来添加自定义的指令。
要调用自定义指令，HTML 元素上需要添加自定义指令名。
使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body ng-app=&amp;quot;myApp&amp;quot;&amp;gt;

&amp;lt;runoob-directive&amp;gt;&amp;lt;/runoob-directive&amp;gt;

&amp;lt;script&amp;gt;
var app = angular.module(&amp;quot;myApp&amp;quot;, []);
app.directive(&amp;quot;runoobDirective&amp;quot;, function() {
    return {
        template : &amp;quot;&amp;lt;h1&amp;gt;自定义指令!&amp;lt;/h1&amp;gt;&amp;quot;
    };
});
&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AngularJS 表达式&lt;/p&gt;

&lt;p&gt;AngularJS 表达式写在双大括号内：{{ expression }}。
AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。
AngularJS 将在表达式书写的位置&amp;rdquo;输出&amp;rdquo;数据。
AngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。
实例 {{ 5 + 5 }} 或 {{ firstName + &amp;ldquo; &amp;rdquo; + lastName }}&lt;/p&gt;

&lt;p&gt;AngularJS 模块（Module） 定义了 AngularJS 应用。
AngularJS 控制器（Controller） 用于控制 AngularJS 应用。
ng-app指令定义了应用, ng-controller 定义了控制器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; 
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;p&amp;gt;尝试修改以下表单。&amp;lt;/p&amp;gt;

&amp;lt;div ng-app=&amp;quot;myApp&amp;quot; ng-controller=&amp;quot;myCtrl&amp;quot;&amp;gt;

名: &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;firstName&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
姓: &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;lastName&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;br&amp;gt;
姓名: {{firstName + &amp;quot; &amp;quot; + lastName}}

&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
var app = angular.module(&#39;myApp&#39;, []);      //angular的模块引用
app.controller(&#39;myCtrl&#39;, function($scope) { //angular的控制器引用
    $scope.firstName= &amp;quot;John&amp;quot;;
    $scope.lastName= &amp;quot;Doe&amp;quot;;
});
&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AngularJS 控制器&lt;/p&gt;

&lt;p&gt;ng-controller 指令定义了应用程序控制器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-app=&amp;quot;myApp&amp;quot; ng-controller=&amp;quot;myCtrl&amp;quot;&amp;gt;

名: &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;firstName&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
姓: &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;lastName&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;br&amp;gt;
姓名: {{firstName + &amp;quot; &amp;quot; + lastName}}

&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;myCtrl&#39;, function($scope) {
    $scope.firstName = &amp;quot;John&amp;quot;;
    $scope.lastName = &amp;quot;Doe&amp;quot;;
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AngularJS 应用程序由 ng-app 定义。应用程序在 &lt;div&gt; 内运行。&lt;/p&gt;

&lt;p&gt;ng-controller=&amp;ldquo;myCtrl&amp;rdquo; 属性是一个 AngularJS 指令。用于定义一个控制器。&lt;/p&gt;

&lt;p&gt;myCtrl 函数是一个 JavaScript 函数。&lt;/p&gt;

&lt;p&gt;AngularJS 使用$scope 对象来调用控制器。&lt;/p&gt;

&lt;p&gt;在 AngularJS 中， $scope 是一个应用对象(属于应用变量和函数)。&lt;/p&gt;

&lt;p&gt;控制器的 $scope （相当于作用域、控制范围）用来保存AngularJS Model(模型)的对象。&lt;/p&gt;

&lt;p&gt;控制器在作用域中创建了两个属性 (firstName 和 lastName)。&lt;/p&gt;

&lt;p&gt;ng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。&lt;/p&gt;

&lt;p&gt;外部调用，既要降script写成js文件进行调用就好。&lt;/p&gt;

&lt;p&gt;AngularJS 的controller其实就是一个方法，它有三种写法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;pre name=&#34;code&#34; class=&#34;javascript&#34;&gt;var AppController = [&amp;lsquo;$scope&amp;rsquo;, function($scope){&lt;br /&gt;
     $scope.notifyServiceOnChage = function(){&lt;br /&gt;
     console.log($scope.windowHeight);&lt;br /&gt;
  };&lt;br /&gt;
}];&lt;br /&gt;
app.controller(&amp;lsquo;AppController&amp;rsquo;,AppController);&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在定义AppController的时候，先声明方法需要注入的参数，然后再定义方法体。最后将AppController绑定到app上。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;app.controller(&amp;lsquo;AppController&amp;rsquo;, function($scope){&lt;br /&gt;
    $scope.notifyServiceOnChage = function(){&lt;br /&gt;
     console.log($scope.windowHeight);&lt;br /&gt;
  };&lt;br /&gt;
})&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;直接在app的controller属性定义，首先是controller名字，然后是方法体。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接写方法，然后在ng-controller引用该方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;var app=angular.module(&amp;ldquo;myApp&amp;rdquo;,[]);
app.controller(&amp;ldquo;myController&amp;rdquo;,[&amp;lsquo;$scope&amp;rsquo;,&amp;lsquo;aService&amp;rsquo;,&amp;hellip;,function($scope,aService,&amp;hellip;){
    //可以注入你写的factory，provider等等
}]);&lt;/p&gt;

&lt;p&gt;controller第一个参数是名称，后面是一个数组，数组的前面是声明注入的内容，可以是n个，最后是个function，function的参数个数也必须是n个，必须跟前面声明注入的内容一一对应，这样实现了依赖注入。&lt;/p&gt;

&lt;p&gt;Scope(作用域)&lt;/p&gt;

&lt;p&gt;Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。
Scope 是一个对象，有可用的方法和属性。
Scope 可应用在视图和控制器上。&lt;/p&gt;

&lt;p&gt;根作用域
所有的应用都有一个 $rootScope，它可以作用在 ng-app 指令包含的所有 HTML 元素中。
$rootScope 可作用于整个应用中。是各个 controller 中 scope 的桥梁。用 rootscope 定义的值，可以在各个 controller 中使用。&lt;/p&gt;

&lt;p&gt;AngularJS 过滤器&lt;/p&gt;

&lt;p&gt;过滤器可以使用一个管道字符（|）添加到表达式和指令中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;currency    格式化数字为货币格式。
filter  从数组项中选择一个子集。
lowercase   格式化字符串为小写。
orderBy 根据某个表达式排列数组。
uppercase   格式化字符串为大写。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义过滤器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;myCtrl&#39;, function($scope) {
    $scope.msg = &amp;quot;Runoob&amp;quot;;
});
app.filter(&#39;reverse&#39;, function() { //可以注入依赖
    return function(text) {
        return text.split(&amp;quot;&amp;quot;).reverse().join(&amp;quot;&amp;quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务(Service)&lt;/p&gt;

&lt;p&gt;AngularJS 中你可以创建自己的服务，或使用内建服务。&lt;/p&gt;

&lt;p&gt;$location 服务，它可以返回当前页面的 URL 地址。&lt;/p&gt;

&lt;p&gt;$http 是 AngularJS 应用中最常用的服务。 服务向服务器发送请求，应用响应服务器传送过来的数据。&lt;/p&gt;

&lt;p&gt;$timeout 服务对应了 JS window.setTimeout 函数&lt;/p&gt;

&lt;p&gt;$interval 服务对应了 JS window.setInterval 函数。&lt;/p&gt;

&lt;p&gt;创建自定义服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.service(&#39;hexafy&#39;, function() {
    this.myFunc = function (x) {
        return x.toString(16);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AngularJS 路由&lt;/p&gt;

&lt;p&gt;主要是使用 ngRoute 模块，引入angularjs的提供的模块js文件。&lt;/p&gt;

&lt;p&gt;访问&lt;a href=&#34;http://runoob.com/#/first&#34;&gt;http://runoob.com/#/first&lt;/a&gt; 向服务端请的地址都是一样的 (&lt;a href=&#34;http://runoob.com/)。#号之后的内容在向服务端请求时会被浏览器忽略掉。&#34;&gt;http://runoob.com/)。#号之后的内容在向服务端请求时会被浏览器忽略掉。&lt;/a&gt; 所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由 就通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。&lt;/p&gt;

&lt;p&gt;AngularJS $routeProvider 用来定义路由规则。&lt;/p&gt;

&lt;p&gt;语法规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$routeProvider.when(url, {
    template: string,
    templateUrl: string,
    controller: string, function 或 array,
    controllerAs: string,
    redirectTo: string, function,
    resolve: object&amp;lt;key, function&amp;gt;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;template:&lt;/p&gt;

&lt;p&gt;如果我们只需要在 ng-view 中插入简单的 HTML 内容，则使用该参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.when(&#39;/computers&#39;,{template:&#39;这是电脑分类页面&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;templateUrl:&lt;/p&gt;

&lt;p&gt;如果我们只需要在 ng-view 中插入 HTML 模板文件，则使用该参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$routeProvider.when(&#39;/computers&#39;, {
    templateUrl: &#39;views/computers.html&#39;,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;controller:&lt;/p&gt;

&lt;p&gt;function、string或数组类型，在当前模板上执行的controller函数，生成新的scope。&lt;/p&gt;

&lt;p&gt;controllerAs:&lt;/p&gt;

&lt;p&gt;string类型，为controller指定别名。&lt;/p&gt;

&lt;p&gt;redirectTo:&lt;/p&gt;

&lt;p&gt;重定向的地址。&lt;/p&gt;

&lt;p&gt;resolve:&lt;/p&gt;

&lt;p&gt;指定当前controller所依赖的其他模块。&lt;/p&gt;

&lt;p&gt;AngularJS 依赖注入&lt;/p&gt;

&lt;p&gt;五种组件：&lt;/p&gt;

&lt;p&gt;value&lt;/p&gt;

&lt;p&gt;Value 是一个简单的 javascript 对象，用于向控制器传递值（配置阶段）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 定义一个模块
var mainApp = angular.module(&amp;quot;mainApp&amp;quot;, []);

// 创建 value 对象 &amp;quot;defaultInput&amp;quot; 并传递数据
mainApp.value(&amp;quot;defaultInput&amp;quot;, 5);

// 将 &amp;quot;defaultInput&amp;quot; 注入到控制器
mainApp.controller(&#39;CalcController&#39;, function($scope, CalcService, defaultInput) {
   $scope.number = defaultInput;
   $scope.result = CalcService.square($scope.number);

   $scope.square = function() {
      $scope.result = CalcService.square($scope.number);
   }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;factory&lt;/p&gt;

&lt;p&gt;通常我们使用 factory 函数来计算或返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 定义一个模块
var mainApp = angular.module(&amp;quot;mainApp&amp;quot;, []);

// 创建 factory &amp;quot;MathService&amp;quot; 用于两数的乘积 provides a method multiply to return multiplication of two numbers
mainApp.factory(&#39;MathService&#39;, function() {
   var factory = {};

   factory.multiply = function(a, b) {
      return a * b
   }
   return factory;
}); 

// 在 service 中注入 factory &amp;quot;MathService&amp;quot;
mainApp.service(&#39;CalcService&#39;, function(MathService){
   this.square = function(a) {
      return MathService.multiply(a,a);
   }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;service
provider&lt;/p&gt;

&lt;p&gt;AngularJS 中通过 provider 创建一个 service、factory等(配置阶段)。
Provider 中提供了一个 factory 方法 get()，它用于返回 value/service/factory。&lt;/p&gt;

&lt;p&gt;// 定义一个模块
var mainApp = angular.module(&amp;ldquo;mainApp&amp;rdquo;, []);
&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 使用 provider 创建 service 定义一个方法用于计算两数乘积
mainApp.config(function($provide) {
   $provide.provider(&#39;MathService&#39;, function() {
      this.$get = function() {
         var factory = {};  

         factory.multiply = function(a, b) {
            return a * b; 
         }
         return factory;
      };
   });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;constant&lt;/p&gt;

&lt;p&gt;constant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。&lt;/p&gt;

&lt;p&gt;mainApp.constant(&amp;ldquo;configParam&amp;rdquo;, &amp;ldquo;constant value&amp;rdquo;);&lt;/p&gt;

&lt;h2 id=&#34;html&#34;&gt;html&lt;/h2&gt;

&lt;p&gt;超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;页面标题&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;这是一个标题&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;这是一个段落。&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;这是另外一个段落。&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有body部分会在浏览器上显示出来。&lt;/p&gt;

&lt;p&gt;属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTML 元素可以设置属性
属性可以在元素中添加附加信息
属性一般描述于开始标签
属性总是以名称/值对的形式出现，比如：name=&amp;quot;value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;  html5标准网页声明&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有的HTML文档都应该有一个&lt;html&gt;标签，&lt;html&gt;标签可以包含两个部分:&lt;head&gt;和&lt;body&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常用标签&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;font&gt; 改变字体，字号，文字颜色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;font size=&amp;quot;6&amp;quot;&amp;gt;6&amp;lt;/font&amp;gt; 
&amp;lt;font size=&amp;quot;4&amp;quot;&amp;gt;4&amp;lt;/font&amp;gt; 
&amp;lt;font color=&amp;quot;red&amp;quot; size=&amp;quot;5&amp;quot;&amp;gt;红色的5&amp;lt;/font&amp;gt; 
&amp;lt;font face=&amp;quot;黑体&amp;quot;&amp;gt;黑体的字&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加粗，下划线，斜体字也是常用的文字效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;b&amp;gt;Bold&amp;lt;/b&amp;gt; 
&amp;lt;i&amp;gt;italic&amp;lt;/i&amp;gt; 
&amp;lt;u&amp;gt;underline&amp;lt;/u&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 这是一个注释 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标题的标签&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;,&amp;lt;h2&amp;gt;,&amp;lt;h3&amp;gt;,&amp;lt;h4&amp;gt;,&amp;lt;h5&amp;gt;,&amp;lt;h6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;hr&gt;标签用于在页面上添加横线&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;hr width=&amp;quot;90%&amp;quot; color=&amp;quot;red&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img&gt;标签用于在页面上添加图片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;/Icons/valid-xhtml10&amp;quot; alt=&amp;quot;图片简介&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a&gt;链接，href属性指定了链接到的地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;http://deerchao.net&amp;quot;&amp;gt;Unibetter大学生论坛&amp;lt;/a&amp;gt; 
&amp;lt;a href=&amp;quot;http://validator.w3.org&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;/Icons/valid-xhtml10&amp;quot; alt=&amp;quot;验证HTML&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分段与换行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;这是第一段。&amp;lt;/p&amp;gt; 
&amp;lt;p&amp;gt;这是第二段。&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;标签专门用于标明不同的部分  块，可以用于布局。

    &lt;div&gt;页头内容&lt;/div&gt; &lt;div&gt;主体内容&lt;/div&gt; &lt;div&gt;页脚内容&lt;/div&gt;

&lt;p&gt;&lt;table&gt; 表示html表格。标签里通常会包含几个&lt;tr&gt;标签，&lt;tr&gt;代表表格里的一行。&lt;tr&gt;标签又会包含&lt;td&gt;标签，每个&lt;td&gt;代表一个单元格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;tr&amp;gt; 元素定义表格行，&amp;lt;th&amp;gt; 元素定义表头，&amp;lt;td&amp;gt; 元素定义表格单元
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;html全局属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;accesskey   规定激活元素的快捷键。
class   规定元素的一个或多个类名（引用样式表中的类）。
contenteditable 规定元素内容是否可编辑。
contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示。
data-*  用于存储页面或应用程序的私有定制数据。
dir 规定元素中内容的文本方向。
draggable   规定元素是否可拖动。
dropzone    规定在拖动被拖动数据时是否进行复制、移动或链接。
hidden  规定元素仍未或不再相关。
id  规定元素的唯一 id。
lang    规定元素内容的语言。
spellcheck  规定是否对元素进行拼写和语法检查。
style   规定元素的行内 CSS 样式。
tabindex    规定元素的 tab 键次序。
title   规定有关元素的额外信息。
translate   规定是否应该翻译元素内容。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签&lt;/p&gt;

&lt;p&gt;input   &lt;input&gt; 标签规定了用户可以在其中输入数据的输入字段。&lt;input&gt; 元素在 &lt;form&gt; 元素中使用，用来声明允许用户输入数据的 input 控件。输入字段可通过多种方式改变，取决于 type 属性。&lt;/p&gt;

&lt;p&gt;一个简单的 HTML 表单，包含两个文本输入框和一个提交按钮：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;form_action.asp&amp;quot; method=&amp;quot;get&amp;quot;&amp;gt;
First name: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;fname&amp;quot; /&amp;gt;
Last name: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;lname&amp;quot; /&amp;gt;
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用属性：type 控件类型， name 控件名称 value 控件默认值&lt;/p&gt;

&lt;p&gt;br   换行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用 br 元素&amp;lt;br&amp;gt;在文本中&amp;lt;br&amp;gt;换行。

使用 br 元素
在文本中
换行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ul和li  无序 HTML 列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Coffee&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Tea&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Milk&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

Coffee
Tea
Milk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;script  用于定义客户端脚本,正常js&lt;/p&gt;

&lt;p&gt;a   标签定义超链接，用于从一个页面链接到另一个页面，最重要的属性是 href 属性，它指定链接的目标。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;http://www.runoob.com&amp;quot;&amp;gt;访问菜鸟教程!&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;p  定义段落&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;这是一个段落。&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pre  可定义预格式化的文本。被包围在 &lt;pre&gt; 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 用于对文档中的行内元素进行操作，提供了一种将文本的一部分或者文档的一部分独立出来的方式。&lt;/p&gt;

&lt;p&gt;&lt;i&gt; 定义与文本中其余部分不同的部分，并把这部分文本呈现为斜体文本。&lt;/p&gt;

&lt;p&gt;dl,dt,dd   带有项目和描述的描述列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dl&amp;gt;
  &amp;lt;dt&amp;gt;Coffee&amp;lt;/dt&amp;gt;
    &amp;lt;dd&amp;gt;Black hot drink&amp;lt;/dd&amp;gt;
  &amp;lt;dt&amp;gt;Milk&amp;lt;/dt&amp;gt;
    &amp;lt;dd&amp;gt;White cold drink&amp;lt;/dd&amp;gt;
&amp;lt;/dl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;button&gt; 标签定义一个按钮。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button type=&amp;quot;button&amp;quot;&amp;gt;点我!&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;label   &lt;label&gt; 标签为 input 元素定义标注（标记）。&lt;/p&gt;

&lt;p&gt;head&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt; 元素是所有头部元素的容器。
&amp;lt;head&amp;gt; 元素必须包含文档的标题（title），可以包含脚本、样式、meta 信息 以及其他更多的信息。
以下列出的元素能被用在 &amp;lt;head&amp;gt; 元素内部：
&amp;lt;title&amp;gt; （在头部中，这个元素是必需的）定义HTML文档的标题
&amp;lt;style&amp;gt;
&amp;lt;base&amp;gt;    定义页面中所有链接默认的链接目标地址。
&amp;lt;link&amp;gt;
&amp;lt;meta&amp;gt;    描述HTML文档的描述，关键词，作者，字符集等
&amp;lt;script&amp;gt;
&amp;lt;noscript&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;meta&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;元数据（Metadata）是数据的数据信息。
&amp;lt;meta&amp;gt; 标签提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。
META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。
元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;link&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link&amp;gt; 标签定义文档与外部资源的关系。
&amp;lt;link&amp;gt; 标签最常见的用途是链接样式表。

&amp;lt;head&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;theme.css&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;表单是一个包含表单元素的区域。
表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。
表单使用表单标签 &lt;form&gt; 来设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form&amp;gt;
.
input 元素
.
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mac os</title>
      <link>http://kingjcy.github.io/blog/2017/05/24/mac-os/</link>
      <pubDate>Wed, 24 May 2017 16:21:43 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/05/24/mac-os/</guid>
      <description>&lt;p&gt;这边主要是记录在使用mac os中的一些常用的东西。mac os和linux有这个很多相同的东西，可以互相学习&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;界面安装软件必须要加入到应用程序中才能和mac os系统中的环境变量一致，liteide的环境变量设置由于没有加入(直接图标拖入应用程序就好)到应用程序中导致环境变量一直无法修改，折腾了好半天才发现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;brew很重要，类似于linux中的yum，rpm。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>go积累</title>
      <link>http://kingjcy.github.io/blog/2017/05/23/go%E7%A7%AF%E7%B4%AF/</link>
      <pubDate>Tue, 23 May 2017 14:54:09 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/05/23/go%E7%A7%AF%E7%B4%AF/</guid>
      <description>&lt;p&gt;学习使用go语言已经有一段时间了，积累了很多的经验，这边进行整理并持续积累，也便于后期的备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;每个 Go 程序都是由包组成的。&lt;/p&gt;

&lt;p&gt;程序运行的入口是包 &lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;go自己的设计哲学：
1、不得包含源代码文件中没有用到的包
2、函数的左括号{位置
3、函数名大小写规则
4、不一定要用分号结束语句
package的名称必须和目录名保持一致&lt;/p&gt;

&lt;p&gt;Go语言的工作空间结构：
Go语言的工作空间其实就是一个文件目录，目录中必须包含src、pkg、bin三个目录。&lt;/p&gt;

&lt;p&gt;其中src目录用于存放Go源代码，pkg目录用于package对象，bin目录用于存放可执行对象
&amp;ndash;对应的环境变量的搭建&amp;ndash;
go命名行用到了GOPATH环境变量，在这个目录下收索
export GOPATH=你的工作空间路径
export PATH=$PATH:$GOPATH/bin&amp;mdash;-安装用这个路劲&lt;/p&gt;

&lt;p&gt;编译：build&lt;/p&gt;

&lt;p&gt;安装：
1、只要进入对应的应用包目录，然后执行go install，就可以安装了&lt;/p&gt;

&lt;p&gt;2、在任意的目录执行如下代码go install mymath&lt;/p&gt;

&lt;p&gt;go命令行工具
run:&lt;/p&gt;

&lt;p&gt;build:
1.如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install了。&lt;/p&gt;

&lt;p&gt;2.如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。&lt;/p&gt;

&lt;p&gt;3.如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。&lt;/p&gt;

&lt;p&gt;clean:
清除编译文件&lt;/p&gt;

&lt;p&gt;fmt：
格式化文件&lt;/p&gt;

&lt;p&gt;get：
动态获取远程代码包&lt;/p&gt;

&lt;p&gt;install：
这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin&lt;/p&gt;

&lt;p&gt;test：
自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件&lt;/p&gt;

&lt;p&gt;go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1
 go version 查看go当前的版本
go env 查看当前go的环境变量
go list 列出当前全部安装的package
 go run 编译并运行Go程序&lt;/p&gt;

&lt;p&gt;标准库：
bufio   带缓冲的io&lt;/p&gt;

&lt;p&gt;io&lt;/p&gt;

&lt;p&gt;fmt   基本输出输入&lt;/p&gt;

&lt;p&gt;Net/http.    http包提供了HTTP客户端和服务端的实现。&lt;/p&gt;

&lt;p&gt;strconv 类型转换 Itoa  Atoi&lt;/p&gt;

&lt;p&gt;time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//返回现在时间  
tNow := time.Now()  
//时间转化为string，layout必须为 &amp;quot;2006-01-02 15:04:05&amp;quot;  
timeNow := tNow.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)  
fmt.Println(&amp;quot;tNow(time format):&amp;quot;, tNow)  
fmt.Println(&amp;quot;tNow(string format):&amp;quot;, timeNow)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;make（）
make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。
//创建一个初始元素个数为5的数组切片，元素初始值为0
 a := make([]int, 5)  // len(a)=5&lt;/p&gt;

&lt;p&gt;1、变量
用关键字var来声明&lt;/p&gt;

&lt;p&gt;可以直接用:=这个服务声明初始化，但必须不是声明过的。
a := 10类似于var i int
        i = 10；
&lt;code&gt;:=&lt;/code&gt; 结构不能使用在函数外。&lt;/p&gt;

&lt;p&gt;支持多重赋值
i，j = j，i这样就完成了交换。&lt;/p&gt;

&lt;p&gt;支持匿名变量
func getname（）（firstname,lastname,nickname）{
}
&amp;mdash;&amp;gt;&lt;em&gt;,&lt;/em&gt;,nickname := getname();可以这样玩&lt;/p&gt;

&lt;p&gt;2、常量：
iota 一个特殊的常量，出现一次自动加一，当出现const的时候会自动置零
常量不能使用 := 语法定义&lt;/p&gt;

&lt;p&gt;枚举类型不需要enum
正常定义
const（
    Sunday = iota
    monday
)
其中的大写字母开头的在包外可用，小写字母开头的包内私有&lt;/p&gt;

&lt;p&gt;3、数组
1、主要是值类型，每次传参都是一个副本，要传址，需要用数组切片
2、遍历数组元素，除了用下标，也可以用关键字range，有两个返回值，一个是下标，一个是value,在对strings进行遍历的时候一个是下表，一个是ASII&lt;/p&gt;

&lt;p&gt;var a [10]int&lt;/p&gt;

&lt;p&gt;var a = [10]int{0,1,2,3,4,5,6,7,8,9}&lt;br /&gt;
var a = [&amp;hellip;]int{0,1,2,3,4,5,6,7,8,9}&lt;/p&gt;

&lt;p&gt;var a = [2][2]int{[2]int{1,1}, [2]int{2,2}}&lt;br /&gt;
var a = [2][2]int{{1,1}, {2,2}}&lt;/p&gt;

&lt;p&gt;数组切片
创建：1、在一个数组的基础上用[:]来创建
    2、直接用make函数创建
创建一个初始元素个数为5的数组切片，元素初始值为0：
mySlice1 := make([] int, 5)
创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：
mySlice2 := make([] int, 5, 10)
直接创建并初始化包含5个元素的数组切片：
mySlice3 := [] int{1, 2, 3, 4, 5}&lt;/p&gt;

&lt;p&gt;cap():分配的空间
len()：所占的元素
copy()：复制，以小的为准&lt;/p&gt;

&lt;p&gt;优点：可以动态增减元素，原始数组增减数据是要重新分配内存，然后将数据搬过去，这样比较消耗性能，但是数据切片则可以用cap（）知道分配的空间，然后充分利用，而后在内存不够会自动扩大内存。&lt;/p&gt;

&lt;p&gt;map[key] = value
定义 var a map[string]value&lt;/p&gt;

&lt;p&gt;4、控制语句：
顺序if条件中初始化的变量可以在else中使用，选择，循环(支持for，不支持while和do_while)，goto语句&amp;mdash;》跳到标志位&lt;/p&gt;

&lt;p&gt;5、函数：
关键字func、函数名、参数列表、返回值、函数体和返回语句。
func Add(a int, b int) (ret int, err error) {
}&lt;/p&gt;

&lt;p&gt;函数调用：
因此需要先牢记这样的规则：小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用。
n, err := Foo(0)
if err != nil {
 // 错误处理
} else {
 // 使用返回值n
}&lt;/p&gt;

&lt;p&gt;不定参数：传入参数的数量不变
语法糖：&amp;hellip;type
func myfunc(args &amp;hellip; int) {
}
如果是不同的类型则用interface{}
func myfunc(args &amp;hellip; interface{}) {
}&lt;/p&gt;

&lt;p&gt;如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice&amp;hellip;)。
nums := []int{1, 2, 3, 4}
myfunc(noms…)&lt;/p&gt;

&lt;p&gt;多返回值
支持匿名函数&amp;mdash;闭包？？？&lt;/p&gt;

&lt;p&gt;6、错误处理
error接口
关键字defer
defer 语句会延迟函数的执行直到上层函数返回。
两个函数panic，recover&lt;/p&gt;

&lt;p&gt;面向对象：&amp;mdash;很直接，没有隐藏this指针
func (a Integer) Less(b Integer) bool { // 面向对象
return a &amp;lt; b
}
func Integer_Less(a Integer, b Integer) bool { // 面向过程
return a &amp;lt; b
}
a.Less(2) // 面向对象的用法
Integer_Less(a, 2) // 面向过程的用法&lt;/p&gt;

&lt;p&gt;STRUCT基本和c差不多，也有继承采取了组合的文法&amp;ndash;通过结构体继承，没有private，public关键字来保护，而是通过字母大小写来，
初始化常用方法：
rect1 := new(Rect)
rect2 := &amp;amp;Rect{}
rect3 := &amp;amp;Rect{0, 0, 100, 200}
rect4 := &amp;amp;Rect{width: 100, height: 200}&lt;/p&gt;

&lt;p&gt;未显式初始化的都是对应的零值
构造函数用一个全局函数NEWXXXX来表示
func NewRect(x, y, width, height float64) *Rect {
 return &amp;amp;Rect{x, y, width, height}
}&lt;/p&gt;

&lt;p&gt;最重要的就是接口interface（是any类型）的改造-非侵入式的.&amp;mdash;可以完成包与包之间的调用，或者同一个包内部的调用
interface是一组method的组合，我们通过interface来定义对象的一组行为。实现interface中的所有方法的类就是实现了这个接口，可以调用这个接口以及这个接口中的方法。interface中的方法不能重载。
空的interface可以存储任意类型的值。&lt;/p&gt;

&lt;p&gt;并发：不要通过共享内存来通信，而应该通过通信来共享内存。
多进程&amp;mdash;&amp;mdash;-开销太大，都是基于内核的调用
多线程&amp;mdash;&amp;mdash;-相对开销小，但是远远达不到需求，最多并发1万这样
基于回调的非阻塞/异步io&amp;mdash;-共享内存式的同步异步，导致编程相当复杂
协程&amp;mdash;-轻量级线程，轻松达到100w的并发&lt;/p&gt;

&lt;p&gt;所以在协程的基础上，go支持在语言上实现协程并发goroutine，goroutine类似于进程，各个协程之间互不干涉，通过channel通信控制，这样减少了很多的复杂问题，所以goroutine重点：
关键字go&amp;mdash;&amp;ndash;只要在执行体前加上关键字go就能实现协程并发
消息通信channel&amp;mdash;&amp;ndash;不同的协程之间，通过消息channel通信&lt;/p&gt;

&lt;p&gt;channel：关键字chan
声明var ch chan int
var m map[ string] chan bool
ch := make( chan int)
c := make( chan int, 1024)&amp;ndash;带缓冲的channel，后面的参数是缓冲大小
c := make( []chan int, 1024)&amp;ndash;这个是是数组&lt;/p&gt;

&lt;p&gt;写 ch &amp;lt;- 1     向channel写入数据通常会导致程序阻塞，直到有其他goroutine从这个channel中读取数据
读 value := &amp;lt;-ch    如果channel之前没有写入数据，那么从channel中读取数据也会导致程序阻塞，直到channel中被写入数据为止——这两点可以用于数据同步。&lt;/p&gt;

&lt;p&gt;select {
 case &amp;lt;-chan1:
 // 如果chan1成功读到数据，则进行该case处理语句
 case chan2 &amp;lt;- 1:
 // 如果成功向chan2写入数据，则进行该case处理语句
default:
 // 如果上面都没有成功，则进入default处理流程
}&amp;mdash;-超时机制也是用select来实现的&lt;/p&gt;

&lt;p&gt;单向channel：
var ch1 chan int // ch1是一个正常的 channel，不是单向的
var ch2 chan&amp;lt;- float64// ch2是单向channel，只用于写float64数据
var ch3 &amp;lt;-chan int // ch3 是单向channel，只用于读取int数据&lt;/p&gt;

&lt;p&gt;ch4 := make( chan int)
ch5 := &amp;lt;-chan int(ch4) // ch5就是一个单向的读取channel
ch6 := chan&amp;lt;- int(ch4) // ch6 是一个单向的写入channel&lt;/p&gt;

&lt;p&gt;关闭close（）&amp;mdash;-x, ok := &amp;lt;-ch，可以通过ok来判断channel是否关闭，一个非空的通道也是可以关闭的，但是通道中剩下的值仍然可以被接收到。&lt;/p&gt;

&lt;p&gt;go并发也提供锁机制Mutex和RWMutex
var l sync.Mutex
func foo() {
 l.Lock()
 defer l.Unlock()
 //&amp;hellip;
}&lt;/p&gt;

&lt;p&gt;全局唯一性操作
var once sync.Once&lt;/p&gt;

&lt;p&gt;time&lt;/p&gt;

&lt;p&gt;time.Duration（时长，耗时）
time.Time（时间点）
time.C（放时间点的管道）[ Time.C:=make(chan time.Time) ]&lt;/p&gt;

&lt;p&gt;方法
定时器time—sleep，after（time.Duration）多长时间后执行，一个阻塞一个非阻塞
打点器tick（time.Duration）每隔多长时间执行一次
time.Now()当前时间
可以哟过sub，add加减
定时器和打点器可以实现速率控制&lt;/p&gt;

&lt;p&gt;排序：sort包
常用方法：
排序字符串sort.Strings()
排序int。sort.Ints()
是否排序好。sort.IntsAreSorted(ints）
可以自定义排序实现sort.Interface中的方法，然后可以用sort方法自定义排序。&lt;/p&gt;

&lt;p&gt;Panic处理意外的错误。&lt;/p&gt;

&lt;p&gt;golang中包的理解
定义：
关键字 package XXXX&lt;/p&gt;

&lt;p&gt;我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。&lt;/p&gt;

&lt;p&gt;Go标准库中的包对应的源码部分路径在：$GOROOT/src，而标准库中包编译后的.a文件路径在$GOROOT/pkg/darwin_amd64下。&lt;/p&gt;

&lt;p&gt;执行go install libproj1/foo，Go编译器编译foo包，并将foo.a安装到$GOPATH/pkg/darwin_amd64/libproj1下&amp;mdash;不用先go build然后在go install&lt;/p&gt;

&lt;p&gt;因此我们要依赖第三方包，就必须搞到第三方包的源码，这也是Golang包管理的一个特点&lt;/p&gt;

&lt;p&gt;编译main包时，编译器到底用的是.a还是源码？&amp;mdash;-在使用第三方包的时候，当源码和.a均已安装的情况下，编译器链接的是源码。
最根本的是链接的是链接了以该最新源码编译的临时目录下的.a文件，而不是pkg下面的.a文件。&amp;mdash;如果想依赖pkg下面的.a文件，那只能分布编译了，把6l链接时的-L $WORK 去掉，才会找到pkg下面（具体参考-X -V参数的编译原理）&lt;/p&gt;

&lt;p&gt;标志库也是依赖源码编译产生的临时目录下的.a文件，但是当标准库的源码发生变化时，编译器不会尝试重新编译&amp;ndash;但是第三方库发生变化时，会重新编译生成临时文件，然后连接&lt;/p&gt;

&lt;p&gt;临时文件不是一直存在的，只是在编译的时候产生&lt;/p&gt;

&lt;p&gt;import后面的是路劲名还是包名？&amp;mdash;&amp;ndash;import后面的最后一个元素应该是路径，就是目录，并非包名。&amp;ndash;而调用的函数的那个是包名&amp;mdash;所以源码路劲一定要存在，不然就can not find&lt;/p&gt;

&lt;p&gt;引用包
import 文件所在的目录路劲（除去$GOPATH/src）
同一个目录下不能定义不同的package&lt;/p&gt;

&lt;p&gt;import m &amp;ldquo;lib/math&amp;rdquo;import语句用m替代lib/math  m指代的是lib/math路径下唯一的那个包&amp;ndash;一定是唯一，不然报错&lt;/p&gt;

&lt;p&gt;第三方语言包管理插件godep安装：
我这边找了一个现成的exe文件放到对应的目录下：&lt;a href=&#34;https://github.com/kr/heroku-buildpack-go/raw/master/linux-amd64/bin/godep&#34;&gt;https://github.com/kr/heroku-buildpack-go/raw/master/linux-amd64/bin/godep&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;go环境变量：
GOROOT ：go的安装目录&lt;/p&gt;

&lt;p&gt;GOPATH ：你自己开发go语言代码的目录，目录结构为bin,pkg,src，如果你有多个目录，那么使用分号分隔。&lt;/p&gt;

&lt;p&gt;网络编程：
    func Dial(net, addr string) (Conn, error)&lt;/p&gt;

&lt;p&gt;其中net参数是网络协议的名字， addr参数是IP地址或域名，而端口号以“:”的形式跟随在地址
或域名的后面，端口号可选。如果连接成功，返回连接对象，否则返回error。&lt;/p&gt;

&lt;p&gt;Dial() 函数支持如下几种网络协议： &amp;ldquo;tcp&amp;rdquo; 、 &amp;ldquo;tcp4&amp;rdquo; （仅限IPv4）、 &amp;ldquo;tcp6&amp;rdquo; （仅限
IPv6）、 &amp;ldquo;udp&amp;rdquo; 、 &amp;ldquo;udp4&amp;rdquo;（仅限IPv4）、 &amp;ldquo;udp6&amp;rdquo;（仅限IPv6）、 &amp;ldquo;ip&amp;rdquo; 、 &amp;ldquo;ip4&amp;rdquo;（仅限IPv4）和&amp;rdquo;ip6&amp;rdquo;
（仅限IPv6）。&lt;/p&gt;

&lt;p&gt;func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error)
func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error)
func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)
func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err error)&lt;/p&gt;

&lt;p&gt;与之前使用Dail() 的例子相比，这里有两个不同:
net.ResolveTCPAddr() ，用于解析地址和端口号；
net.DialTCP() ，用于建立链接。
这两个函数在Dial() 中都得到了封装。/Applications/QQ.app&lt;/p&gt;

&lt;p&gt;我们给 fmt.Println 一个短名字的别名
var p = fmt.Println&lt;/p&gt;

&lt;p&gt;随机数rand&lt;/p&gt;

&lt;p&gt;Rand. Intn(n)。int代表整数，后面的n代表范围，其他类型类似&lt;/p&gt;

&lt;p&gt;((rand.Float64() * 5) + 5)这个技巧可以用来生成其他范围的随机浮点数，例如5.0 &amp;lt;= f &amp;lt;= 10.0&lt;/p&gt;

&lt;p&gt;种子
s1 := rand.NewSource(time.Now().UnixNano())
    r1 := rand.New(s1)&lt;/p&gt;

&lt;p&gt;相同的种子产生的随机数是一样的。&lt;/p&gt;

&lt;p&gt;数字解析包strconv
Url解析包url
SHA1散列就是通过一个算法计算散列值，使用Go 在多个 crypto/* 包中实现了一系列散列函数。
Base64编码—加密解密&lt;/p&gt;

&lt;p&gt;命令行参数
os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。&lt;/p&gt;

&lt;p&gt;命令行标志解析flag包
环境变量设置在os包&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;go提供了安装包，直接下载解压设置/etc/profile环境变量就可以使用go了，简单便捷&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOROOT=/home/test/Go/go—-源码安装路径

export PATH=$GOROOT/bin:$PATH——声明应用

export GOPATH=/home/test/Go/go-project—你的项目路劲
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;最常用的一种形式&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;./test&amp;rdquo;导入同一目录下test包中的内容&lt;/p&gt;

&lt;p&gt;import f &amp;ldquo;fmt&amp;rdquo;导入fmt，并给他启别名ｆ&lt;/p&gt;

&lt;p&gt;import . &amp;ldquo;fmt&amp;rdquo;，将fmt启用别名&amp;rdquo;.&amp;ldquo;，这样就可以直接使用其内容，而不用再添加ｆｍｔ，如fmt.Println可以直接写成Println&lt;/p&gt;

&lt;p&gt;import  _ &amp;ldquo;fmt&amp;rdquo; 表示不使用该包，而是只是使用该包的init函数，并不显示的使用该包的其他内容。注意：这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;struct&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type person struct {
    name string
    age int
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;    var P person  // P现在就是person类型的变量了
    P.name = &amp;quot;Astaxie&amp;quot;  // 赋值&amp;quot;Astaxie&amp;quot;给P的name属性.
    P.age = 25  // 赋值&amp;quot;25&amp;quot;给变量P的age属性type person struct {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按照顺序提供初始化值&lt;/p&gt;

&lt;p&gt;P := person{&amp;ldquo;Tom&amp;rdquo;, 25}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过field:value的方式初始化，这样可以任意顺序&lt;/p&gt;

&lt;p&gt;P := person{age:24, name:&amp;ldquo;Tom&amp;rdquo;}&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;4。 interface&lt;/p&gt;

&lt;p&gt;Go语言引入了一种新类型—Interface，它在效果上实现了类似于C++的“多态”概念。&lt;/p&gt;

&lt;p&gt;从语法上看，Interface定义了一个或一组method(s)，这些method只有函数签名，没有具体的实现代码（有没有联想起C++中的虚函数？）。若某个数据类型实现了Interface中定义的那些被称为&amp;rdquo;methods&amp;rdquo;的函数，则称这些数据类型实现（implement）了interface。&lt;/p&gt;

&lt;p&gt;Interface类型的更通用定义可归纳如下：
type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    &amp;hellip;
}&lt;/p&gt;

&lt;p&gt;以fmt包的Printf()函数为例，其函数签名格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Printf(format string, a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数在实现底层的打印行为时，要求传入的可变长参数实现了fmt包中定义的Stringer接口，这个接口类型定义及描述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Stringer interface {
    String() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一段简单的打印代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

func main() {
    addrs := map[string]IPAddr{
        &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
        &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
    }
}

loopback: [127 0 0 1]
googleDNS: [8 8 8 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要求按规定的格式打印：IPAddr{1, 2, 3, 4}应该输出为&amp;rdquo;1.2.3.4&amp;rdquo;的格式，所以IPAddr这个自定义类型需要实现Stringer接口，实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

// TODO: Add a &amp;quot;String() string&amp;quot; method to IPAddr.
func (ip IPAddr) String() string {    
    return fmt.Sprintf(&amp;quot;%v.%v.%v.%v&amp;quot;, ip[0], ip[1], ip[2], ip[3])
}

func main() {
    addrs := map[string]IPAddr{
        &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
        &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
    }
}

googleDNS: 8.8.8.8
loopback: 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;go tool&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;go build&lt;/p&gt;

&lt;p&gt;go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。&lt;/p&gt;

&lt;p&gt;如果是普通包，当你执行go build命令后，不会产生任何文件。&lt;/p&gt;

&lt;p&gt;如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin木下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/a.exe。&lt;/p&gt;

&lt;p&gt;如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。&lt;/p&gt;

&lt;p&gt;你也可以指定编译输出的文件名。比如，我们可以指定go build -o myapp.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。&lt;/p&gt;

&lt;p&gt;go build 会忽略目录下以”_”或者”.”开头的go文件。&lt;/p&gt;

&lt;p&gt;go build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。&lt;/p&gt;

&lt;p&gt;go clean&lt;/p&gt;

&lt;p&gt;go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括&lt;/p&gt;

&lt;p&gt;_obj/ 旧的object目录，由Makefiles遗留
_test/ 旧的test目录，由Makefiles遗留
_testmain.go 旧的gotest文件，由Makefiles遗留
test.out 旧的test记录，由Makefiles遗留
build.out 旧的test记录，由Makefiles遗留
*.[568ao] object文件，由Makefiles遗留
DIR(.exe) 由 go build 产生
DIR.test(.exe) 由 go test -c 产生
MAINFILE(.exe) 由 go build MAINFILE.go产生&lt;/p&gt;

&lt;p&gt;go fmt&lt;/p&gt;

&lt;p&gt;go fmt 命令主要是用来帮你格式化所写好的代码文件。&lt;/p&gt;

&lt;p&gt;比如我们写了一个格式很糟糕的test.go文件，我们只需要使用fmt命令，就可以让go帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了 go fmt 命令而已。&lt;/p&gt;

&lt;p&gt;使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w src，可以格式化整个项目。&lt;/p&gt;

&lt;p&gt;go get&lt;/p&gt;

&lt;p&gt;go get 命令主要是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具.&lt;/p&gt;

&lt;p&gt;所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。&lt;/p&gt;

&lt;p&gt;go get 命令本质上可以理解为：首先通过源码工具clone代码到src目录，然后执行go install。&lt;/p&gt;

&lt;p&gt;如果需要更新所有的依赖库，增加 -u 参数&lt;/p&gt;

&lt;p&gt;go install&lt;/p&gt;

&lt;p&gt;go install 命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。&lt;/p&gt;

&lt;p&gt;.exe文件： 一般是 go install 带main函数的go文件产生的，有函数入口，所有可以直接运行。&lt;/p&gt;

&lt;p&gt;.a应用包： 一般是 go install 不包含main函数的go文件产生的，没有函数入口，只能被调用。&lt;/p&gt;

&lt;p&gt;go test&lt;/p&gt;

&lt;p&gt;go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似&lt;/p&gt;

&lt;p&gt;ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
&amp;hellip;
默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag&lt;/p&gt;

&lt;p&gt;go doc&lt;/p&gt;

&lt;p&gt;go doc 命令其实就是一个很强大的文档工具。&lt;/p&gt;

&lt;p&gt;如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net/http；查看某一个包里面的函数，那么执行godoc fmt Printf；也可以查看相应的代码，执行godoc -src fmt Printf；&lt;/p&gt;

&lt;p&gt;通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。&lt;/p&gt;

&lt;p&gt;其他命令&lt;/p&gt;

&lt;p&gt;Go语言还提供了其它有用的工具，例如下面的这些工具&lt;/p&gt;

&lt;p&gt;go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1&lt;/p&gt;

&lt;p&gt;go version 查看go当前的版本&lt;/p&gt;

&lt;p&gt;go env 查看当前go的环境变量&lt;/p&gt;

&lt;p&gt;go list 列出当前全部安装的package&lt;/p&gt;

&lt;p&gt;go run 编译并运行Go程序&lt;/p&gt;

&lt;h2 id=&#34;开发工具&#34;&gt;开发工具&lt;/h2&gt;

&lt;p&gt;尝试了liteide和sublime text，感觉还是sublime text比较好，它支持源码的查看的跳转，编译执行，而liteide在跳转上有点问题，不能跳转到自定义的函数，不知道是不是我配置的问题（基本上就是在查看选项设定了go环境变量），所以自己开发的时候决定用sublime&lt;/p&gt;

&lt;p&gt;sublime text go环境搭建&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在mac上安装go并设置好环境变量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装一个Package Control，这个应该是一个插件管理工具，用于安装很多其他插件的，只要用ctrl+ ` 打开命令行输入执行命令&lt;/p&gt;

&lt;p&gt;import urllib.request,os,hashlib; h = &amp;lsquo;7183a2d3e96f11eeadd761d777e62404&amp;rsquo; + &amp;lsquo;e330c659d4bb41d3bdf022e94cab3cd0&amp;rsquo;; pf = &amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &amp;lsquo;&lt;a href=&#34;http://sublime.wbond.Net/&#39;&#34;&gt;http://sublime.wbond.Net/&#39;&lt;/a&gt; + pf.replace(&amp;rsquo; &amp;lsquo;, &amp;lsquo;%20&amp;rsquo;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&amp;lsquo;Error validating download (got %s instead of %s), please try manual install&amp;rsquo; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &amp;lsquo;wb&amp;rsquo; ).write(by)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装好后可以在preferences中找到这个插件。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装go插件gosublime&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们点击Package Control插件或者用shift+ctrl+p来打开，输入pcip（Package Control:Install Package的缩写）也就是安装插件的意思。然后输入gosublime就会自动安装了，安装好了依旧可以在preferences下找到这个gosublime插件。&lt;/p&gt;

&lt;p&gt;4.然后就可以在gopath下建src，src下建对应的项目，使用sublime进行编码，查看，按command+b进入到shell模式进行编译执行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>插件系统</title>
      <link>http://kingjcy.github.io/blog/2017/03/29/%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 29 Mar 2017 17:40:08 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/03/29/%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>python以及爬虫学习</title>
      <link>http://kingjcy.github.io/blog/2017/02/07/python%E4%BB%A5%E5%8F%8A%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Tue, 07 Feb 2017 15:57:46 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2017/02/07/python%E4%BB%A5%E5%8F%8A%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;p&gt;最近对爬虫技术很感兴趣，于是就来学习一下，在学习对过程中突然发现爬虫技术真的很强大，同时让我收益匪浅，把学习过程中的一些重要的东西记录下来，便于分享与备忘。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;python基础&#34;&gt;python基础&lt;/h2&gt;

&lt;p&gt;学习爬虫需要python，html，css,js等基础知识，其中python尤为重要，python只是偶尔用一些,这边再复习巩固一下python基础知识。&lt;/p&gt;

&lt;h3 id=&#34;运算符&#34;&gt;运算符&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;+-*/加减乘除//整除**乘方%求余&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in  是否在内，成功返回true、false&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转义字符／，防止转义r&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多行字符用三引号来表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转化为utf-8用u&amp;rdquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;运行python脚本&#34;&gt;运行python脚本&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;显式使用python&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在脚本中加#!/usr/bin/env python&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python启动参数是sys.argv[1]  第一个参数1&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;文本文件编码&#34;&gt;文本文件编码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基本数据类型&#34;&gt;基本数据类型：&lt;/h3&gt;

&lt;p&gt;一、列表和元组&lt;/p&gt;

&lt;p&gt;a=[&amp;lsquo;a&amp;rsquo;,&amp;lsquo;b&amp;rsquo;,&amp;lsquo;c&amp;rsquo;]&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在python中双引号和单引号是一样的&lt;/li&gt;
&lt;li&gt;索引可以分方向，左边从0开始，右边从-1开始的&lt;/li&gt;
&lt;li&gt;分片&amp;ndash;用冒号：隔开，可以取一点范围内的值，可以在后面加步长，步长可以是负数，表示反向&lt;/li&gt;
&lt;li&gt;空用内建值none，类似于NULL&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;列表方法：
* append 追加
* count 计数
* extend 追加列表
* index 找索引
* insert 插入
* pop    顶
* remove 移除   == del list[index]
* reverse 反向
* sort  排序&amp;mdash;&amp;ndash;可以用cmp，key，reverse&lt;/p&gt;

&lt;p&gt;.join(a)    对a进行循环显示&lt;/p&gt;

&lt;p&gt;元组，不可以变序列&amp;mdash;&amp;ndash;用，隔开，即便是一个元素值&lt;/p&gt;

&lt;p&gt;a=(&amp;lsquo;a&amp;rsquo;,&amp;lsquo;b&amp;rsquo;,&amp;lsquo;c&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;tuple（）&amp;mdash;-将序列转化为元组&lt;/p&gt;

&lt;p&gt;二、字符串：是不可变的&lt;/p&gt;

&lt;p&gt;字符串格式化类似于c，用%（s）&lt;/p&gt;

&lt;p&gt;方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;find  查找，未找到返回-1，可以在参数中提供起始点和终点&lt;/li&gt;
&lt;li&gt;join 在各个字符串之间加上&amp;mdash;-split去除&lt;/li&gt;
&lt;li&gt;replace 替代&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strip去除两端的空格&lt;/p&gt;

&lt;p&gt;s.isalnum() #所有字符都是数字或者字母
s.isalpha() #所有字符都是字母
s.isdigit() #所有字符都是数字
s.islower() #所有字符都是小写
s.isupper() #所有字符都是大写
s.istitle() #所有单词都是首字母大写，像标题
s.isspace() #所有字符都是空白字符、\t、\n&lt;/p&gt;

&lt;p&gt;s.upper() #把所有字符中的小写字母转换成大写字母
s.lower() #把所有字符中的大写字母转换成小写字母
s.capitalize()  #把第一个字母转化为大写字母，其余小写
s.title()  #把每个单词的第一个字母转化为大写，其余小写&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、字典（映射mapping）&amp;mdash;-存储的键值对，可以用dict函数形成键值对&lt;/p&gt;

&lt;p&gt;a={&amp;lsquo;a&amp;rsquo;:&amp;lsquo;b&amp;rsquo;,&amp;lsquo;c&amp;rsquo;:&amp;rsquo;d&amp;rsquo;}&lt;/p&gt;

&lt;p&gt;方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;clear（）清除字典中的所有项&lt;/li&gt;
&lt;li&gt;copy（）浅复制&amp;ndash;复制后的改变原来的也会改变，deepcopy（）深复制，两个不搭嘎&lt;/li&gt;
&lt;li&gt;fromkey（）给对应的键建立字典，默认值为None&lt;/li&gt;
&lt;li&gt;get获取，不存在时不会出错，还可以指定不存在时返回什么值，有点类似于nvl&amp;mdash;setdefault（）&lt;/li&gt;
&lt;li&gt;hash_key（）查找字典中是否有对应的键值&lt;/li&gt;
&lt;li&gt;items（） 将字典项以元组的形式展开&amp;mdash;-对应的迭代器iteritems&lt;/li&gt;
&lt;li&gt;keys（）将字典中的键以列表的形式返回&amp;mdash;&amp;ndash;对应的迭代器iterkeys&lt;/li&gt;
&lt;li&gt;pop（）将一个键值对应的键值对删除&amp;ndash;popitem（）类似于list.pop&lt;/li&gt;
&lt;li&gt;update（）用字典更新字典&lt;/li&gt;

&lt;li&gt;&lt;p&gt;values（）&amp;ndash;itervalues（）   以列表的形式返回字典中的值&lt;/p&gt;

&lt;p&gt;info={&amp;lsquo;a&amp;rsquo;:&amp;lsquo;b&amp;rsquo;}
for k,v in info.items():
    print i&lt;/p&gt;

&lt;p&gt;a b&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;四、集合set&lt;/p&gt;

&lt;p&gt;set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。&lt;/p&gt;

&lt;p&gt;五、变量&lt;/p&gt;

&lt;p&gt;变量必须以字母或者下划线开头，如果有特殊符号需要用三个单引号来赋值，比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=&#39;&#39;&#39;this is aa&#39;aa !&#39;&#39;&#39;
print a

this is aa&#39;aa !&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基本语句&#34;&gt;基本语句&lt;/h3&gt;

&lt;p&gt;一、顺序语句&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输出语句 print  可以输出多个用，号隔开&lt;/li&gt;
&lt;li&gt;导入语句 import +功能&amp;mdash;-from 模块 import 功能  as 别名（有一样的功能）&lt;/li&gt;
&lt;li&gt;赋值语句 可以同时多个赋值操作，类似于go的多返回值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、条件语句&lt;/p&gt;

&lt;p&gt;false&amp;mdash;None 0 &amp;ldquo;&amp;rdquo; () [] {}&amp;mdash;其他都为真&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if condition:
    语句
    elif condition:
        语句
    else:
        语句
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意要加冒号&lt;/p&gt;

&lt;p&gt;一致性比较符is，成员资格运算符in&amp;mdash;-condition&lt;/p&gt;

&lt;p&gt;三、循环语句&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;for word in xx&lt;range(1,19),列表&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以加一个else来表达循环结束
else:
    print &amp;lsquo;the loop is over!&amp;ldquo;&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;while true/flase:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以加一个else来表达循环结束
else:
    print &amp;lsquo;the loop is over!&amp;rsquo;&lt;/p&gt;

&lt;p&gt;都要注意冒号，可以使用break，continue。都是以tab键来判断里面的语句是否结束。&lt;/p&gt;

&lt;h3 id=&#34;标准使用函数&#34;&gt;标准使用函数：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;输出 print&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;print &amp;lsquo;hello&amp;rsquo;,&amp;lsquo;world&amp;rsquo;&lt;/p&gt;

&lt;p&gt;hello world&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;格式化输出类似于c。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=10
b=20
print &#39;a is %s,b is %s&#39; % (a,b)

a is 10,b is 20
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;输入 input&amp;mdash;-返回字符串 raw_input，如果要转化为int类型直接int(字符串)，数字转化为字符串也是str(a)&lt;/p&gt;

&lt;p&gt;name = raw_input(&amp;lsquo;please enter words:&amp;lsquo;)&lt;/p&gt;

&lt;p&gt;print &amp;lsquo;hello&amp;rsquo;,name&lt;/p&gt;

&lt;p&gt;please enter words:world&lt;/p&gt;

&lt;p&gt;hello,world&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;长度 len&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最大值 max&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最小值 min&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把内容列表化 list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除  del&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python open&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;file内建函数open()&lt;/p&gt;

&lt;p&gt;file_object = open(file_name,access_mode = &amp;lsquo;r&amp;rsquo;,buffering = -1)&lt;/p&gt;

&lt;p&gt;文件对象的访问模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r——读方式
w——写方式
a——追加模式
r+,w+,a+——以读写模式打开
rb，wb，ab——以二进制模式读写追加
rb+,wb+,ab+——以二进制读写模式打开
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输入/输出&lt;/p&gt;

&lt;p&gt;read(size),readline(),readlines(),write()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他
file.close() —— 关闭文件
file.fileno() —— 返回文件的描述符(file descriptor,FD,整型值)
file.flush() —— 直接把内部缓冲区中的数据立刻写入文件，而不是被动地等待输出缓冲区被写入。
最后用close关闭&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python csv&lt;/p&gt;

&lt;p&gt;reader
writer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工厂函数file()&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;open()和file()函数具有相同的功能，可以任意替换。您所看到任何使用open()的地方，都可以使用file()替换它。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Python sys&amp;ndash;sys模块中的函数非常多，挑几个有用的来讲讲。&lt;/p&gt;

&lt;p&gt;1.sys.argv —— 对命令行参数的访问
sys.argv是命令行参数的列表
len(sys.argv) 是命令行参数个数(也就是argc）
2.sys.platform() —— 输出平台信息
3.sys.exit(n) 退出
5.sys.stdin,stdout,stderr —— 标准输入输出，错误输出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python sqlite&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sqllite是一个小巧的内嵌型数据库，也就是说没有独立的维护进程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 导入模块

&amp;gt;&amp;gt;&amp;gt; import sqlite3

2. 创建/打开数据库

可以打开数据库：
cx = sqlite3.connect(&#39;./test.db&#39;)
也可以存在内存当中：
con = sqlite3.connect(&amp;quot;:memory:&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;type(a) 判断a是什么类型&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;函数定义&#34;&gt;函数定义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;def function(params):
    block
    return expression/value
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;import&#34;&gt;import&lt;/h3&gt;

&lt;p&gt;可以使用import导入包，或者from + import来导入包中的部分模块.这个很重要，类似于c中引用标准库或者其他库。&lt;/p&gt;

&lt;p&gt;每个python文件*.py都是一个模块。都可以用import导入&lt;/p&gt;

&lt;p&gt;import语句使用以下几种方式导入包中的模块:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Graphics.Primitive.fill 导入模块Graphics.Primitive.fill,只能以全名访问模块属性,例如 Graphics.Primitive.fill.floodfill(img,x,y,color). 
from Graphics.Primitive import fill 导入模块fill ,只能以 fill.属性名这种方式访问模块属性,例如 fill.floodfill(img,x,y,color). 
from Graphics.Primitive.fill import floodfill 导入模块fill ,并将函数floodfill放入当前名称空间,直接访问被导入的属性，例如 floodfill(img,x,y,color).

from os import *   导入os模块的所有功能，下面就不用加os.mkdir,直接用mkdir
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;模块&#34;&gt;模块&lt;/h3&gt;

&lt;p&gt;os操作系统的基本命令，shell里面的命令基本都有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os
os.mkdir(&#39;/tmp/aaa&#39;) 创建目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不知道命令的作用就用help&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help(os.system)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个模块中有一个很强大的命令os.system,可以执行所有的shell命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;os.system(&#39;ifconfig | grep ip&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行成功就返回0，在python命令行历也有&lt;/p&gt;

&lt;p&gt;定义自己的模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;自己写的py文件，去掉后缀就是模块名，中间可以实现一些函数。然后import这个模块，就可以像标准库一样，用模块名加函数名调用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;time.strftime(&#39;%Y%m%d&#39;)
time.sleep(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sys&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f = file(filename)
line=f.readline()
f.close()            类似于c
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;class&#34;&gt;class&lt;/h3&gt;

&lt;p&gt;Python 的 Class 比较特别，和我们习惯的静态语言类型定义有很大区别。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 使用一个名为 __init__ 的方法来完成初始化。

    def __init__(self,name):
        self.name = name            每个类都有一个self变量

2. 使用一个名为 __del__ 的方法来完成类似析购操作。
3. 所有的实例方法都拥有一个 self 参数来传递当前实例，类似于 this。
4. 可以使用 __class__ 来访问类型成员
5. 继承 class a(b)     a继承b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Class 有一些特殊的属性，便于我们获得一些额外的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass.__doc__ # 类型帮助信息 
MyClass.__name__ # 类型名称 
MyClass.__module__ # 类型所在模块 
MyClass.__bases__ # 类型所继承的基类(Python 支持多继承) 
MyClass.__dict__ # 类型字典，存储所有类型成员信息 
MyClass().__class__ # 实例的类型
MyClass().__module__ # 实例类型所在模块 
MyClass().__dict__ # 对象字典，存储所有实例成员  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;错误机制&#34;&gt;错误机制&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;try:
    语句
except IndexError:
    pass                       抛出异常
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;捕捉到错误就到except中执行相关语句，类似与c++里对try&amp;hellip;catch&lt;/p&gt;

&lt;h2 id=&#34;python常用运维&#34;&gt;python常用运维&lt;/h2&gt;

&lt;h2 id=&#34;python爬虫入门&#34;&gt;python爬虫入门&lt;/h2&gt;

&lt;p&gt;网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。&lt;/p&gt;

&lt;p&gt;在上面已经巩固来python的基础，下面需要用到的是python的urllib和urllib2这两个库，还有很重要的正则表达式，如果这些掌握了就可以抓取一些简单的网站了，继续进阶功能强大的框架。&lt;/p&gt;

&lt;h3 id=&#34;urllib和urllib2&#34;&gt;urllib和urllib2&lt;/h3&gt;

&lt;p&gt;如果把网页比作一个人，那么HTML便是他的骨架，JS便是他的肌肉，CSS便是它的衣服。urllib就是把这些代码扒下来。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重点api&lt;/p&gt;

&lt;p&gt;urlopen(url, data, timeout)&lt;/p&gt;

&lt;p&gt;第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。&lt;/p&gt;

&lt;p&gt;第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正常会构建一个request对象，将相关的参数传递进去然后进行服务器请求，urlopen支持request对象的请求。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传递参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;get是以链接中直接加参数的形式去直接访问，post则在结构体中传递参数，不会在网址中展示。&lt;/p&gt;

&lt;p&gt;实例对比展示&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;post&lt;/p&gt;

&lt;p&gt;import urllib
import urllib2&lt;/p&gt;

&lt;p&gt;values = {}
values[&amp;lsquo;username&amp;rsquo;] = &amp;ldquo;1016903103@qq.com&amp;rdquo;
values[&amp;lsquo;password&amp;rsquo;] = &amp;ldquo;XXXX&amp;rdquo;
#values = {&amp;lsquo;username&amp;rsquo;:&amp;ldquo;1016903103@qq.com&amp;rdquo;,&amp;ldquo;password&amp;rdquo;:&amp;ldquo;XXXX&amp;rdquo;}  也可以这样定义
data = urllib.urlencode(values)
url = &amp;ldquo;&lt;a href=&#34;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&amp;quot;&#34;&gt;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&amp;quot;&lt;/a&gt;
request = urllib2.Request(url,data)
response = urllib2.urlopen(request)
print response.read()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get&lt;/p&gt;

&lt;p&gt;import urllib
import urllib2&lt;/p&gt;

&lt;p&gt;values={}
values[&amp;lsquo;username&amp;rsquo;] = &amp;ldquo;1016903103@qq.com&amp;rdquo;
values[&amp;lsquo;password&amp;rsquo;]=&amp;ldquo;XXXX&amp;rdquo;
data = urllib.urlencode(values)
url = &amp;ldquo;&lt;a href=&#34;http://passport.csdn.net/account/login&amp;quot;&#34;&gt;http://passport.csdn.net/account/login&amp;quot;&lt;/a&gt;
geturl = url + &amp;ldquo;?&amp;rdquo;+data
request = urllib2.Request(geturl)
response = urllib2.urlopen(request)
print response.read()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样就可以将对应的网址的html扒下来了，下面就是获取我们所需要的内容了,但是在这个之前还有很多的特殊情况要处理&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有些网站会对访问进行识别，这个时候就需要进行header属性的设置了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们一般可以是用F12打开浏览器的网络监听，也就是开发者工具，来查看http包的内容。如下图&lt;/p&gt;

&lt;p&gt;在header中有这些属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求
Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。
application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用
application/json ： 在 JSON RPC 调用时使用
application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用
在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如User-Agent表示请求者的身份，Referer表示是不是它自己，我们可以将他加入到请求参数中一起在header中有这些属性,我们来实战一下&lt;/p&gt;

&lt;p&gt;在上面的post方法请求中加入header参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib
import urllib2

values = {}
values[&#39;username&#39;] = &amp;quot;1016903103@qq.com&amp;quot;
values[&#39;password&#39;] = &amp;quot;XXXX&amp;quot;
#values = {&#39;username&#39;:&amp;quot;1016903103@qq.com&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;XXXX&amp;quot;}  也可以这样定义
data = urllib.urlencode(values) 
url = &amp;quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&amp;quot;
user-agent = &amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36&amp;quot;
header = {&amp;quot;User-Agent&amp;quot;:user-agent,&amp;quot;Referer&amp;quot;:&amp;quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&amp;quot;}
request = urllib2.Request(url,data,header)
response = urllib2.urlopen(request)
print response.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以突破了一些限制，将对应的网站扒下来&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;超时时间和代理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;超时时间直接在上面的urlopen的参数中设置即可，代理主要是为了防止某些网站禁止一个IP过于频繁的访问。代理的使用如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2
enable_proxy = True
proxy_handler = urllib2.ProxyHandler({&amp;quot;http&amp;quot; : &#39;http://some-proxy.com:8080&#39;})
null_proxy_handler = urllib2.ProxyHandler({})
if enable_proxy:
    opener = urllib2.build_opener(proxy_handler)
else:
    opener = urllib2.build_opener(null_proxy_handler)
urllib2.install_opener(opener)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在里有一个opener的概念，他是一种扒取网页的模式，我们之前用的都是默认的一种opener，也就是urllib中的urlopen，它具有更加通用的模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HTTP的PUT和DELETE方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然这两种方法在HTTP请求中很少用，但是urllib也是支持的，直接看使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2
request = urllib2.Request(uri, data=data)
request.get_method = lambda: &#39;PUT&#39; # or &#39;DELETE&#39;
response = urllib2.urlopen(request)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是设置requesr的get_method属性设置为对应的PUT或者DELETE。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用DEBUGLOG&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;打印DEBUGLOG主要是方便调试，使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2
httpHandler = urllib2.HTTPHandler(debuglevel=1)
httpsHandler = urllib2.HTTPSHandler(debuglevel=1)
opener = urllib2.build_opener(httpHandler, httpsHandler)
urllib2.install_opener(opener)
response = urllib2.urlopen(&#39;http://www.baidu.com&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;出错处理&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;URLerror&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们一般是使用try-exceot来捕捉错误的，有一个类URlerror来存储错误类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2

request = urllib2.Request(&#39;http://www.xxxxx.com&#39;)
try:
    urllib2.urlopen(request)
except urllib2.URLError, e:
    print e.reason
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HTTPerror&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTPError是URLError的子类,它包含来一个数字的状态码，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;100：继续  客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。
101： 转换协议  在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。
102：继续处理   由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
200：请求成功      处理方式：获得响应的内容，进行处理
201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到
202：请求被接受，但处理尚未完成    处理方式：阻塞等待
204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃
300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃
301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL
302：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL
304：请求的资源未更新     处理方式：丢弃
400：非法请求     处理方式：丢弃
401：未授权     处理方式：丢弃
403：禁止     处理方式：丢弃
404：没有找到     处理方式：丢弃
500：服务器内部错误  服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。
501：服务器无法识别  服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。
502：错误网关  作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
503：服务出错   由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道，HTTPError的父类是URLError，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，那么可以捕获父类的异常，所以正常这样使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2

req = urllib2.Request(&#39;http://blog.csdn.net/cqcre&#39;)
try:
    urllib2.urlopen(req)
except urllib2.HTTPError, e:
    print e.code
except urllib2.URLError, e:
    print e.reason
else:
    print &amp;quot;OK&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;cookie&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）&lt;/p&gt;

&lt;p&gt;比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容是不允许的。那么我们可以利用Urllib2库保存我们登录的Cookie，然后再抓取其他页面就达到目的了。&lt;/p&gt;

&lt;p&gt;主要是通过cookielib来实现的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先cookiejar可以获取cookie然后存放到变量中去&lt;/p&gt;

&lt;p&gt;import urllib2
import cookielib
#声明一个CookieJar对象实例来保存cookie
cookie = cookielib.CookieJar()
#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器
handler=urllib2.HTTPCookieProcessor(cookie)
#通过handler来构建opener
opener = urllib2.build_opener(handler)
#此处的open方法同urllib2的urlopen方法，也可以传入request
response = opener.open(&amp;lsquo;&lt;a href=&#34;http://www.baidu.com&#39;&#34;&gt;http://www.baidu.com&#39;&lt;/a&gt;)
for item in cookie:
    print &amp;lsquo;Name = &amp;lsquo;+item.name
    print &amp;lsquo;Value = &amp;lsquo;+item.value&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用filecookiejar将变量保存到文件中去&lt;/p&gt;

&lt;p&gt;import cookielib
import urllib2&lt;/p&gt;

&lt;p&gt;#设置保存cookie的文件，同级目录下的cookie.txt
filename = &amp;lsquo;cookie.txt&amp;rsquo;
#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件
cookie = cookielib.MozillaCookieJar(filename)
#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器
handler = urllib2.HTTPCookieProcessor(cookie)
#通过handler来构建opener
opener = urllib2.build_opener(handler)
#创建一个请求，原理同urllib2的urlopen
response = opener.open(&amp;ldquo;&lt;a href=&#34;http://www.baidu.com&amp;quot;&#34;&gt;http://www.baidu.com&amp;quot;&lt;/a&gt;)
#保存cookie到文件
cookie.save(ignore_discard=True, ignore_expires=True)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重文件中获取cookie并用于访问&lt;/p&gt;

&lt;p&gt;import cookielib
import urllib2&lt;/p&gt;

&lt;p&gt;#创建MozillaCookieJar实例对象
cookie = cookielib.MozillaCookieJar()
#从文件中读取cookie内容到变量
cookie.load(&amp;lsquo;cookie.txt&amp;rsquo;, ignore_discard=True, ignore_expires=True)
#创建请求的request
req = urllib2.Request(&amp;ldquo;&lt;a href=&#34;http://www.baidu.com&amp;quot;&#34;&gt;http://www.baidu.com&amp;quot;&lt;/a&gt;)
#利用urllib2的build_opener方法创建一个opener
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))
response = opener.open(req)
print response.read()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结合这三者就可以实现利用cookie来模拟登陆了。&lt;/p&gt;

&lt;h3 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;正则表达式是内容匹配的重点，本身就是一种匹配的规则，在python中使用比较常见，这边东西比较多而乱，也比较重要，所以单独的系统的巩固学习了一下，具体可以参考我的另一篇博文《正则表达式》&lt;/p&gt;

&lt;h3 id=&#34;框架&#34;&gt;框架&lt;/h3&gt;

&lt;p&gt;基本使用会了，可以更加功能强大且方便的框架&lt;/p&gt;

&lt;h2 id=&#34;实战&#34;&gt;实战&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;可以用上述的基本知识完成对糗事百科，百度贴吧这样网站的抓取。
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>ceph管理平台calamari的安装</title>
      <link>http://kingjcy.github.io/blog/2016/12/21/ceph%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0calamari%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Wed, 21 Dec 2016 16:17:28 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/12/21/ceph%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0calamari%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>&lt;p&gt;环境准备&lt;/p&gt;

&lt;p&gt;pdapp17     172.32.148.127  ceph-deploy/mon/osd&lt;/p&gt;

&lt;p&gt;pdapp18     172.32.148.128  mds&lt;/p&gt;

&lt;p&gt;pdapp19     172.32.148.129  osd&lt;/p&gt;

&lt;p&gt;pdapp20     172.32.148.130  osd&lt;/p&gt;

&lt;p&gt;获取安装包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp17 calamari]# l
总用量 21436
-rw-r--r--. 1 root root 20283376 12月 21 15:15 calamari-server-1.3.1.1-105_g79c8df2.el7.centos.x86_64.rpm
-rw-r--r--. 1 root root     3661 12月 21 15:15 ceph-deploy-ceph.log
-rw-r--r--. 1 root root   558644 12月 21 15:15 diamond-3.4.67-0.noarch.rpm
-rw-r--r--. 1 root root  1099116 12月 21 15:15 romana-1.2.2-36_gc62bb5b.el7.centos.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在pdapp17上安装calamari-server-1.3.1.1-105_g79c8df2.el7.centos.x86_64.rpm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install -y calamari-server-1.3.1.1-105_g79c8df2.el7.centos.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化calamari服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;calamari-ctl initialize
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在所有的机器上安装diamond-3.4.67-0.noarch.rpm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install -y diamond-3.4.67-0.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改所有机器的diamond的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /etc/diamond/
mv diamond.conf.example diamond.conf
vi diamond.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要将host主机修改为安装calamari服务安装的主机名&lt;/p&gt;

&lt;p&gt;重启diamond服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start diamond
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启之前需要加载systemd的配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在所有的主机主机上安装salt-minion&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install -y salt-minion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/salt/minion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将master全部修改为calamari安装的主机名&lt;/p&gt;

&lt;p&gt;然后重启diamond服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl restart diamond
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启懂salt-minion服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start salt-minion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在安装过程中全部使用root，并且关闭所有机器的防火墙。&lt;/p&gt;

&lt;p&gt;修改python脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /opt/calamari/salt/salt/_modules/ceph.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改下面三行，在571行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mon_epoch = status.get(&#39;monmap&#39;, {}).get(&#39;epoch&#39;)
osd_epoch = status.get(&#39;osdmap&#39;, {}).get(&#39;osdmap&#39;, {}).get(&#39;epoch&#39;)
mds_epoch = status.get(&#39;fsmap&#39;, status.get(&#39;mdsmap&#39;, {})).get(&#39;epoch&#39;)&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用salt命令来查看机器的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@pdapp17 salt]# salt-key -L
Accepted Keys:
Denied Keys:
Unaccepted Keys:
pdapp17
pdapp18
pdapp19
pdapp20
Rejected Keys:
[root@pdapp17 salt]# salt-key -A
The following keys are going to be accepted:
Unaccepted Keys:
pdapp17
pdapp18
pdapp19
pdapp20
Proceed? [n/Y] y
Key for minion pdapp17 accepted.
Key for minion pdapp18 accepted.
Key for minion pdapp19 accepted.
Key for minion pdapp20 accepted.
[root@pdapp17 salt]# salt-key -L
Accepted Keys:
pdapp17
pdapp18
pdapp19
pdapp20
Denied Keys:
Unaccepted Keys:
Rejected Keys:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别使用下面的命令来检验各台机器的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;salt &amp;quot;*&amp;quot; test.ping
salt &amp;quot;*&amp;quot; ceph.get_heartbeats
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在calamari主机上安装romana-1.2.2-36_gc62bb5b.el7.centos.x86_64.rpm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install -y romana-1.2.2-36_gc62bb5b.el7.centos.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改日志的权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod 777 /var/log/calamari/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在这台机器上重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl restart supervisord.service
systemctl restart httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以直接通过这台主机的ip来访问了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>centos6升级centos7</title>
      <link>http://kingjcy.github.io/blog/2016/12/07/centos6%E5%8D%87%E7%BA%A7centos7/</link>
      <pubDate>Wed, 07 Dec 2016 09:48:07 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/12/07/centos6%E5%8D%87%E7%BA%A7centos7/</guid>
      <description>&lt;p&gt;随着centos 7的使用越来越多，技术越来越成熟，并且很多技术对内核和centos的版本上都有来新的要求，原来的centos6已经不能满足需要，所以将centos由6升级到7.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;升级&#34;&gt;升级&lt;/h1&gt;

&lt;p&gt;可以直接下载安装centos7进行安装，不过这边讲述的是centos6.4到centos7的升级。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先查看现有的系统版本：&lt;/p&gt;

&lt;p&gt;unmae -a&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lsb_release -a
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改yum源，增加仓库&lt;/p&gt;

&lt;p&gt;vi /etc/yum.repos.d/upgradtool.repo&lt;/p&gt;

&lt;p&gt;[upg]
name=CentOS-$releasever - Upgrade Tool
baseurl=&lt;a href=&#34;http://dev.centos.org/centos/6/upg/x86_64/&#34;&gt;http://dev.centos.org/centos/6/upg/x86_64/&lt;/a&gt;
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装升级工具&lt;/p&gt;

&lt;p&gt;yum install -y redhat-upgrade-tool preupgrade-assistant-contents&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用preupg工具进行升级检查&lt;/p&gt;

&lt;p&gt;preupg -s CentOS6_7&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装升级用的centos7 rpm key&lt;/p&gt;

&lt;p&gt;rpm &amp;ndash;import &lt;a href=&#34;http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-7&#34;&gt;http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-7&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行升级工具&lt;/p&gt;

&lt;p&gt;centos-upgrade-tool-cli &amp;ndash;network 7 &amp;ndash;instrepo=&lt;a href=&#34;http://mirror.centos.org/centos/7/os/x86_64/&#34;&gt;http://mirror.centos.org/centos/7/os/x86_64/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;补充&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大版本的升级还是比较容易出问题的，所以可以下载centos7的iso文件，直接安装比较靠谱。&lt;/p&gt;

&lt;p&gt;一般装完系统后需要修改/etc/sysconfig/ifcfg-eth0的onboot来设置网卡的开始启动。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iptables tutorial</title>
      <link>http://kingjcy.github.io/blog/2016/12/02/iptables-tutorial/</link>
      <pubDate>Fri, 02 Dec 2016 17:13:49 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/12/02/iptables-tutorial/</guid>
      <description>&lt;p&gt;防火墙是通过审查经过的每一个数据包，判断它是否有相匹配的过滤规则，根据规则的先后顺序进行一一比较，直到满足其中的一条规则为止，然后依据控制机制做出相应的动作。如果都不满足，则将数据包丢弃，从而保护网络的安全。目前防火墙有两种机制：一个是阻止传输流通过，一个是允许传输流通过。就是我们所说的过滤式的防火墙，还有就是代理服务器。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;iptables基本概念&#34;&gt;iptables基本概念&lt;/h2&gt;

&lt;p&gt;规则（rules）：预定义条件，一般类似于“如果数据包头符合这样的条件，就这样处理这个数据包。”&lt;/p&gt;

&lt;p&gt;链（chains）：是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。&lt;/p&gt;

&lt;p&gt;表（tables）：提供特定的功能，iptables内置了4个表，即filter表、nat表、mangle表和raw表，分别用于实现包过滤，网络地址转换、包重构(修改)和数据跟踪处理。&lt;/p&gt;

&lt;p&gt;显而易见，数据包在链上传输，通过表中不同规则的检查，决定怎么处理这些数据包，比如放行（accept）、拒绝（reject）和丢弃（drop）等&lt;/p&gt;

&lt;h2 id=&#34;iptables命令&#34;&gt;iptables命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;iptables [-t table] 命令 [chain] [rules] [-j target]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;table——指定表，也就是上面指iptables内的四张表。&lt;/li&gt;
&lt;li&gt;命令——对链的操作命令&lt;/li&gt;
&lt;li&gt;-P或–policy &amp;lt;链名&amp;gt; 定义默认策略&lt;/li&gt;
&lt;li&gt;-L或–list &amp;lt;链名&amp;gt; 查看iptables规则列表&lt;/li&gt;
&lt;li&gt;-A或—append &amp;lt;链名&amp;gt; 在规则列表的最后增加1条规则&lt;/li&gt;
&lt;li&gt;-I或–insert &amp;lt;链名&amp;gt; 在指定的位置插入1条规则&lt;/li&gt;
&lt;li&gt;-D或–delete &amp;lt;链名&amp;gt; 从规则列表中删除1条规则&lt;/li&gt;
&lt;li&gt;-R或–replace &amp;lt;链名&amp;gt; 替换规则列表中的某条规则&lt;/li&gt;
&lt;li&gt;-F或–flush &amp;lt;链名&amp;gt; 删除表中所有规则&lt;/li&gt;
&lt;li&gt;-Z或–zero &amp;lt;链名&amp;gt; 将表中数据包计数器和流量计数器归零&lt;/li&gt;
&lt;li&gt;chain——链名&lt;/li&gt;
&lt;li&gt;INPUT&lt;/li&gt;
&lt;li&gt;OUTPUT&lt;/li&gt;
&lt;li&gt;FORWORD&lt;/li&gt;
&lt;li&gt;PREROUTING&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POSTROUTING&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rules——规则&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-i或–in-interface &amp;lt;网络接口名&amp;gt; 指定数据包从哪个网络接口进入，如ppp0、eth0和eth1等&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-o或–out-interface &amp;lt;网络接口名&amp;gt; 指定数据包从哪块网络接口输出，如ppp0、eth0和eth1等&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面两个支持&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-p或—proto协议类型 &amp;lt; 协议类型&amp;gt; 指定数据包匹配的协议，如TCP、UDP和ICMP等

&lt;ul&gt;
&lt;li&gt;TCP&lt;/li&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;li&gt;ICMP&lt;/li&gt;
&lt;li&gt;protocol name  from /etc/protocol&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;-s或–source &amp;lt;源地址或子网&amp;gt; 指定数据包匹配的源地址&lt;/li&gt;
&lt;li&gt;–sport &amp;lt;源端口号&amp;gt; 指定数据包匹配的源端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口&lt;/li&gt;
&lt;li&gt;-d或–destination &amp;lt;目标地址或子网&amp;gt; 指定数据包匹配的目标地址&lt;/li&gt;
&lt;li&gt;–dport目标端口号 指定数据包匹配的目标端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口&lt;/li&gt;
&lt;li&gt;target——动作如何进行&lt;/li&gt;
&lt;li&gt;ACCEPT 接受数据包&lt;/li&gt;
&lt;li&gt;DROP 丢弃数据包&lt;/li&gt;
&lt;li&gt;REDIRECT 与DROP基本一样，区别在于它除了阻塞包之外， 还向发送者返回错误信息。&lt;/li&gt;
&lt;li&gt;SNAT 源地址转换，即改变数据包的源地址&lt;/li&gt;
&lt;li&gt;DNAT 目标地址转换，即改变数据包的目的地址&lt;/li&gt;
&lt;li&gt;MASQUERADE IP伪装，即是常说的NAT技术，MASQUERADE只能用于ADSL等拨号上网的IP伪装，也就是主机的IP是由ISP分配动态的；如果主机的IP地址是静态固定的，就要使用SNAT&lt;/li&gt;
&lt;li&gt;LOG 日志功能，将符合规则的数据包的相关信息记录在日志中，以便管理员的分析和排错&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>ceph tutorial</title>
      <link>http://kingjcy.github.io/blog/2016/12/01/ceph-tutorial/</link>
      <pubDate>Thu, 01 Dec 2016 14:26:20 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/12/01/ceph-tutorial/</guid>
      <description>&lt;p&gt;ceph是一个linux PB级分布式文件存储系统，它是一个大容量并且简单扩容，高性能，高可靠等特性。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;简析&#34;&gt;简析&lt;/h2&gt;

&lt;p&gt;ceph是一套基于RADOS（可靠自动化分布式对象存储）的分布式对象存储系统。RADOS是由为数众多负责完成数据存储和维护的osd和负责监测的mon组成的完整的对象存储系统。在RADOS上进行抽象和封装形成基础库librados提供上层所需要的API。在librados的基础上继续封装抽象就达到了我们所需要的应用层接口RADOS GW，RBD，ceph FS。在RADOS上进行的完整的对象存储系统。&lt;/p&gt;

&lt;p&gt;集群部署组成部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ceph-deploy   安装部署工具&lt;/li&gt;
&lt;li&gt;ceph mon      监控节点，负责监控，从osd节点获取信息，来判断osd节点的状态&lt;/li&gt;
&lt;li&gt;ceph osd      存储数据&lt;/li&gt;
&lt;li&gt;ceph mds      元数据服务&lt;/li&gt;
&lt;li&gt;ceph client   客户端，用于文件系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;寻址流程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;file  切割为 object，object是大小是有RADOS来定的，获取到对应到oid，唯一，这个是file到object到第一级映射。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object 使用算法 hash(oid) &amp;amp; mask -&amp;gt; pgid获取pid完成到pg的映射，这边mask是pg总数-1，最后这种是伪随机的算法，只有在大量的情况下才能产生均衡。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pg 到 osd 的映射，使用的是CRUSH算法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三级映射完成数据的查找&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据存储流程&lt;/p&gt;

&lt;p&gt;将file变为一个object，然后找出存储该object的一组三个OSD。这三个OSD具有各自不同的序号，序号最靠前的那个OSD就是这一组中的Primary OSD，而后两个则依次是Secondary OSD和Tertiary OSD。找出三个OSD后，client将直接和Primary OSD通信，发起写入操作（步骤1）。Primary OSD收到请求后，分别向Secondary OSD和Tertiary OSD发起写入操作（步骤2、3）。当Secondary OSD和Tertiary OSD各自完成写入操作后，将分别向Primary OSD发送确认信息（步骤4、5）。当Primary OSD确信其他两个OSD的写入完成后，则自己也完成数据写入，并向client确认object写入操作完成（步骤6）。当各个OSD都将数据写入内存缓冲区后，就先向client发送一次确认，此时client即可以向下执行。解决延迟。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;集群维护&lt;/p&gt;

&lt;p&gt;mon共同负责整个Ceph集群中所有OSD状态的发现与记录，并且共同形成cluster map的master版本，然后扩散至全体OSD以及client。OSD使用cluster map进行数据的维护，而client使用cluster map进行数据的寻址。&lt;/p&gt;

&lt;p&gt;monitor并不主动轮询各个OSD的当前状态。正相反，OSD需要向monitor上报状态信息。&lt;/p&gt;

&lt;p&gt;Cluster map: epoch(版本号)，各个osd的网络地址和状态，CRUSH的参数配置。&lt;/p&gt;

&lt;p&gt;Cluster map信息是以增量形式扩散的。如果任意一次通信的双方发现其epoch不一致，则版本更新的一方将把二者所拥有的cluster map的差异发送给另外一方。&lt;/p&gt;

&lt;p&gt;对于一个Ceph集群而言，即便由数千个甚至更多OSD组成，cluster map的数据结构大小也并不惊人。同时，cluster map的状态更新并不会频繁发生。即便如此，Ceph依然对cluster map信息的扩散机制进行了优化，以便减轻相关计算和通信压力。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;技术特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高可靠&lt;/li&gt;
&lt;li&gt;高自动化&lt;/li&gt;
&lt;li&gt;高扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设计思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发挥存储设备的计算能力&lt;/li&gt;
&lt;li&gt;去中心化，避免单点故障和瓶颈&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-centos&#34;&gt;安装（centos）&lt;/h2&gt;

&lt;p&gt;环境准备&lt;/p&gt;

&lt;p&gt;pdapp17     172.32.148.127  ceph-deploy/mon/osd&lt;/p&gt;

&lt;p&gt;pdapp18     172.32.148.128  mds&lt;/p&gt;

&lt;p&gt;pdapp19     172.32.148.129  osd&lt;/p&gt;

&lt;p&gt;pdapp20     172.32.148.130  osd&lt;/p&gt;

&lt;h3 id=&#34;安装-ceph-部署工具&#34;&gt;安装 CEPH 部署工具&lt;/h3&gt;

&lt;p&gt;首先安装ceph-deploy这个ceph部署管理工具，便于ceph的安装。&lt;/p&gt;

&lt;p&gt;创建源文件&lt;/p&gt;

&lt;p&gt;sudo vim /etc/yum.repos.d/ceph.repo 追加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ceph]
name=Ceph packages for $basearch
baseurl=https://download.ceph.com/rpm-jewel/el7/x86_64
enabled=1
priority=1
gpgcheck=1
type=rpm-md
gpgkey=https://download.ceph.com/keys/release.asc

[ceph-noarch]
name=Ceph noarch packages
baseurl=https://download.ceph.com/rpm-jewel/el7/noarch
enabled=1
priority=1
gpgcheck=1
type=rpm-md
gpgkey=https://download.ceph.com/keys/release.asc

[ceph-source]
name=Ceph source packages
baseurl=https://download.ceph.com/rpm-jewel/el7/SRPMS
enabled=0
priority=1
gpgcheck=1
type=rpm-md
gpgkey=https://download.ceph.com/keys/release.asc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是ceph的官方源，其中ceoh-deploy应该是在源[ceph-noarch]，这边一并加了后面要用这个源，（但是这些源都太慢了，我把对应的rpm包下载下来(可以第一次用这个源安装，但是修改源的配置文件保留下载的安装包)做了一个内部源，这样就可以快速的完成安装了,建议可以这样做）&lt;/p&gt;

&lt;p&gt;最后更新安装就好&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum update &amp;amp;&amp;amp; sudo yum install ceph-deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这边管理节点就安装好了，比较简单，下面开始安装ceph。&lt;/p&gt;

&lt;h3 id=&#34;ceph-节点安装和集群部署&#34;&gt;CEPH 节点安装和集群部署&lt;/h3&gt;

&lt;h4 id=&#34;1-集群机器环境准备&#34;&gt;1. 集群机器环境准备&lt;/h4&gt;

&lt;p&gt;安装ceph-deploy的管理节点必须能够通过 SSH 无密码地访问各 Ceph 节点。如果 ceph-deploy 以某个普通用户安装，那么这个用户必须有无密码使用 sudo 的权限。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装ntp&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装ntp始终服务可以避免时钟漂移产生故障。所有的集群机器都要安装，在centos下只要用用yum安装就好&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install ntp ntpdate ntp-doc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要对ntp服务进行设置，修改配置文件/etc/ntp.conf，一台主机时间作为标准时间来同步，集群其他的机器来和这台机器时间进行同步&lt;/p&gt;

&lt;p&gt;标准时间机器也就是ntpserver配置新增&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server  127.127.1.0     # local clock
fudge   127.127.1.0 stratum 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示以本地时间为准，然后启动或者重启ntp服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start ntpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集群的其他机器需要修改配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server ip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集群的其他机器第一次需要手动同步，然后启动ntp服务，手动同步直接用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ntpdate ip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同步成功输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;16 Dec 16:29:21 ntpdate[29461]: adjust time server 172.32.148.127 offset 0.000601 sec
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装ssh&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确保系统中有ssh服务，否则需要安装，安装很简单，直接使用yum&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install openssh-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有ssh服务需要确保服务都在运行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;创建账户并且支持各个节点之间对无密码ssh登陆&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ceph-deploy 工具必须以普通用户登录 Ceph 节点，且此用户拥有无密码使用 sudo 的权限，因为它需要在安装软件及配置文件的过程中，不必输入密码。&lt;/p&gt;

&lt;p&gt;新版ceph-deploy支持使用&amp;ndash;username来创建无密码登陆适用于ssh用户。用户名最好用一些自己取对名字，增加安全性。然后针对自己对用户赋予sudo权限。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建用户&lt;/p&gt;

&lt;p&gt;sudo useradd -d /home/{username} -m {username}
passwd {username}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;增加root权限&lt;/p&gt;

&lt;p&gt;echo &amp;ldquo;{username} ALL = (ALL)ALL&amp;rdquo; | sudo tee /etc/sudoers&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无密码ssh登陆&lt;/p&gt;

&lt;p&gt;ssh-keygen  生成密钥
##scp ~/.ssh/id_rsa.pub xxx@host:/home/xxx/id_rsa.pub   复制到其他主机上来完成无密码访问有一个更好用到命令&lt;/p&gt;

&lt;p&gt;ssh-copy-id {username}@hostname   将密钥~/.ssh/id_rsa.pub复制到其他主机上文件为authorized_keys中，就可以无密码登陆了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;解析主机名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编辑/etc/hosts加上对于到ip 主机名 就可以直接用主机名进行访问了，也可以给主机起别名，编辑~/.ssh/config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host node1
    Hostname node1
    User {username}
Host node2
    Hostname node2          
    User {username}
Host node3
    Hostname node3
    User {username}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装过程中需要关闭防火墙&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl stop firewalld
setenforce 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装优先级/首选项&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install yum-plugin-priorities
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-安装ceph部署集群&#34;&gt;2.安装ceph部署集群&lt;/h4&gt;

&lt;p&gt;集群的基础环境已经部署好了，下面就是开始安装ceph，部署集群。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;登陆ceph-deploy主机先建一个目录来存储集群需要的配置文件和密钥&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir my-cluster
cd my-cluster
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个过程中需要ssh到集群其他机器还需要使用这个机器到sudo权限，所以需要修改配置文件/etc/sudoers,屏蔽掉#Defaults    requiretty才行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用ceph-deploy来创建集群&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy new [-h] [--no-ssh-copykey] [--fsid FSID][--cluster-network CLUSTER_NETWORK][--public-network PUBLIC_NETWORK] MON [MON ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这个命令开始部署一个集群，后面的主机名也是接下来要部署的mon节点的主机名，这边指定主机，主要是生成一个配置文件和一个密钥。后面需要初始化。在这还需要修改一下配置文件&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改osd节点的个数默认为3，这边改为2&lt;/p&gt;

&lt;p&gt;osd pool default size = 2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置网卡，这个不是一定要配置的&lt;/p&gt;

&lt;p&gt;public network = {ip-address}/{netmask}&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装ceph&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用ceph-deploy来安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy install [-h] [--stable [CODENAME] | --release [CODENAME] |--testing | --dev [BRANCH_OR_TAG] | --dev-commit[COMMIT]] [--mon] [--mds] [--rgw] [--osd] [--tests][--cli] [--all][--adjust-repos | --no-adjust-repos | --repo][--local-mirror [LOCAL_MIRROR]][--repo-url [REPO_URL]] [--gpg-url [GPG_URL][--nogpgcheck] HOST [HOST ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是在各个host安装ceph,先检验源，如果没有则安装一个ceph.repo，我这边用了内部源，则检测到不会被覆盖，然后主要是安装ceph：sudo yum -y install ceph ceph-radosgw。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;初始化mon节点&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy mon create-initial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在ceph-deploy主机集群目录下会生成对应的密钥。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;添加OSD节点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先在osd节点的主机上新建目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;login pdapp19  
mkdir /ceph/osd0
login pdapp20
mkdir /ceph/osd1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建逻辑卷挂载到这个目录上,在对应的osd主机上执行分区挂载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;umount /home &amp;amp;&amp;amp; lvremove /dev/centos/home &amp;amp;&amp;amp; mkdir /ceph &amp;amp;&amp;amp; lvcreate -L 107374182400k -n ceph centos &amp;amp;&amp;amp; mkfs.xfs -i size=512 /dev/centos/ceph &amp;amp;&amp;amp; mount /dev/centos/ceph /ceph;df -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后管理节点执行 ceph-deploy 来准备 OSD,这边特别主要的是各个机器的主机的防火墙一定要关闭，还有对应的文件是否有其他用户执行权限没有则使用chmod来修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-delpoy osd prepare pdapp19:/ceph/osd0 pdapp20:/ceph/osd1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;激活osd节点，最终会在osd节点上创建systemd 服务单元&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy osd activate pdapp19:/ceph/osd0 pdapp20:/ceph/osd1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 ceph-deploy 把配置文件和 admin 密钥拷贝到管理节点和 Ceph 节点，这样你每次执行 Ceph 命令行时就无需指定 monitor 地址和 ceph.client.admin.keyring 了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy admin pdapp17 pdapp18 pdapp19 pdapp20

sudo chmod +r /etc/ceph/ceph.client.admin.keyring
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集群就ok了，查看一下集群状况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph health/ceph -s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示的应该是达到 active + clean 状态。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-集群卸载&#34;&gt;3.集群卸载&lt;/h3&gt;

&lt;p&gt;卸载ceph&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy purge {ceph-node}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个过程中主要是卸载ceph相关软件：sudo yum -y -q remove ceph ceph-release ceph-common ceph-radosgw  还将ceph源备份，因为在安装的时候是安装ceph源：/etc/yum.repos.d/ceph.repo saved as /etc/yum.repos.d/ceph.repo.rpmsave&lt;/p&gt;

&lt;p&gt;清除相关数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy purgedata {ceph-node}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是删除之前安装时在相关目录下产生的文件，可以通过手动直接删除这个文件来实现：sudo rm -rf &amp;ndash;one-file-system &amp;ndash; /var/lib/ceph &amp;amp;&amp;amp; sudo rm -rf &amp;ndash;one-file-system &amp;ndash; /etc/ceph/&lt;/p&gt;

&lt;p&gt;最后清除key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy forgetkeys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要对osd单独分配的逻辑卷进行擦除，先直接删除对应的osdN中的所有文件，然后擦除逻辑卷&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy disk zap hostname:lvname
ceph-deploy disk zap pdapp19:/dev/mapper/centos-ceph
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;操作集群&#34;&gt;操作集群&lt;/h2&gt;

&lt;h3 id=&#34;启动集群&#34;&gt;启动集群&lt;/h3&gt;

&lt;p&gt;启动所有的deamon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl start ceph.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动一个类型的所有deamon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl start ceph-osd.target
sudo systemctl start ceph-mon.target
sudo systemctl start ceph-mds.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动单独的一个deamon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl start ceph-osd@{id}
sudo systemctl start ceph-mon@{hostname}
sudo systemctl start ceph-mds@{hostname}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;停止集群&lt;/p&gt;

&lt;p&gt;停止所有的deamon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl stop ceph\*.service ceph\*.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;停止一个类型的所有deamon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl stop ceph-mon\*.service ceph-mon.target
sudo systemctl stop ceph-osd\*.service ceph-osd.target
sudo systemctl stop ceph-mds\*.service ceph-mds.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;停止单独一个deamon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl stop ceph-osd@{id}
sudo systemctl stop ceph-mon@{hostname}
sudo systemctl stop ceph-mds@{hostname}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看集群状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl status ceph\*.service ceph\*.target
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;扩展集群&#34;&gt;扩展集群&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;新增osd节点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;新增节点和一开始部署osd节点是一样的。这边以在pdapp17上新增osd节点为例。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;建目录&lt;/p&gt;

&lt;p&gt;login pdapp17
mkdir /ceph/osd2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新划分逻辑券来挂载&lt;/p&gt;

&lt;p&gt;umount /home &amp;amp;&amp;amp; lvremove /dev/centos/home &amp;amp;&amp;amp; lvcreate -L 52428800k -n ceph centos &amp;amp;&amp;amp; mkfs.xfs -i size=512 /dev/centos/ceph &amp;amp;&amp;amp; mount /dev/centos/ceph /ceph;df -h&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.准备osd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy osd prepare pdapp17:/ceph/osd2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.激活osd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy osd activate pdapp17:/ceph/osd2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用ceph -w来观察集群的变化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;新增mds节点&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy mds create {ceph-node}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;新增rgw例程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy rgw create {getway-node}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rgw例程默认端口是7480，可以修改ceph.conf来修改端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[client]
rgw frontends = civetweb port=80
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;增加mon节点&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ceph-deploy mon add {ceph-node}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ceph文件系统&#34;&gt;Ceph文件系统&lt;/h2&gt;

&lt;p&gt;首先需要创建mds&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>centos内核升级</title>
      <link>http://kingjcy.github.io/blog/2016/11/25/centos%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/</link>
      <pubDate>Fri, 25 Nov 2016 11:20:34 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/11/25/centos%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/</guid>
      <description>&lt;p&gt;最近在研究docker，在安装的时候遇到了升级内核的需求，docker需要内核在3.10.X，所以这边进行内核升级的研究。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;内核升级&#34;&gt;内核升级&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;p&gt;内核升级有两种方式：&lt;/p&gt;

&lt;p&gt;1.在elrepo源中存在内核版本，所以导入elrepo源可以直接用yum安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -import https://www.elrepo.prg/RPM-GPG-KEY-elrepo.org
Yum -enanlerepo=elrepokernel install kernel-it -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改配置文件就可以了——这个没有实际验证。我采用了编译内核的方法升级的，具体如下&lt;/p&gt;

&lt;p&gt;2.编译内核
1. 首先先看内核&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`uname -r`
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看已经安装的和未安装的软件包组，来判断我们是否安装了相应的开发环境和开发库；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum grouplist&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一般是安装这两个软件包组，这样做会确定你拥有编译时所需的一切工具
&lt;code&gt;yum groupinstall &amp;quot;Development Tools&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你必须这样才能让 make *config 这个指令正确地执行
&lt;code&gt;yum install ncurses-devel&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你没有 X 环境，这一条可以不用
&lt;code&gt;yum install qt-devel&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建 CentOS-6 内核时需要这些依赖包
&lt;code&gt;yum install hmaccalc zlib-devel binutils-devel elfutils-libelf-devel&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载内核源码&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;官网 &lt;a href=&#34;http://www.kernel.org&#34;&gt;http://www.kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可以看到有stable, longterm等版本，longterm是比stable更稳定的版本，会长时间更新，因此我选择 3.10.104。

    [root@sean ~]#wget  https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.10.104.tar.xz  貌似下不下来，直接去官网下
    [root@sean ~]# tar -xf linux-3.10.58.tar.xz -C /usr/src/
    [root@sean ~]# cd /usr/src/linux-3.10.58/
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;复制一份已有的系统配置进行修改&lt;/p&gt;

&lt;p&gt;[root@sean linux-3.10.58]# cp /boot/config-2.6.32-220.el6.x86_64 .config&lt;/p&gt;

&lt;p&gt;在配置文件中追加一些内容兼容docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG_NF_NAT_IPV4=y
CONFIG_IP_NF_TARGET_MASQUERADE=y
CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
CONFIG_MEMCG_SWAP=y
CONFIG_MEMCG_SWAP_ENABLED=y
CONFIG_AUFS_FS=y
CONFIG_DM_THIN_PROVISIONING=y
CONFIG_OVERLAY_FS=y
CONFIG_CGROUP_PERF=y
CONFIG_CFS_BANDWIDTH=y
HYPERVISOR_GUEST=y
CONFIG_VMWARE_BALLOON=m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对配置文件的修改有两种工具可以使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用make menuconfig工具来勾选选择General setup&amp;ndash;&amp;gt;Control Group support-&amp;gt;Memory Resource Controller for Control Groups，y为选择，n为未选择，m为模块&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make oldconfig会读取当前目录下的.config文件，在.config文件里没有找到的选项则提示用户填写，然后备份.config文件为.config.old，并生成新的.config文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用这个shell命令来完成配置文件的修改，就是在配置文件中没有找到选项的填y&lt;/p&gt;

&lt;p&gt;sh -c &amp;lsquo;yes &amp;ldquo;&amp;rdquo; | make oldconfig&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@sean linux-3.10.58]# make -j4 bzImage  //生成内核文件
[root@sean linux-3.10.58]# make -j4 modules  //编译模块
[root@sean linux-3.10.58]# make -j4 modules_install  //编译安装模块
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-j后面的数字是线程数，用于加快编译速度，一般的经验是，逻辑CPU，就填写那个数字，例如有8核，则为-j8。（modules部分耗时30多分钟）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改系统配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/grub.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;default改为0，就是指向配置文件中的第一个，一般新安装的在第一个&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级成功，可以查看一下&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于编译失败&lt;br /&gt;
编译过程中由于一些原因需要重新编译的，先清理环境变量，以及编译现场&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make mrproper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清除编译文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make clean
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>