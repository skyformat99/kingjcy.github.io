<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.24.1" />



<link rel="canonical" href="http://kingjcy.github.io/post/shell/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>shell 积累 - kingjcy Blog</title>
    
<meta name="description" content="&lt;p&gt;shell主要是用于linux的系统操作的脚本语言，python主要适用于web界面的，如果用python写一些linux系统的东西会比较冗余。&lt;/p&gt;&lt;p&gt;shell是一个命令解释器，也就是我们常说的bash(bash只是shell中最常用的一种，还有很多shell解释器)，是与操作系统直接进行交互的还可以支持多种编程化操作的强大工具。&lt;/p&gt;&lt;p&gt;shell是一种很强大的脚本语言，也是操作终端的利器，用好shell可以让你在linux环境开发中如鱼得水，这边别学习别记录，便于备忘与查找。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;">

<meta property="og:title" content="shell 积累 - kingjcy Blog">
<meta property="og:type" content="article">
<meta property="og:url" content="http://kingjcy.github.io/post/shell/">
<meta property="og:image" content="http://kingjcy.github.ioimages/default.png">
<meta property="og:site_name" content="kingjcy Blog">
<meta property="og:description" content="&lt;p&gt;shell主要是用于linux的系统操作的脚本语言，python主要适用于web界面的，如果用python写一些linux系统的东西会比较冗余。&lt;/p&gt;&lt;p&gt;shell是一个命令解释器，也就是我们常说的bash(bash只是shell中最常用的一种，还有很多shell解释器)，是与操作系统直接进行交互的还可以支持多种编程化操作的强大工具。&lt;/p&gt;&lt;p&gt;shell是一种很强大的脚本语言，也是操作终端的利器，用好shell可以让你在linux环境开发中如鱼得水，这边别学习别记录，便于备忘与查找。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="kingjcy Blog">
<meta name="twitter:url" content="http://kingjcy.github.io/post/shell/">
<meta name="twitter:title" content="shell 积累 - kingjcy Blog">
<meta name="twitter:description" content="&lt;p&gt;shell主要是用于linux的系统操作的脚本语言，python主要适用于web界面的，如果用python写一些linux系统的东西会比较冗余。&lt;/p&gt;&lt;p&gt;shell是一个命令解释器，也就是我们常说的bash(bash只是shell中最常用的一种，还有很多shell解释器)，是与操作系统直接进行交互的还可以支持多种编程化操作的强大工具。&lt;/p&gt;&lt;p&gt;shell是一种很强大的脚本语言，也是操作终端的利器，用好shell可以让你在linux环境开发中如鱼得水，这边别学习别记录，便于备忘与查找。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;">
<meta name="twitter:image" content="http://kingjcy.github.ioimages/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"http://kingjcy.github.io"
    },
    "headline": "shell 积累 - kingjcy Blog",
    "image": {
      "@type": "ImageObject",
      "url": "http://kingjcy.github.ioimages/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2016-03-02T17:26:28JST",
    "dateModified": "2016-03-02T17:26:28JST",
    "author": {
      "@type": "Person",
      "name": "kingjcy Blog"
    },
    "publisher": {
      "@type": "Organization",
      "name": "kingjcy Blog",
      "logo": {
        "@type": "ImageObject",
        "url": "http://kingjcy.github.ioimages/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "<p>shell主要是用于linux的系统操作的脚本语言，python主要适用于web界面的，如果用python写一些linux系统的东西会比较冗余。</p>

<p>shell是一个命令解释器，也就是我们常说的bash(bash只是shell中最常用的一种，还有很多shell解释器)，是与操作系统直接进行交互的还可以支持多种编程化操作的强大工具。</p>

<p>shell是一种很强大的脚本语言，也是操作终端的利器，用好shell可以让你在linux环境开发中如鱼得水，这边别学习别记录，便于备忘与查找。</p>

<p></p>"
  }
</script>


    <link href="http://kingjcy.github.iocss/styles.css" rel="stylesheet">
  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://kingjcy.github.io">kingjcy Blog</a>
          </div>

          
          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="http://kingjcy.github.io/post/">归档</a></li>
              
              
              
              <li><a href="http://kingjcy.github.io/about/">关于我</a></li>
              
              
            </ul>
            
          </div>
          

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="http://kingjcy.github.io"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="http://kingjcy.github.iopost/" itemprop="url"><span itemprop="title">post</span></a></li>
        
        <li class="active">shell 积累</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2016-03-02T17:26:28JST">Mar 2, 2016</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="http://kingjcy.github.iopost/">post</a></li>
      
    </ul>

    <h1 class="title">shell 积累</h1>
  </header>

  

  <div class="article-body"><p>shell主要是用于linux的系统操作的脚本语言，python主要适用于web界面的，如果用python写一些linux系统的东西会比较冗余。</p>

<p>shell是一个命令解释器，也就是我们常说的bash(bash只是shell中最常用的一种，还有很多shell解释器)，是与操作系统直接进行交互的还可以支持多种编程化操作的强大工具。</p>

<p>shell是一种很强大的脚本语言，也是操作终端的利器，用好shell可以让你在linux环境开发中如鱼得水，这边别学习别记录，便于备忘与查找。</p>

<p></p>

<h2 id="场景">场景</h2>

<p>不适合shell的场景</p>

<ol>
<li><p>密集型任务，需要计算，hash，排序</p></li>

<li><p>对跨平台和安全性有要求的</p></li>

<li><p>大量文件操作，图型操作，io和socket</p></li>
</ol>

<p>这些不适用的场景可以用强大一点的脚本语言python，ruby，perl，或者高层次的编译语言c/c++，java等。</p>

<p>##shell基本语法</p>

<ol>
<li>开头
#!/bin/sh</li>
</ol>

<p>符号#!用来告诉系统它后面的参数是用来执行该文件的程序,是一个解释器的标记。在这个例子中我们使用/bin/sh来执行程序。</p>

<pre><code>1 #!/bin/sh
2 #!/bin/bash
3 #!/usr/bin/perl 
4 #!/usr/bin/tcl 
5 #!/bin/sed -f
6 #!/usr/awk -f
</code></pre>

<ol>
<li><p>特殊字符</p>

<h1 id="注释">注释</h1>

<p>/ 转义
; 命令分隔符
;; case终止符</p>

<pre><code>case &quot;$variable&quot; in
abc) echo &quot;\$variable = abc&quot; ;; 
xyz) echo &quot;\$variable = xyz&quot; ;; 
esac
</code></pre>

<p>. source/正则中匹配任意字符
, 逗号链接了一系列的算术操作,虽然里边所有的内容都被运行了,但只有最后一项被 返回
` 后置引用,命令替换</p>

<dl>
<dd><p>空命令
$ 变量替换,在正则表达式中作为行结束符
${} 参数替换
() 命令组.如:(a=hello;echo)  在()中的命令列表,将作为一个子 shell 来运行. 在()中的变量,由于是在子 shell 中,所以对于脚本剩下的部分是不可用的. 如:</p>

<p>a=123
( a=321; )</p>

<p>echo&rdquo;a=$a&rdquo;</p>

<p>a=123</p></dd>
</dl>

<p>{} 这个结构创建了一个匿名的函数.但是与函数不同的是,在其中声明的变量,对于脚本其他部分的代码来说还是可见的,在大括号中,不允许有空白,除非这个空白是有意义的
    a=123
    ( a=321; )</p>

<pre><code>echo&quot;a=$a&quot; 

a=321
</code></pre>

<blockquote>
<p>&amp;&gt;&gt;&amp;&gt;&gt;&lt; 重定向.
scriptname &gt;filename 重定向脚本的输出到文件中.覆盖文件原有内容.
command &amp;&gt;filename 重定向 stdout 和 stderr 到文件中
command &gt;&amp;2 重定向 command 的 stdout 到 stderr
scriptname &gt;&gt;filename 重定向脚本的输出到文件中.添加到文件尾端,如果没有文件, 则创建这个文件.</p>
</blockquote>

<p>| 管道
子进程的运行的管道,不能够改变脚本的变量.
1 variable=&ldquo;initial_value&rdquo;
2 echo &ldquo;new_value&rdquo; | read variable
3 echo &ldquo;variable = $variable&rdquo; #variable = initial_value</p>

<blockquote>
<p>| 强制重定向</p>
</blockquote>

<p>|| 或-逻辑操作</p>

<pre><code>1 if [ $condition1 ] || [ $condition2 ]
2 if [ $condition1 -o $condition2 ] 相同
3 # 如果 condition1 或 condition2 为 true,那结果就为 true.
4
5 if [[ $condition1 || $condition2 ]] # 也可以
6 # 注意||不允许出现在[ ... ]中.
</code></pre>

<p>&amp;&amp; 与-逻辑操作</p>

<pre><code>1 if [ $condition1 ] &amp;&amp; [ $condition2 ]
2 与if [ $condition1 -a $condition2 ] 相同
3 # 如果 condition1 和 condition2 都为 true,那结果就为 true.
4
5 if [[ $condition1 &amp;&amp; $condition2 ]] # 也可以.
6 # 注意&amp;&amp;不允许出现在[ ... ]中.
</code></pre>

<p>- 选项,前缀.在所有的命令内如果想使用选项参数的话,前边都要加上&rdquo;-&ldquo;,之前工作的目录</p>

<p>^ 行首,正则表达式中表示行首.&ldquo;^&ldquo;定位到行首.</p>

<p>exit 退出脚本</p>

<p>((&hellip;))与 let 命令很像,允许算术扩展和赋值.举个简单的例子 a=$(( 5 + 3 )),将把 a 设为 &ldquo;5+3&rdquo;或者 8.然而,双圆括号也是一种在 Bash 中允许使用 C 风格的变量处理的机制.</p></li>

<li><p>变量</p></li>
</ol>

<p>在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明，直接赋值就可以，应用变量的话，用$+变量名的形式。</p>

<p><strong>等号前后不能有空格,如果赋值后面是执行语句，需要用<code>来表示，执行语句都是用</code>都可以不一定语句后</strong></p>

<p>数组</p>

<pre><code>A=(1 1 2 3)  定义
${A[i]}    取数组的值,重0开始的
${A[@]}     显示所有的参数
${#A[@]}    显示参数的个数
${A[@]/1/2}  将一换成2
unset A[2]  删除A[2]
</code></pre>

<p>函数</p>

<pre><code>function command()
{

}
</code></pre>

<ol>
<li><p>重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。</p>

<blockquote>
<p>写入文件并覆盖旧文件
&gt; 加到文件的尾部，保留旧文件内容。</p>
</blockquote></li>

<li><p>流程控制</p></li>
</ol>

<p>判断</p>

<pre><code>if .... then 
.... 
elif .... then 
.... 
else 
.... 
fi

当 if 和 then 在一个条件测试的同一行中的话,必须使用&quot;;&quot;


通常用&quot; [ ] &quot;来表示条件测试。注意这里的空格很重要。要确保方括号的空格。 
[ -f &quot;somefile&quot; ] ：判断是否是一个文件 
[ -x &quot;/bin/ls&quot; ] ：判断/bin/ls是否存在并有可执行权限 
[ -n &quot;$var&quot; ] ：判断$var变量是否有值 
[ &quot;$a&quot; = &quot;$b&quot; ] ：判断$a和$b是否相等 ,注意“=”和变量之间要有空格。
多重条件可以用&amp;&amp;或者||来逻辑判断，但是用两个[]来使用，例如[]||[]

1.整数比较 
-eq 等于,如:if [ &quot;$a&quot; -eq &quot;$b&quot; ]   
-ne/!= 不等于,如:if [ &quot;$a&quot; -ne &quot;$b&quot; ] 
-gt 大于,如:if [ &quot;$a&quot; -gt &quot;$b&quot; ]   
-ge 大于等于,如:if [ &quot;$a&quot; -ge &quot;$b&quot; ]   
-lt 小于,如:if [ &quot;$a&quot; -lt &quot;$b&quot; ]   
-le 小于等于,如:if [ &quot;$a&quot; -le &quot;$b&quot; ]   
&lt;   小于(需要双括号),如:((&quot;$a&quot; &lt; &quot;$b&quot;))   
&lt;=  小于等于(需要双括号),如:((&quot;$a&quot; &lt;= &quot;$b&quot;))   
&gt;   大于(需要双括号),如:((&quot;$a&quot; &gt; &quot;$b&quot;))   
&gt;   &gt;=  大于等于(需要双括号),如:((&quot;$a&quot; &gt;= &quot;$b&quot;))   



2.字符串比较

= 等于,如:if [ &quot;$a&quot; = &quot;$b&quot; ]   
== 等于,如:if [ &quot;$a&quot; == &quot;$b&quot; ],与=等价  




[[ $a == z* ]]   # 如果$a以&quot;z&quot;开头(模式匹配)那么将为true   
[[ $a == &quot;z*&quot; ]] # 如果$a等于z*(字符匹配),那么结果为true   

  [ $a == z* ]     # File globbing 和word splitting将会发生   
  [ &quot;$a&quot; == &quot;z*&quot; ] # 如果$a等于z*(字符匹配),那么结果为true



还有一些参数的比较见下面一个专题
</code></pre>

<p>循环</p>

<pre><code>while
while表达式： ----------while read line    这边的line只是一个变量，read应该读到换行符就解释
while ...; do 
.... 
done &lt; filename   -----追加文件输入

可以用关键字&quot;break&quot; 用来跳出循环；也可以用关键字”continue”用来不执行余下的部分而直接跳到下一个循环。大部分和for差不多，但是有一些必须使用while，比如无限循环。一般和read一起使用对文件进行操作，比如行操作，read line大部分和for差不多，但是有一些必须使用while，比如无限循环。一般和read一起使用，read读取数据。，read读取数据。

for var in ....; do 
.... 
done 

在一个 for 循环中忽略[list]的话,将会使循环操作$@(从命令行传递给脚本的参数

也可以使用命令替换来产生 for 循环的[list],例如`seq 1 15`

for在shell中十分强大，它在批量操作，批量部署上有这个很大的优势。

until 条件
do
done

直到条件满足才退出
</code></pre>

<p>选择</p>

<pre><code>case &quot;$variable&quot; in
&quot;$condition1&quot;) command...
;;
&quot;$condition1&quot;) command...
;;
esac
注意: 对变量使用&quot;&quot;并不是强制的,因为不会发生单词分离. 每句测试行,都以右小括号)结尾.
每个条件块都以两个分号结尾;;.
case 块的结束以 esac(case 的反向拼


select i in var
do
done

一般与变量PS3结合使用

PS3=&quot;what do you like:&quot;
selct i in centos ubuntu readhat
do 
    echo &quot;you like $i&quot;
done

1)centos
2)ubuntu
3)readhat
what do you like:1
you like centos

可以结合上面的case进行步骤操作。
</code></pre>

<h2 id="awk">awk</h2>

<p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>

<p><strong>使用方法</strong></p>

<p>awk &lsquo;{pattern + action}&rsquo; {filenames}
尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</p>

<p>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p>

<p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>

<p><strong>实例</strong></p>

<pre><code>[root@www ~]# last -n 5 &lt;==仅取出前五行
root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in
root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)
root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)
dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)
root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)
</code></pre>

<p>如果只是显示最近登录的5个帐号</p>

<pre><code>#last -n 5 | awk  '{print $1}'
root
root
root
dmtsai
root
</code></pre>

<p>awk工作流程是这样的：读入有&rsquo;\n&rsquo;换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&rdquo;空白键&rdquo; 或 &ldquo;[tab]键&rdquo;,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p>

<p>NF最后一行，NR是最后一列。</p>

<p>指定分隔符 awk -F: &lsquo;{print &ldquo;01: &ldquo;$1}&lsquo;,这个就以：分域了。可以在print中添加注解，相当于拼接字符串。</p>

<p>简单用法，有时间继续补充</p>

<h2 id="空格">空格</h2>

<ol>
<li>等号赋值两边不能有空格, var=string command,针对=后面跟上命令的，可以有空格，但是后面的命令必须要用``来执行，注意</li>
<li>命令与选项之间需要空格</li>
<li>管道两边空格可有可无</li>
</ol>

<h2 id="sed">sed</h2>

<p>sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法</p>

<p>sed命令行格式为：</p>

<pre><code>sed [-nefri] ‘command’ 输入文本

常用选项：
    -n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
    -e∶直接在指令列模式上进行 sed 的动作编辑；
    -f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；
    -r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
    -i∶直接修改读取的档案内容，而不是由萤幕输出。 不加则不修改源文件      

常用命令：
     a   ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
     c   ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
     d   ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
     i   ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
     p  ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～
     s  ∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

主要用于查找替换

sed &quot;s/a/b/g&quot; filename      替换，b替换a
sed &quot;s/^/&amp; /g&quot; filename     开头是^,结尾是$,添加&amp;，这些都是正则里面的，可以用于其他的比如grep，学会举一反三
sed &quot;/a/a b/&quot; filename      查找追加，追加a，在前面加i
sed &quot;1p&quot;                    打印第一行，一到五行1，5p，匹配打印这一行/a/p,最后一行$p

例如：

1. 在文件最后追加一些内容，常用于配置

sed -i &quot;$a 内容&quot; filename 可以用于追加内容，但是觉得还是直接用echo &quot;&quot; &gt;&gt; filename好一点

2.还可以在每个行首行尾追加内容

sed -i &quot;s/$/&amp; 内容/g&quot; filename
</code></pre>

<h2 id="变量">$变量</h2>

<p>特殊变量列表</p>

<pre><code>变量     含义
$0     当前脚本的文件名
$n     传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
$#     传递给脚本或函数的参数个数。
$*     传递给脚本或函数的所有参数。
$@     传递给脚本或函数的所有参数。被双引号(&quot; &quot;)包含时，与 $* 稍有不同，下面将会讲到。
$?     上个命令的退出状态，或函数的返回值。0表示成功，可以用于脚本的命令执行状态的判断。
$$     当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID
</code></pre>

<p>开头
    #!/bin/sh</p>

<h3 id="多台服务器">多台服务器</h3>

<p>ue是很好的文本编辑器，用于处理文本编辑上具有很大的优势，包括块处理，替换，编码上，要学会用它来编辑我们需要的文档，比如今天的ip端口的整理替换用于shell脚本来跑</p>

<ol>
<li><p>安装redis</p>

<p>redis=(10.147.0.1 10.147.0.107 10.147.0.16 10.147.0.31 10.147.0.17 10.147.0.32 10.147.0.46 10.147.0.61 10.147.0.47 10.147.0.62 10.147.0.76 10.147.0.91 10.147.0.77 10.147.0.92)</p></li>
</ol>

<p>这边给变量赋值，这些ip在ue中可以很好的处理。等于号前后不能有空格，数组就是用大括号和逗号来表达</p>

<pre><code>for x in ${redis[@]}
do
ssh $x -t &quot;mkdir -p /root/redis&quot;
done

for x in ${redis[@]};do scp redis-3.2.8.tar.gz root@$x:/root/redis; done
</code></pre>

<p>这边把安装包重一台机器上复制到所有的机器上。-t 该参数通过指定一个伪终端迫使SecureShell客户端以交互模式工作，即使在给定命令的情况下也是如此。它被用于执行在远地主机上的基于屏幕的程序。通过-t参数来执行后面的命令，然后退出。</p>

<pre><code>for x in ${redis[@]}
do 
ssh $$x -t &quot;tar -zxf redis-3.2.8.tar.gz &amp;&amp; cd redis-3.2.8 &amp;&amp; make &amp;&amp; make PREFIX=/usr/lib/redis install &amp;&amp; chown -R  hnapp:hnapp /usr/lib/redis &amp;&amp; chmod 777 -R /usr/lib/redis&quot;&quot;
done
</code></pre>

<p>这边就是把所有的机器上安装上redis,可以将所有的命令进行联合用&amp;&amp;。这样用shell的for循环在一台机器上处理所有机器的安装，可以大幅度提高工作效率和减少出错。</p>

<p>修改所有机器的密码</p>

<pre><code>for x in ${cxx[@]}; do ssh $x -t &quot;echo Rljgvz0j | passwd --stdin root&quot;; done
</code></pre>

<ol>
<li><p>创建集群的配置文件</p>

<p>for x in ${redis[@]}; do ssh $x -t &ldquo;mkdir /usr/lib/redis/conf&rdquo;; done
cd /usr/lib/redis/conf
vi redis-common.conf
for x in ${redis[@]}; do scp redis-common.conf $x:<code>pwd</code>; done</p></li>
</ol>

<p>可以这样创建一个公共配置文件include在每个配置文件中,这边有一个pwd指令是指当前目录，上面这个是正常的方法，下面我们来使用单个配置文件</p>

<p>首先在一台机器上创建一个配置文件redis-.conf，在文件文件中需要改变的设置为变量</p>

<pre><code>daemonize yes
tcp-backlog 511
timeout 0
tcp-keepalive 0
loglevel notice
databases 16
dir xccccccccccccccccccc
slave-serve-stale-data yes
slave-read-only yes
repl-disable-tcp-nodelay yes
slave-priority 100
appendonly yes
appendfsync everysec
no-appendfsync-on-rewrite yes
auto-aof-rewrite-min-size 64mb
lua-time-limit 5000
cluster-enabled yes
cluster-node-timeout 15000
cluster-migration-barrier 1
slowlog-log-slower-than 10000
slowlog-max-len 128
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
port 6379
maxmemory cxxxxxxxxxxxxx
maxmemory-policy allkeys-lru
appendfilename &quot;appendonly-6379.aof&quot;
dbfilename dump-6379.rdb
cluster-config-file nodes-6379.conf
auto-aof-rewrite-percentage 80-100
logfile xcxcxcxcxcxcxcxcxcxc
protected-mode no
</code></pre>

<p>然后写脚本redis_install.sh来替换变量，生成对应的配置文件</p>

<pre><code>#!/bin/bash                                                     ----shell脚本的可执行文件，类似的python都是这样声明

clusterName=$1                                                  ----获取shell的参数$1-n
memCache=$2 

----因为嵌套在下面的循环中，会导致冲突，所有这边单独拿出来跑一边
rm -f mkredisdir.sh
echo &quot;#!/bin/bash&quot; &gt;&gt; mkredisdir.sh
cat redis_$clusterName.txt | awk -F'[: ]' '{for(i=2;i&lt;=NF;i++){printf(&quot;ssh %s -ttt \&quot;mkdir -p /data1/redis/%s\&quot; \n&quot;,$1,$i)}}' &gt;&gt; mkredisdir.sh  ----NF最后一行，NR是最后一列。
chmod 755 mkredisdir.sh
./mkredisdir.sh
if [ $? -ne 0 ];then
    exit 1
fi




while read line                                                 ----while循环结构do,done,读一行read line
do
    IP=`echo ${line} |  awk -F: '{print $1}'`                   ----获取文件中一行的ip,awk对line进行域划分，这边获取第一域            
    dirName=`echo /usr/lib/redis/conf/$clusterName/`            ----获取文件名，这个shell中用``来执行命令，获取对结果给变量
    portList=(`echo ${line} |  awk -F: '{print $2}' | tr -d '|'`)   ----这边获取端口list,用tr删除所有的|
    for x in ${portList[@]}                                         ----在端口中循环
    do

        logfile=&quot;/data1/redis/$x/$x.log&quot;                            ----获取日志文件名
        tmpFileName=/tmp/redis-$x.conf                              ----临时文件名,tmp目录下系统是自动清理的，一般清理十天前的文件
        sed &quot;s/6379/$x/g&quot; redis-.conf &gt; $tmpFileName                ----把redis-.conf文件中的6379替换为变量$x重写到新文件中
        sed -i &quot;s#xccccccccccccccccccc#/data1/redis/$x#g&quot; $tmpFileName  ----这边是把新文件中的xccccccccccccccccccc替换为/data1/redis/$x，如果变量中含有／就用#
        sed -i &quot;s/cxxxxxxxxxxxxx/$memCache/g&quot; $tmpFileName
        sed -i &quot;s#xcxcxcxcxcxcxcxcxcxc#$logfile#g&quot; $tmpFileName
        scp $tmpFileName $IP:${dirName}/                                ----将对应的配置文件拷贝到对应主机的目录下
        if [ $? -ne 0 ];then                                            ----如果失败则退出
            echo &quot;scp  $tmpFileName to $IP failed.&quot;
            exit 1
        fi
    done
done &lt; redis_${clusterName}.txt                                         ----输入文件
</code></pre>

<p>写脚本的时候可以使用-X来调试shell脚本，&rdquo;-x&rdquo;选项可用来跟踪脚本的执行，是调试shell脚本的强有力工具。“-x”选项使shell在执行脚本的过程中把它实际执行的每一个命令行显示出来，并且在行首显示一个&rdquo;+&ldquo;号。 &ldquo;+&ldquo;号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令。 “-x”选项使用起来简单方便，可以轻松对付大多数的shell调试任务,应把其当作首选的调试手段。
这边需要看一下解析的文件才能看懂</p>

<pre><code>10.147.0.1:6000 6001
10.147.0.107:6020 6021
10.147.0.16:6040 6041
10.147.0.31:6060 6061
10.147.0.17:6080 6081
10.147.0.32:6100 6101
10.147.0.46:6120 6121
10.147.0.61:6140 6141
10.147.0.47:6160 6161
10.147.0.62:6180 6181
10.147.0.76:6200 6201
10.147.0.91:6220 6221
10.147.0.77:6240 6241
10.147.0.92:6260 6261
</code></pre>

<p>这样就可以生成所有redis需要的配置文件并且在对应的主机路径,下面就是启动所有的redis</p>

<pre><code>for x in ${redis[@]}; do ssh $x; done  -------这样可以按循序一台台主机上进行操作，然后没有把握的大批量数据就这样操作，如果又把我可以直接ssh $x -t ``
find /usr/lib/redis/conf/ -name &quot;*.conf&quot; |  xargs -i /usr/lib/redis/bin/redis-server {}  ----获取的序列可以直接给{}
</code></pre>

<p>启动好后就要给redis配备集群角色了，先安装ruby，gem,以及redis的gem包</p>

<pre><code>for x in ${redis[@]}; do  ssh $x -t &quot;yum install -y ruby;gem install -l redis-3.2.2.gem&quot;; done
</code></pre>

<p>然后生成tb脚本</p>

<p>首先上面的文件处理成ip:port</p>

<pre><code>awk '{

for(i=2;i&lt;=NF;i++){
    if (i!=NF){
        printf(&quot;%s:%s &quot;,$1,$i)
    }else{
        printf(&quot;%s:%s \n&quot;,$1,$i)}
}

}' REDIS_W_DICT_NAT.txt &gt; REDIS_W_DICT_NAT_cluster.txt
</code></pre>

<p>然后生成shell脚本createsh.sh来生成对应的ruby脚本</p>

<pre><code>#!/bin/bash

fileName=$1                                                                         ----正常获取启动参数
masterList=`awk '{for(i=1;i&lt;=NF;i++){                                               ----按行循环，如果这一列是奇数则取奇数位，偶数则取偶数位，最终获取所有的主的ip和port
    if(NR%2!=0){
        if(i%2!=0){
            printf(&quot;\&quot;%s\&quot;,&quot;,$i)
        }
    }else{
        if(i%2==0){
            printf(&quot;\&quot;%s\&quot;,&quot;,$i)
        }
    }
    }
}' $fileName`


masterListForStr=`echo $masterList | tr -s ',' ' ' | tr -d '&quot;'`                     ----将重复的空格和逗号都删除，并删除引号
masterList=`echo [${masterList%,}]`                                                     


num=1
master=&quot;&quot;
slave=&quot;&quot;
cxx1=(`sed -n '1'p $fileName`)                                                      ----p是打印对应的行，这个就是获取第一行
cxx2=(`sed -n '2'p $fileName`)
cxx3=(`sed -n '3'p $fileName`)
cxx4=(`sed -n '4'p $fileName`)
cxx5=(`sed -n '5'p $fileName`)
cxx6=(`sed -n '6'p $fileName`)
cxx7=(`sed -n '7'p $fileName`)
cxx8=(`sed -n '8'p $fileName`)
cxx9=(`sed -n '9'p $fileName`)
cxx10=(`sed -n '10'p $fileName`)
cxx11=(`sed -n '11'p $fileName`)
cxx12=(`sed -n '12'p $fileName`)
cxx13=(`sed -n '13'p $fileName`)
cxx14=(`sed -n '14'p $fileName`)

lineCount=`awk 'END{print NF}' $fileName`                                           ----end是指处理完所有的执行，这边就是获取一行有多少个数据

num=0
num2=1
while [ $num -lt $lineCount ]
do
    eval str1='$'{cxx1[${num}]}                                                     ----存在变量的变量需要用eval，获取第一列的所有数据
    eval str2='$'{cxx2[${num}]}
    eval str3='$'{cxx3[${num}]}
    eval str4='$'{cxx4[${num}]}
    eval str5='$'{cxx5[${num}]}
    eval str6='$'{cxx6[${num}]}
    eval str7='$'{cxx7[${num}]}
    eval str8='$'{cxx8[${num}]}
    eval str9='$'{cxx9[${num}]}
    eval str10='$'{cxx10[${num}]}
    eval str11='$'{cxx11[${num}]}
    eval str12='$'{cxx12[${num}]}
    eval str13='$'{cxx13[${num}]}
    eval str14='$'{cxx14[${num}]}

    res=`expr $num2 % 2`                                                            ----执行算数用expr
    if [ &quot;X$res&quot; = &quot;X1&quot; ];then                                                      ----奇数重上往下，偶数重下往上，生成上下key/value结构，json格式
        str=&quot;$str,\&quot;${str1}\&quot;:\&quot;${str2}\&quot;,\&quot;${str3}\&quot;:\&quot;${str4}\&quot;,\&quot;${str5}\&quot;:\&quot;${str6}\&quot;,\&quot;${str7}\&quot;:\&quot;${str8}\&quot;,\&quot;${str9}\&quot;:\&quot;${str10}\&quot;,\&quot;${str11}\&quot;:\&quot;${str12}\&quot;,\&quot;${str13}\&quot;:\&quot;${str14}\&quot;&quot;
    else
        str=&quot;$str,\&quot;${str14}\&quot;:\&quot;${str13}\&quot;,\&quot;${str12}\&quot;:\&quot;${str11}\&quot;,\&quot;${str10}\&quot;:\&quot;${str9}\&quot;,\&quot;${str8}\&quot;:\&quot;${str7}\&quot;,\&quot;${str6}\&quot;:\&quot;${str5}\&quot;,\&quot;${str4}\&quot;:\&quot;${str3}\&quot;,\&quot;${str2}\&quot;:\&quot;${str1}\&quot;&quot;
    fi  

    ((num = num + 1))
    ((num2 = num2 + 1))
done

#echo $master
str=`echo $str | cut -c 2-`                                                         ----删除第一个逗号
str=`echo &quot;{$str}&quot;`

slaveListForStr=`/usr/bin/python &lt;&lt;EOF                                              ----开始结束,将python嵌入到shel中，输出字符直接给一个变量

allDict=$str                                                                        ----将json格式到字符串给python中到数组，类似于c++中到vector
masterList=$masterList
slaveStr=&quot;&quot;
for master in masterList:
    slaveStr=slaveStr + &quot; &quot; + allDict[master]                                       ----进行匹配
    print slaveStr


EOF`
echo &quot;/root/redis-3.2.8/src/redis-trib.rb create --replicas 1 &quot;$masterListForStr$slaveListForStr
</code></pre>

<p>然后生成redis官方的tb脚本</p>

<pre><code>/root/redis-3.2.8/src/redis-trib.rb create --replicas 1 ip:port                 -------这边是先都是主后面都是备，一一对应，这个脚本有自己均衡m/s的功能，不一定会按着对应分配master和slave，但是正常情况下都是对应的。
</code></pre>

<p>由此可见shell的自动化脚本确实很强大，可以解决很多问题。</p>

<h2 id="test结构">test结构</h2>

<p>if test condition-true 这种形式和 if[condition-true]这种形式是等价的</p>

<p>有一个专用命令&rdquo;[&ldquo;(左中括号,特殊字符).这个命令与 test 命令等价。在版本 2.02 的 Bash 中,推出了一个新的[[&hellip;]]扩展 test 命令.因为这种表现形式可能对某些语 言的程序员来说更加熟悉.注意&rdquo;[[&ldquo;是一个关键字,并不是一个命令.</p>

<p>Bash 把[[ $a -lt $b ]]看作一个单独的元素,并且返回一个退出码.</p>

<p>[-f filename]相当于判断文件是否存在</p>

<p>[-d dir]        判断目录是否存在</p>

<p>[ -n string ]  –n 字符串 字符串的长度非零</p>

<p>[ -z string ]  字符串的长度零</p>

<p>[ -a FILE ] 如果 FILE 存在则为真。</p>

<p>[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。</p>

<p>[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。</p>

<p>[ -d FILE ] 如果 FILE 存在且是一个目录则为真。</p>

<p>[ -e FILE ] 如果 FILE 存在则为真。</p>

<p>[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</p>

<p>[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</p>

<p>[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。</p>

<p>[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</p>

<p>[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</p>

<p>[ -r FILE ] 如果 FILE 存在且是可读的则为真。</p>

<p>[ -s FILE ] 如果 FILE 存在且大小不为0则为真。</p>

<p>[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。</p>

<p>[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</p>

<p>[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。</p>

<p>[ -x FILE ] 如果 FILE 存在且是可执行的则为真。</p>

<p>[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。</p>

<p>[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</p>

<p>[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。</p>

<p>[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。</p>

<p>[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。</p>

<h3 id="shell内建变量">shell内建变量</h3>

<pre><code>$BASH
这个变量将指向 Bash 的二进制执行文件的位置.

$BASH_ENV
这个环境变量将指向一个 Bash 启动文件,这个启动文件将在调用一个脚本时被读取.

$BASH_SUBSHELL
这个变量将提醒 subshell 的层次,这是一个在 version3 才被添加到 Bash 中的新特性.

$BASH_VERSINFO[n]
记录 Bash 安装信息的一个 6 元素的数组.与下边的$BASH_VERSION 很像

$DIRSTACK
在目录栈中最上边的值

$EDITOR
脚本调用的默认编辑器,一般是 vi 或者是 emacs.

$EUID
&quot;effective&quot;用户 ID 号.

$FUNCNAME 当前函数的名字.

$GLOBIGNORE
一个文件名的模式匹配列表

$GROUPS
当前用户属于的组.

$HOME
用户的 home 目录

$HOSTNAME
hostname 命令将在一个 init 脚本中,在启动的时候分配一个系统名字. gethostname()函数将用来设置这个$HOSTNAME 内部变量

$HOSTTYPE
主机类型

$IFS 内部域分隔符.

$IGNOREEOF
忽略 EOF

$LC_COLLATE
常在.bashrc 或/etc/profile 中设置,这个变量用来在文件名扩展和模式匹配校对顺序. 如果$LC_COLLATE 被错误的设置,那么将会在 filename globbing 中引起错误的结果.

$LC_CTYPE
这个内部变量用来控制 globbing 和模式匹配的字符串解释.

$LINENO
这个变量记录它所在的 shell 脚本中它所在行的行号.这个变量一般用于调试目的.

$MACHTYPE
系统类型

$OLDPWD你所在的之前的目录

$OSTYPE 操作系统类型.

$PATH
指向 Bash 外部命令所在的位置

$PIPESTATUS
数组变量将保存最后一个运行的前台管道的退出码

$PPID
一个进程的$PPID 就是它的父进程的进程

$PROMPT_COMMAND 这个变量保存一个在主提示符($PS1)显示之前需要执行的命令

$PS1  2  3  4 提示符

$PWD 工作目录(你当前所在的目录). 与 pwd 内建命令作用相同.

$SHELLOPTS
这个变量里保存 shell 允许的选项,这个变量是只读

$SHLVL
Shell 层次

$TMOUT
如果$TMOUT 环境变量被设置为一个非零的时间值,那么在过了这个指定的时间之后, shell 提示符将会超时,这会引起一个 logout.

$UID
用户 ID 号.
当前用户的 id 号,在/etc/passwd 中记录.
这个值不会因为用户使用了 su 命令而改变.$UID 是只读变量,不容易在命令行或者是脚 本中被修改,并且和内建的 id 命令很相像.

$SECONDS 这个脚本已经运行的时间(单位为秒).

$RANDOM: 产生随机整数
</code></pre>

<h3 id="字符串">字符串</h3>

<pre><code>${#string}
expr length $string 
expr &quot;$string&quot; : '.*'

1 stringZ=abcABC123ABCabc 
3 echo ${#stringZ}
4 echo `expr length $stringZ`                  -------表达式变量的值，一般用于整数值，也可用于字符串。·
5 echo `expr &quot;$stringZ&quot; : '.*'`

15
15
15

expr match &quot;$string&quot; '$substring' $substring 是一个正则表达式
expr &quot;$string&quot; : '$substring' $substring 是一个正则表达式     
两者相等


 stringZ=abcABC123ABCabc
 2 # |------|
 3
 4 echo `expr match &quot;$stringZ&quot; 'abc[A-Z]*.2'`
 5 echo `expr &quot;$stringZ&quot; : 'abc[A-Z]*.2'`

 8
 8

expr index $string $substring 匹配到子串的第一个字符的位置.

截取
${string:position}
在 string 中从位置$position 开始提取子串.
如果$string 为&quot;*&quot;或&quot;@&quot;,那么将提取从位置$position 开始的位置参数
${string:position:length}
在 string 中从位置$position 开始提取$length 长度的子串.


反向截取
echo ${stringZ:-4}     
# 以${parameter:-default}方式,默认是提取完整地字符串.
echo ${stringZ:(-4)}
echo ${stringZ: -4}
# 现在,它可以工作了.
# 使用圆括号或者添加一个空格来转义这个位置参数.


abcABC123ABCabc
Cabc
Cabc

expr substr $string $position $length
在 string 中从位置$position 开始提取$length 长度的子串.


子串削除
${string#substring}
从$string 的左边截掉第一个匹配的$substring
${string##substring}
从$string 的左边截掉最后一个个匹配的$substring
${string%substring}
从$string 的右边截掉第一个匹配的$substring
${string%%substring}
从$string 的右边截掉最后一个匹配的$substrin  expr substr $string $position $length
在 string 中从位置$position 开始提取$length 长度的子串.


子串替换
${string/substring/replacement}
使用$replacement 来替换第一个匹配的$substring.
${string//substring/replacement}
使用$replacement 来替换所有匹配的$substring.
${string/#substring/replacement}
如果$substring 匹配$string 的开头部分,那么就用$replacement 来替换$substring.
${string/%substring/replacement}
如果$substring 匹配$string 的结尾部分,那么就用$replacement 来替换$substring.

字符串扩展
${parameter}
与$parameter 相同,就是 parameter 的值.
${parameter-default},${parameter:-default} 如果 parameter 没被 set,那么就使用 default.
${parameter=default},${parameter:=default}
如果 parameter 未设置,那么就设置为 default.
${parameter+alt_value},${parameter:+alt_value}
如果 parameter 被 set 了,那就使用 alt_value,否则就使用 null 字符串.
${parameter?err_msg}, ${parameter:?err_msg}
如果 parameter 被 set,那就是用 set 的值,否则 print err_msg.

变量长度/子串删除 ${#var}
字符串长度($var 的字符数量).对于一个数组,${#array}是数组中第一个元素的长度.
一些例外:
${#*}和${#@}将给出位置参数的个数. 对于数组来说${#array[*]}和${$#array[@]}将给出数组元素的个数.
${var#Pattern}, ${var##Pattern}
从$var 开头删除最近或最远匹配$Pattern 的子串.
${var%Pattern}, ${var%%Pattern}
从$var 结尾删除最近或最远匹配$Pattern 的子串.



变量扩展/子串替换
这些结构都是从 ksh 中吸收来的.
${var:pos}
变量 var 从位置 pos 开始扩展.
${var:pos:len}
从位置 pos 开始,并扩展 len 长度个字符.见 Example A-14(这个例子里有这种操作的一个 创造性用法)
${var/Pattern/Replacement}
使用 Replacement 来替换 var 中的第一个 Pattern 的匹配.
${var//Pattern/Replacement}
全局替换.在 var 中所有的匹配,都会用 Replacement 来替换.
向上边所说,如果 Replacement 被忽略的话,那么所有匹配到的 Pattern 都会被删除.
${var/#Pattern/Replacement}
如果 var 的前缀匹配到了 Pattern,那么就用 Replacement 来替换 Pattern.
${var/%Pattern/Replacement}
如果 var 的后缀匹配到了 Pattern,那么就用 Replacement 来替换 Pattern.

间接引用
a=letter_of_alphabet
letter_of_alphabet=z
echo 
# 直接引用.
echo &quot;a = $a&quot;
# 间接引用.
eval a=\$$a
echo &quot;Now a = $a&quot;


a = letter_of_alphabet
Now a = z
</code></pre>

<h2 id="内建命名">内建命名</h2>

<p>I/O</p>

<pre><code>echo
打印(到 stdout)一个表达式或变量
</code></pre>

<h2 id="系统增量备份和全量备份">系统增量备份和全量备份</h2>

<p>全量备份</p>

<pre><code>tar -g /tmp/snop -zcvf /tmp/sh.tar.gz /data/sh ------ -g /tmp/snop就是建立了一个快照，便于下面增量备份坐参考，重新全量备份，只要把这个快照删除就行了
</code></pre>

<p>增量备份</p>

<pre><code>tar -g /tmp/snop -zxcf /tmp/sh_add.tar.gz /data/sh --------这边的快照名要和上面全量的一样，但是tar包名不能一样。
</code></pre>

<p>然后就可以用corntab来每天跑这个脚本，在这个脚本历可以设置每周日进行全量备份，其他时间进行增量备份</p>

<h2 id="tmp-snop就是建立了一个快照-便于下面增量备份坐参考-重新全量备份-只要把这个快照删除就行了">/tmp/snop就是建立了一个快照，便于下面增量备份坐参考，重新全量备份，只要把这个快照删除就行了</h2>

<p>增量备份</p>

<pre><code>tar -g /tmp/snop -zxcf /tmp/sh_add.tar.gz /data/sh --------这边的快照名要和上面全量的一样，但是tar包名不能一样。
</code></pre>

<p>然后就可以用corntab来每天跑这个脚本，在这个脚本历可以设置每周日进行全量备份，其他时间进行增量备份</p></div>

  <footer class="article-footer">
    
    
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">TAGS</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="http://kingjcy.github.iotags/shell/">shell</a></li>
          
          <li><a href="http://kingjcy.github.iotags/tool/">tool</a></li>
          
        </ul>
      </div>
    </section>
    
    
  </footer>

</article>


    
  </div>

  <div class="col-md-4">
    
<aside class="l-sidebar">

  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="http://kingjcy.github.io/post/restful/" class="list-group-item">restful架构</a>
      
      <a href="http://kingjcy.github.io/post/rbac/" class="list-group-item">rbac框架</a>
      
      <a href="http://kingjcy.github.io/post/beego/" class="list-group-item">从harbor入手beego框架</a>
      
      <a href="http://kingjcy.github.io/post/chrome-dev-tool/" class="list-group-item">chrome的开发者工具</a>
      
      <a href="http://kingjcy.github.io/post/gulp/" class="list-group-item">gulp</a>
      
      <a href="http://kingjcy.github.io/post/typescript/" class="list-group-item">typescript</a>
      
      <a href="http://kingjcy.github.io/post/web/" class="list-group-item">web</a>
      
      <a href="http://kingjcy.github.io/post/mac/" class="list-group-item">mac os</a>
      
      <a href="http://kingjcy.github.io/post/go/" class="list-group-item">go积累</a>
      
      <a href="http://kingjcy.github.io/post/kickstart/" class="list-group-item">kickstart</a>
      
    </div>
  </section>

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">CATEGORY</div>
    </div>
    <div class="list-group">
      
      <a href="http://kingjcy.github.iocategories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0" class="list-group-item">技术文章</a>
      
      <a href="http://kingjcy.github.iocategories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F" class="list-group-item">人生感悟</a>
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
      <a href="http://kingjcy.github.iotags/tool" class="list-group-item">tool</a>
      
      <a href="http://kingjcy.github.iotags/linux" class="list-group-item">linux</a>
      
      <a href="http://kingjcy.github.iotags/go" class="list-group-item">go</a>
      
      <a href="http://kingjcy.github.iotags/language" class="list-group-item">language</a>
      
      <a href="http://kingjcy.github.iotags/redis" class="list-group-item">redis</a>
      
      <a href="http://kingjcy.github.iotags/thought" class="list-group-item">thought</a>
      
      <a href="http://kingjcy.github.iotags/centos" class="list-group-item">centos</a>
      
      <a href="http://kingjcy.github.iotags/ceph" class="list-group-item">ceph</a>
      
      <a href="http://kingjcy.github.iotags/database" class="list-group-item">database</a>
      
      <a href="http://kingjcy.github.iotags/fs" class="list-group-item">fs</a>
      
    </div>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p>Copyright (c) 2017. All rights reserved.</p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

