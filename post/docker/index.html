<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.24.1" />



<link rel="canonical" href="http://kingjcy.github.io/post/docker/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>docker入门与实践 - kingjcy Blog</title>
    
<meta name="description" content="&lt;p&gt;docker是一种应用容器化的技术，就是一个容器，类似于logo中的集装箱运行在操作系统这只大鲸鱼上。&lt;/p&gt;&lt;p&gt;docker容器化，类似于虚拟机，但是相对于虚拟机：运行速度快，占用资源少，通过git获取方便，通过dockerfile配置灵活，也不一定不安全,而且docker可以快速交付部署，减少环境问题，轻松迁移扩展，简单管理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;">

<meta property="og:title" content="docker入门与实践 - kingjcy Blog">
<meta property="og:type" content="article">
<meta property="og:url" content="http://kingjcy.github.io/post/docker/">
<meta property="og:image" content="http://kingjcy.github.ioimages/default.png">
<meta property="og:site_name" content="kingjcy Blog">
<meta property="og:description" content="&lt;p&gt;docker是一种应用容器化的技术，就是一个容器，类似于logo中的集装箱运行在操作系统这只大鲸鱼上。&lt;/p&gt;&lt;p&gt;docker容器化，类似于虚拟机，但是相对于虚拟机：运行速度快，占用资源少，通过git获取方便，通过dockerfile配置灵活，也不一定不安全,而且docker可以快速交付部署，减少环境问题，轻松迁移扩展，简单管理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="kingjcy Blog">
<meta name="twitter:url" content="http://kingjcy.github.io/post/docker/">
<meta name="twitter:title" content="docker入门与实践 - kingjcy Blog">
<meta name="twitter:description" content="&lt;p&gt;docker是一种应用容器化的技术，就是一个容器，类似于logo中的集装箱运行在操作系统这只大鲸鱼上。&lt;/p&gt;&lt;p&gt;docker容器化，类似于虚拟机，但是相对于虚拟机：运行速度快，占用资源少，通过git获取方便，通过dockerfile配置灵活，也不一定不安全,而且docker可以快速交付部署，减少环境问题，轻松迁移扩展，简单管理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;">
<meta name="twitter:image" content="http://kingjcy.github.ioimages/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"http://kingjcy.github.io"
    },
    "headline": "docker入门与实践 - kingjcy Blog",
    "image": {
      "@type": "ImageObject",
      "url": "http://kingjcy.github.ioimages/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2016-11-25T10:57:16JST",
    "dateModified": "2016-11-25T10:57:16JST",
    "author": {
      "@type": "Person",
      "name": "kingjcy Blog"
    },
    "publisher": {
      "@type": "Organization",
      "name": "kingjcy Blog",
      "logo": {
        "@type": "ImageObject",
        "url": "http://kingjcy.github.ioimages/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "<p>docker是一种应用容器化的技术，就是一个容器，类似于logo中的集装箱运行在操作系统这只大鲸鱼上。</p>

<p>docker容器化，类似于虚拟机，但是相对于虚拟机：运行速度快，占用资源少，通过git获取方便，通过dockerfile配置灵活，也不一定不安全,而且docker可以快速交付部署，减少环境问题，轻松迁移扩展，简单管理。</p>

<p></p>"
  }
</script>


    <link href="http://kingjcy.github.iocss/styles.css" rel="stylesheet">
  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://kingjcy.github.io">kingjcy Blog</a>
          </div>

          
          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="http://kingjcy.github.io/post/">归档</a></li>
              
              
              
              <li><a href="http://kingjcy.github.io/about/">关于我</a></li>
              
              
            </ul>
            
          </div>
          

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="http://kingjcy.github.io"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="http://kingjcy.github.iopost/" itemprop="url"><span itemprop="title">post</span></a></li>
        
        <li class="active">docker入门与实践</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2016-11-25T10:57:16JST">Nov 25, 2016</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="http://kingjcy.github.iopost/">post</a></li>
      
    </ul>

    <h1 class="title">docker入门与实践</h1>
  </header>

  

  <div class="article-body"><p>docker是一种应用容器化的技术，就是一个容器，类似于logo中的集装箱运行在操作系统这只大鲸鱼上。</p>

<p>docker容器化，类似于虚拟机，但是相对于虚拟机：运行速度快，占用资源少，通过git获取方便，通过dockerfile配置灵活，也不一定不安全,而且docker可以快速交付部署，减少环境问题，轻松迁移扩展，简单管理。</p>

<p></p>

<h2 id="docker安装">docker安装</h2>

<p>在安装之前需要确保linux的内核版本在3.10.X以上，没有话需要升级内核，我在我的虚拟机的上升级内核了可以参考《centos内核升级》</p>

<p>docker是以linux容器化技术为基础的，所以在linux上体验最好，通常使用root用户安装</p>

<ol>
<li>docker放在epel镜像源中，所以需要先添加镜像源yum install -y <a href="http://mirrors.yun-idc.com/epel/6/x86_64/epel-release-6-8.noarch.rpm">http://mirrors.yun-idc.com/epel/6/x86_64/epel-release-6-8.noarch.rpm</a></li>
</ol>

<p>加载完需要修改源文件，将baseurl放开，将mirrorlist注释掉才能链接上。</p>

<ol>
<li><p>docker与一个系统自带的程序重名，所以修改为docker-io</p>

<p>sudo yum install -y docker-io</p></li>

<li><p>启动
service docker start  或者docker -d</p></li>
</ol>

<p>加入开机启动项：chkconfig docker on</p>

<p>过程中可能有一个device-mapper-libs需要升级，这边用yum源直接升级 yum upgrade device-mapper-libs没有用，需要现在最新的安装包进行安装</p>

<p>2017.2.13在centos 7上使用无法链接到对应到镜像，重官网上获取新到docker源</p>

<pre><code>sudo yum-config-manager --add-repo https://docs.docker.com/engine/installation/linux/repo_files/centos/docker.repo
</code></pre>

<p>然后使用yum makecache加载后重新安装</p>

<pre><code>sudo yum install -y docker-engine
</code></pre>

<p>在次过程中，有一个组件需要升级，rpm包需要手动下载</p>

<pre><code>rpm -e selinux-policy-targeted-3.13.1-60.el7_2.9.noarch
rpm -ivh selinux-policy-targeted-3.13.1-190.fc24.noarch.rpm --nodeps
</code></pre>

<p>然后启动docker</p>

<pre><code>systmctl start docker
</code></pre>

<p>到此docker就安装好了，启动docker服务就可以对docker进行操作了。</p>

<p>2017.3.21 docker重3.1之后开始改变命名，分为ce和ee企业班。这边安装更新</p>

<p>OS requirements</p>

<p>To install Docker, you need the 64-bit version of CentOS 7.</p>

<p>Uninstall old versions</p>

<pre><code>sudo yum remove docker \
                docker-common \
                container-selinux \
                docker-selinux \
                docker-engine
</code></pre>

<p>Install yum-utils, which provides the yum-config-manager utility:</p>

<pre><code>$ sudo yum install -y yum-utils
</code></pre>

<p>add repo并且生效加载</p>

<pre><code>$ sudo yum-config-manager \
    --add-repo \
        https://download.docker.com/linux/centos/docker-ce.repo

$ sudo yum-config-manager --disable docker-ce-edge

$ sudo yum makecache fast
</code></pre>

<p>install</p>

<pre><code>sudo yum install docker-ce

$ sudo systemctl start docker
$ sudo docker run hello-world
</code></pre>

<p>新版的也有对应的rpm可以安装。</p>

<p>所以可以重官网下载rpm来安装，我们通过官网提供的yum源来下载rpm包，然后安装</p>

<h2 id="docker使用">docker使用</h2>

<p>docker容器三大核心：镜像，容器和仓库</p>

<p>镜像是docker引擎只读的一块模版，包含文件系统，容器是基于镜像创建的一个实例，在镜像上加了一个可写层，实现了对镜像对起停等各种操作，镜像本事是不变的。起停等各种</p>

<blockquote>
<h2 id="镜像">镜像</h2>
</blockquote>

<ol>
<li><p>镜像：是docker的基础，包含app所需要的lib以及app</p>

<ul>
<li><p>下载：docker pull name[:tag]  不指定tag默认取最新版本。</p></li>

<li><p>创建容器：docker run -t -i 镜像版本 /bin/bash（可执行文件）&mdash;-启动一个bash终端，-t表示一个伪终端并绑定在容器的标准输入中，-i则让容器标准输入保持打开  守护态运行 -d  -p  XX:XXX 为映射端口，将docker容器端口XX映射到宿主机的xxX端口</p></li>

<li><p>查看镜像信息：docker images</p></li>

<li><p>为镜像新增标签：docker tag 镜像名 标签名</p></li>

<li><p>获取镜像的详细信息：docker inspect images-id   同一个镜像的image-id是一样的 返回一个json格式的信息，具体到那一类信息用-f参数</p></li>

<li><p>搜索镜像：docker search      -s n n星以上的镜像   关键字</p></li>

<li><p>删除镜像：docker rmi 标签/image-id    当该镜像创建容器正在运行，则无法删除，当然可以使用-f 强制删除，但是不建议使用。</p></li>

<li><p>创建镜像：</p>

<ol>
<li><p>基于已有镜像创建   docker commit    [option] container [repository[:tag]]</p>

<ul>
<li>option:-a 作者信息  -m 提交信息  -p 提交时暂停容器运行
<br /></li>
</ul>

<p>例如：docker commit -a &ldquo;jcy&rdquo; -m &ldquo;redisconfigload&rdquo; 01758f83ddb2 redisconfigload</p></li>

<li><p>基于本地模板的导出导入 docker export/import</p>

<p>例如：</p>

<pre><code> docker export 7691a814370e &gt; ubuntu.tar.gz
cat ubuntu.tar.gz | docker import - ubuntu:14.04
</code></pre></li>

<li><p>基于dockerfile</p>

<pre><code>dockerfile一种文本格式的配置文件，由一行行命名组成,支持#开头的注释，主要组成如下：

基础镜像信息 FROM &lt;image&gt;:&lt;tag&gt;  第一条必须是这个命令，可以基于多个镜像，也可以基于空镜像scratch

维护者信息   MAINTAINER &lt;name&gt;

镜像操作指令  RUN &lt;command&gt; 类似于/bin/sh -c  RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用exec来执行

容器启动时执行的指令
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]使用exec来执行,运行一个可执行的文件并提供参数
CMD command param1 param2   也可以是一个shell脚本，者就是一个带参数执行的命令bin/sh中执行，提供给需要交互的用户
CMD [&quot;param1&quot;,&quot;param2&quot;]  给ENTRYPOINT提供默认参数          
CMD命令只执行一次，多条也会被覆盖，只执行最后一条，而且会被docker run指定的运行命令所覆盖。

EXPOSE 让docker容器暴露出端口来

ENV key value 指定环境变量

ADD COPY都是复制,ADD会对tar包进行解压，COPY不会,COPY可以自动创建不存在的目录。

ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]使用exec来执行
ENTRYPOINT command param1 param2  shell执行，一样是容器启动后执行的，不会被cmd覆盖，同样只有一条生效。多条的情况下最后一条有效。

VOLUME [&quot;/data&quot;] 创造挂载点

WORKDIR  指定容器的工作目录。
</code></pre>

<p>最后用docker build 来创建镜像 -t指定镜像的标签信息 -f dockerfile的路径 .</p>

<p>比如：</p>

<pre><code>docker build -t fabric8-console:2.2.199 -f /root/f8/f8-console/fabric8-console-2.2.199/Dockerfile .
</code></pre>

<p>每一步都会生成一个块，对应的有一个唯一哈希值标志，下一次再进行打包的时候可以直接用这个缓存的块，可见镜像是由块组成的，dockerfile步骤越多块越多，镜像就越大，所以最后是基于空镜像，将文件系统的相关环境设置好打成tar包，然后用ADD加入，减少后面run执行的步骤，减小镜像的大小。
上面的哈希是根据大小来生成的，如果大小一样，哈希值会一样，不过这个很少出现，如果出现可以加上参数&ndash;no-cache=true不使用缓存。</p></li>
</ol></li>

<li><p>存储镜像：docker save 将镜像存储为本地的文件</p></li>

<li><p>载入镜像：docker load 将本地镜像文件加载为本地镜像库的镜像</p></li>

<li><p>上传镜像：docker push   name[:tag]</p>

<p>先用docker tag打标签，然后这个标签上传到默认的dockerhub中，当然也可以上传到私有仓库。例如：</p>

<p>在dockerhub上注册了user</p>

<pre><code>docker tag test:latest user/test:latest
docker push user/test:latest
</code></pre>

<p>私有库的搭建以及上传管理在下面详细讲解。</p></li>
</ul></li>
</ol>

<blockquote>
<h2 id="容器">容器</h2>
</blockquote>

<ol>
<li><p>容器：在镜像上加一个隔离层，相当于一个个运行的实例，可以用docker ps -a 来查看当前所有的启停实例</p>

<ul>
<li><p>创建:docker create</p></li>

<li><p>启动：docker start/stop &mdash;&mdash;合二为一 docker run</p></li>

<li><p>创建容器：docker run -t -i .. /bin/bash&mdash;-启动一个bash终端，-t表示一个伪终端并绑定在容器的标准输入中，-i则让容器标准输入保持打开 守护态运行-d,退出用exit或者ctrl+d,-v挂载卷，-e传递环境变量，-p映射端口，是通过iptables实现的，可以用iptables-save查看。当然还可以通过参数对资源进行限制。</p>

<ul>
<li>也可以使用docker run centos /bin/echo &lsquo;hello world&rsquo;,这样就类似在本地执行echo &lsquo;hello world&rsquo;</li>
<li>docker run 主要查看本地是否有镜像，没有则去dockerhub上下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，给只读的镜像外层加一个可写层</li>
<li>从宿主机的网桥接口中桥接一个虚拟接口到容器</li>
<li>配置一个ip</li>
<li>执行用户制定的程序</li>
<li>执行完终止容器
<br /></li>
</ul></li>

<li><p>进入容器：</p>

<ul>
<li><p>docker attach  name 这个是docker自带的命令，但是在多个终端一起链接到该容器的时候，他们是同步的，当其中一个出现问题时，其他的也会一样出现该问题</p></li>

<li><p>docker exec -ti   id /bin/bash 这个也是docker自带的，在docker1.3之后，它在容器中启动来一个bash,但是并不是所有的容器都是在linux系统上建立起来的，并不一定能启动bash</p></li>

<li><p>可以用工具nsenter，是一个需要安装的工具。</p></li>
</ul></li>

<li><p>容器资源限制参数 dockerfile的路径</p>

<ul>
<li><p>-m 1024m &ndash;memory-swap=1024m  # 限制内存最大使用（bug：超过后进程被杀死）</p></li>

<li><p>&ndash;cpuset-cpus=&ldquo;0,1&rdquo;           # 限制容器使用CPU</p></li>
</ul></li>

<li><p>docker容器随系统自启参数</p>

<p>docker run &ndash;restart=always redis</p>

<ul>
<li><p>no – 默认值，如果容器挂掉不自动重启</p></li>

<li><p>on-failure – 当容器以非 0 码退出时重启容器 同时可接受一个可选的最大重启次数参数 (e.g. on-failure:5).</p></li>

<li><p>always – 不管退出码是多少都要重启</p></li>
</ul></li>

<li><p>删除：docker rm<br />
-f 强制删除  -l 删除链接  -v删除挂载卷</p></li>

<li><p>导入和导出：docker export/import  将容器导出为tar文件，将文件导入为镜像，docker load差不多</p></li>

<li><p>docker logs id 记录容器内的操作，  * docker logs id</p></li>

<li><p>docker容器和主机进行拷贝</p>

<ol>
<li><p>重docker容器内拷贝到主机上</p>

<p>[root@oegw1 soft]# docker ps
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS               NAMES
8d418a7b6021        postgres            &ldquo;/docker-entrypoint.   7 hours ago         Up 7 hours                              test1<br />
[root@oegw1 soft]# docker exec -t -i 8d418a7b6021 /bin/bash
root@oegw1:/var/lib/postgresql# pwd
/var/lib/postgresql
root@oegw1:/var/lib/postgresql# ls
data
root@oegw1:/var/lib/postgresql# exit
exit
[root@oegw1 soft]# docker cp 8d418a7b6021:/var/lib/postgresql/data /opt/soft/
完成拷贝</p></li>

<li><p>重主机拷贝到docker容器中</p>

<ol>
<li><p>挂载，也即是主机和docker容器共享一个目录</p>

<ol>
<li><p>在创建容器到时候用 -v XXX：XXX 来挂载</p>

<p>[root@pdapp18 etc]# docker run -it -v /opt/inkscope/etc:/mnt centos /bin/bash
[root@bd91c6b79e87 mnt]# ll
total 4
-rw-r&ndash;r&ndash;. 1 root root 1323 May 23  2016 inkscope.conf
[root@bd91c6b79e87 mnt]# exit
[root@pdapp18 etc]# pwd
/opt/inkscope/etc
[root@pdapp18 etc]# l
总用量 4
-rw-r&ndash;r&ndash;. 1 root root 1323 5月  23 2016 inkscope.conf</p></li>

<li><p>动态挂载
后续完成</p></li>

<li><p>docker还提供来一个数据卷的高级用法</p></li>
</ol>

<p>数据卷：“其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的”。感觉像是由一个容器定义的一个数据挂载信息。其他的容器启动可以直接挂载数据卷容器中定义的挂载信息。</p>

<p>看示例：</p>

<pre><code>docker run -v /root:/root  --name test centos /bin/bash
创建一个普通的容器。用--name给他指定了一个名（不指定的话会生成一个随机的名子）。

然后其他容器就可以使用--volumes-from来引用这个数据卷，就可以让当前容器中的/root目录和本机的/root的进行共享
docker run -it --volumes-from test centos /bin/bash
</code></pre></li>

<li><p>首先查看这个容器的id</p>

<p>docker inspect -f &lsquo;{{.Id}}&rsquo; container-id返回容器的id
实际上本机的/var/lib/docker/container/contianer-id/和docker容器的根目录/是一致的，所以可以直接操作这个目录相当于操作容器的根目录，实现共享。但是我试验没有实现，等有时间再看看什么原因。</p></li>
</ol></li>
</ol></li>
</ul></li>
</ol>

<blockquote>
<h2 id="仓库">仓库</h2>
</blockquote>

<ol>
<li><p>仓库：存放镜像文件的</p>

<p>最大docker官方公共仓库：docker hub</p>

<p>国内：docker pool</p>

<p>官方的仓库镜像一般就是基础镜像，单个单词命名，而username/镜像名这个一般是某个用户上传的镜像</p>

<p>默认是重docker hub上下载，如果需要重其他的镜像仓库下载则需要加前缀。</p>

<p>当然也可以创建私有仓库。主要是通过docker registry这个python开源项目进行创建，registry2之后已经重构用go来开发，目前的registry的版本是2.6，但是有着很多的问题，现在已经有对应的容器镜像了，当然也可以通过源码进行安装。</p>

<p>搭建私有库：</p>

<p>首先下载官方提供的的镜像并且创建一个容器</p>

<pre><code>docker run -d -p 5000:5000 --restart=always --name registry registry:2
</code></pre>

<p>我们可以docker ps看一下镜像已经启动，可以使用crul <a href="http://ip:5000看看网络是否通，本地机器和容器之间的通信也需要iptables，iptables-services来进行通信。">http://ip:5000看看网络是否通，本地机器和容器之间的通信也需要iptables，iptables-services来进行通信。</a></p>

<pre><code>[root@pdapp20 ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
98de3ec23d75        registry:2          &quot;/entrypoint.sh /e...&quot;   16 hours ago        Up 16 hours         0.0.0.0:5000-&gt;5000/tcp   registry&quot;&quot;
</code></pre>

<p>可以通过iptables-save来保存现有的规则同时也能查看，不过这个只需要安装好iptables,iptables-services并启动着就可以自动加入通信的规则。然后检查容器与主机之间是否是通的</p>

<pre><code>1、/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态
SELinux status:                 enabled
2、getenforce                 ##也可以用这个命令检查
关闭SELinux：
1、临时关闭（不用重启机器）：
setenforce 0                  ##设置SELinux 成为permissive模式
                              ##setenforce 1 设置SELinux 成为enforcing模式
2、修改配置文件需要重启机器：
    修改/etc/selinux/config 文件
    将SELINUX=enforcing改为SELINUX=disabled
    重启机器即可
</code></pre>

<p>这个时候网络应该是通的了，然后我们tag一个自己的镜像</p>

<pre><code>docker pull ubuntu &amp;&amp; docker tag ubuntu localhost:5000/ubuntu
</code></pre>

<p>然后上传</p>

<pre><code>docker push localhost:5000/ubuntu
</code></pre>

<p>可以通过<a href="http://localhost:5000/v2/_catalog（在v1版本的时候是v1/search,现在在v2版本中已经不使用）来查看私有仓库的镜像,并到每一个镜像中去查看该镜像的具体信息。">http://localhost:5000/v2/_catalog（在v1版本的时候是v1/search,现在在v2版本中已经不使用）来查看私有仓库的镜像,并到每一个镜像中去查看该镜像的具体信息。</a></p>

<pre><code>[root@pdapp20 ~]# curl http://localhost:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;hello-world&quot;,&quot;ubuntu&quot;]}
[root@pdapp20 ~]# curl http://localhost:5000/v2/tags/list
404 page not found
[root@pdapp20 ~]# curl http://localhost:5000/v2/ubuntu/tags/list
{&quot;name&quot;:&quot;ubuntu&quot;,&quot;tags&quot;:[&quot;latest&quot;]}
[root@pdapp20 ~]# curl http://localhost:5000/v2/hello-world/tags/list
{&quot;name&quot;:&quot;hello-world&quot;,&quot;tags&quot;:[&quot;latest&quot;]}
</code></pre>

<p>然后我们删除本地的镜像，重自己的私有库来下载</p>

<pre><code>[root@pdapp20 ~]# docker rmi localhost:5000/hello-world
Untagged: localhost:5000/hello-world:latest
Untagged: localhost:5000/hello-world@sha256:2075ac87b043415d35bb6351b4a59df19b8ad154e578f7048335feeb02d0f759
[root@pdapp20 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
registry            2                   047218491f8c        2 weeks ago         33.2 MB
ubuntu              latest              0ef2e08ed3fa        3 weeks ago         130 MB
hello-world         latest              48b5124b2768        2 months ago        1.84 kB
centos              latest              67591570dd29        3 months ago        192 MB
[root@pdapp20 ~]# docker pull localhost:5000/hello-world
Using default tag: latest
latest: Pulling from hello-world
Digest: sha256:2075ac87b043415d35bb6351b4a59df19b8ad154e578f7048335feeb02d0f759
Status: Downloaded newer image for localhost:5000/hello-world:latest
</code></pre>

<p>当然私有仓库可以进行加密认证，这个后续更新。</p></li>
</ol>

<blockquote>
<h2 id="数据和网络">数据和网络</h2>
</blockquote>

<ol>
<li><p>数据：数据卷和数据卷容器&ndash;主要是几个参数-v</p>

<p>数据卷和数据卷容器在上面主机和容器之间的复都有解释，这边直接讲一个数据卷用于数据的迁移：</p>

<p>备份：</p>

<pre><code>docker run -d -volumes-from data -v $(pwd):/backup  ubuntu
tar -zcvf /backup/buckup.tar.gz /data

这样可以将容器数据卷data打包成backup.tar.gz，然后放到容器的backup目录下和本地主机的当前目录共享。实现备份。
</code></pre>

<p>数据恢复就是将压缩包解压到共享目录，然后放到数据卷的容器中去。</p></li>

<li><p>网络：端口-p和-P</p>

<p>容器到主机：</p>

<pre><code>端口的映射可以制定主机端口，可以多次制定，可以指定所有的，可以通过docker port来查看当前容器的端口。
</code></pre>

<p>容器到容器：</p>

<pre><code>通过--link来在容器之间建立一个安全到通道，避免暴露在外

    docker run --rm -it --name web2 --link db:db training/webapp /bin/bash

    root@5845d10a2bf5:/opt/webapp# cat /etc/hosts
    127.0.0.1    localhost
    ::1    localhost ip6-localhost ip6-loopback
    fe00::0    ip6-localnet
    ff00::0    ip6-mcastprefix
    ff02::1    ip6-allnodes
    ff02::2    ip6-allrouters
    172.17.0.3    db c6cd414f08d4   -------这边在web的容器里面有db的容器的主机配置
    172.17.0.5    5845d10a2bf5
    root@5845d10a2bf5:/opt/webapp# apt-get install -yqq inetutils-ping
    E: Failed to fetch http://archive.ubuntu.com/ubuntu/pool/universe/i/inetutils/inetutils-ping_1.9.2-1_amd64.deb  Could not resolve 'archive.ubuntu.com'

    E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
    root@5845d10a2bf5:/opt/webapp# ping db
    PING db (172.17.0.3) 56(84) bytes of data.
    64 bytes from db (172.17.0.3): icmp_seq=1 ttl=64 time=0.204 ms
    64 bytes from db (172.17.0.3): icmp_seq=2 ttl=64 time=0.106 ms
    64 bytes from db (172.17.0.3): icmp_seq=3 ttl=64 time=0.097 ms
    64 bytes from db (172.17.0.3): icmp_seq=4 ttl=64 time=0.102 ms

    ----网络是通的，说明两个容器之间建立来一个安全的通道。

Docker集群通信：1。自定义网桥2.使用adbasssdor容器—目前已经有实现的容器集群管理方案，例如k8s
</code></pre>

<p>这边可以根据书的内容了解各种语言对应的流行的框架：</p>

<pre><code>1. php

Cakephp,zend framework, symfony,phalconphp（这个是c扩展的，具有高性能低资源占用的框架）

2. python。动态脚本语言。perl 解释型脚本语言

flask，django（都是web框架）

3. ruby  动态脚本语言

jruby，Runy on rails,sinatra

4. javascript

node.js就是javascript的主力技术方案，express 最稳定的web开发框架，angularjs

5. go

beego，revel，martini
</code></pre></li>
</ol>

<blockquote>
<h2 id="架构">架构</h2>
</blockquote>

<ol>
<li><p>docker架构：</p>

<p>c/s基本架构。</p></li>
</ol>

<h2 id="docker实践">docker实践</h2>

<h3 id="busybox">busybox</h3>

<p>busybox是一个集成一百多个常用的linux命令的工具箱，经常使用的echo，cat，mount，grep等等都在这个里面，是linux系统的瑞士军刀。</p>

<pre><code>docker pull busybox
docker run -it busybox
</code></pre>

<p>就可以在这个镜像中使用各个命令了。</p>

<h3 id="ubuntu-centos">ubuntu/centos</h3>

<pre><code>docker pull centos
</code></pre>

<h3 id="coreos">CoreOS</h3>

<p>CoreOS是基于docker发行的linux的版本</p>

<h3 id="支持ssh的镜像">支持ssh的镜像</h3>

<pre><code>首先下载镜像并创建容器，在容器中安装openssh-server，并启动该服务，然后在根目录下写一个脚本run.sh，来启动ssh，然后用docker commit来打包一个新的镜像。

然后可以用这个镜像创建容器启动服务就可以通过ssh来链接这个容器了

docker run -p 10022:22 -d sshd:centos /run.sh

ssh 宿主机 -p 10022 就可以登录到容器内
</code></pre>

<p>###</p>

<blockquote>
<h2 id="docker原理">docker原理</h2>
</blockquote>

<p>docker在版本0.9之前是以lxc（linux container）为基础的，0.9以后又引入了自己开发的libcontainer，试图设计出更加通用的容器化技术。</p>

<p>docker采用c/s架构，服务端默认在后台运行，进行容器的创建等相关操作，客户端就是我们调用的命令行操作.每次客户端运行完就会退出等待再次调用，客户端和服务端是通过socket进行通信的，默认是unix:///var/run/docker.sock,可以通过-H参数修改端口。</p>

<p>docker都是独立的系统，是对操作系统的一种虚拟化。所以需要对其内核，文件系统，网络，PID，UID，IPC，内存，硬盘，cpu进行限制隔离，我们就是通过命名空间namespace，控制组cgroup，联合文件系统UFS，虚拟网络来完成的隔离独立运行。</p>

<p>docker是一种轻量级的操作系统虚拟化方案，基于LXC，相对于传统的vm，它只虚拟来操作系统而没有虚拟内核，基于docker engine共享内核，即虚拟出运行库即可运行app，而传统的vm都是虚拟出完整的内核和运行库文件的操作系统。即虚拟出运行库即可运行app，而传统的vm都是虚拟出完整的内核和运行库文件的操作系统。</p>

<blockquote>
<h2 id="docker-compose">docker Compose</h2>
</blockquote>

<p>Compose，你可以在一个文件中定义一个多容器应用，然后使用一条命令来启动你的应用，完成一切准备工作。</p>

<p>使用Docker Compose，不再需要使用shell脚本来启动容器。在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器</p>

<pre><code>build 构建或重建服务
help 命令帮助
kill 杀掉容器
logs 显示容器的输出内容
port 打印绑定的开放端口
ps 显示容器
pull 拉取服务镜像
restart 重启服务
rm 删除停止的容器
run 运行一个一次性命令
scale 设置服务的容器数目
start 开启服务
stop 停止服务
up 创建并启动容器
</code></pre>

<p>安装</p>

<p>在线下载</p>

<pre><code>curl -L https://github.com/docker/compose/releases/download/1.4.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
chmod  x /usr/local/bin/docker-compose
</code></pre>

<p>离线github上有对应的二进制包。</p>

<p>通过配置yml文件来部署。</p></div>

  <footer class="article-footer">
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">CATEGORIES</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="http://kingjcy.github.iocategories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">技术文章</a></li>
          
        </ul>
      </div>
    </section>
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">TAGS</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="http://kingjcy.github.iotags/docker/">docker</a></li>
          
          <li><a href="http://kingjcy.github.iotags/container/">container</a></li>
          
        </ul>
      </div>
    </section>
    
    
  </footer>

</article>


    
  </div>

  <div class="col-md-4">
    
<aside class="l-sidebar">

  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="http://kingjcy.github.io/post/restful/" class="list-group-item">restful架构</a>
      
      <a href="http://kingjcy.github.io/post/rbac/" class="list-group-item">rbac框架</a>
      
      <a href="http://kingjcy.github.io/post/beego/" class="list-group-item">从harbor入手beego框架</a>
      
      <a href="http://kingjcy.github.io/post/chrome-dev-tool/" class="list-group-item">chrome的开发者工具</a>
      
      <a href="http://kingjcy.github.io/post/gulp/" class="list-group-item">gulp</a>
      
      <a href="http://kingjcy.github.io/post/typescript/" class="list-group-item">typescript</a>
      
      <a href="http://kingjcy.github.io/post/web/" class="list-group-item">web</a>
      
      <a href="http://kingjcy.github.io/post/mac/" class="list-group-item">mac os</a>
      
      <a href="http://kingjcy.github.io/post/go/" class="list-group-item">go积累</a>
      
      <a href="http://kingjcy.github.io/post/kickstart/" class="list-group-item">kickstart</a>
      
    </div>
  </section>

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">CATEGORY</div>
    </div>
    <div class="list-group">
      
      <a href="http://kingjcy.github.iocategories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0" class="list-group-item">技术文章</a>
      
      <a href="http://kingjcy.github.iocategories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F" class="list-group-item">人生感悟</a>
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
      <a href="http://kingjcy.github.iotags/tool" class="list-group-item">tool</a>
      
      <a href="http://kingjcy.github.iotags/linux" class="list-group-item">linux</a>
      
      <a href="http://kingjcy.github.iotags/go" class="list-group-item">go</a>
      
      <a href="http://kingjcy.github.iotags/language" class="list-group-item">language</a>
      
      <a href="http://kingjcy.github.iotags/redis" class="list-group-item">redis</a>
      
      <a href="http://kingjcy.github.iotags/thought" class="list-group-item">thought</a>
      
      <a href="http://kingjcy.github.iotags/centos" class="list-group-item">centos</a>
      
      <a href="http://kingjcy.github.iotags/ceph" class="list-group-item">ceph</a>
      
      <a href="http://kingjcy.github.iotags/database" class="list-group-item">database</a>
      
      <a href="http://kingjcy.github.iotags/fs" class="list-group-item">fs</a>
      
    </div>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p>Copyright (c) 2017. All rights reserved.</p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

