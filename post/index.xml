<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on kingjcy Blog</title>
    <link>http://kingjcy.github.io/post/index.xml</link>
    <description>Recent content in Post-rsses on kingjcy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <lastBuildDate>Wed, 02 Nov 2016 16:50:34 +0800</lastBuildDate>
    <atom:link href="http://kingjcy.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>工具系列(一)：git和github的使用总结</title>
      <link>http://kingjcy.github.io/blog/2016/11/02/%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E4%B8%80git%E5%92%8Cgithub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 02 Nov 2016 16:50:34 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/11/02/%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E4%B8%80git%E5%92%8Cgithub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;一直想整理一下平时使用的工具，都没有时间，但是还是要带着整理的，备忘也便于查看。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;##git&lt;/p&gt;

&lt;p&gt;git是一个分布式版本控制系统，它没有中央服务器，本地便是一个版本库。它是通过推送自己修改的内容给对方来实现版本控制的。&lt;/p&gt;

&lt;p&gt;svn则与之相反，svn是一种集中式的版本控制系统，它拥有中央服务器，需要先从中央服务器中下载最新的版本，然后进行修改，最后在将修改的推送到中央服务器上，所以必须能连接上服务器，不然不利于开发。&lt;/p&gt;

&lt;p&gt;相对而言，git适用于随时随地的本地开发。&lt;/p&gt;

&lt;p&gt;###安装&lt;/p&gt;

&lt;p&gt;linux下安装（centos）&lt;/p&gt;

&lt;p&gt;1.yum基础软件包管理工具&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum install git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;目前的yum源安装最高版本应该是1.7.1&lt;/p&gt;

&lt;p&gt;2.编译安装&lt;/p&gt;

&lt;p&gt;首先到github[&lt;a href=&#34;https://github.com/git/git/releases&#34;&gt;https://github.com/git/git/releases&lt;/a&gt;] 上下载最新的release版本。安装之前需要先安装git的依赖包：：curl、zlib、openssl、expat，还有libiconv。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;`
$ tar -zxf git-2.0.0.tar.gz&lt;/p&gt;

&lt;p&gt;$ cd git-2.0.0&lt;/p&gt;

&lt;p&gt;$ make configure&lt;/p&gt;

&lt;p&gt;$ ./configure &amp;ndash;prefix=/usr&lt;/p&gt;

&lt;p&gt;$ make all doc info&lt;/p&gt;

&lt;p&gt;$ sudo make install install-doc install-html install-info`&lt;/p&gt;

&lt;p&gt;然后就可以检查版本安装是否成功了&lt;code&gt;git --version&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;###操作使用&lt;/p&gt;

&lt;p&gt;git是一个本地管理的软件，首先要掌握本地的使用命令：&lt;/p&gt;

&lt;p&gt;1.git init  在当前目录建立仓库，也就是初始化本地目录环境，可以看见有一个隐藏文件.git 要输出这个仓库，直接删除这个目录（暴力方法）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>redis源码解析</title>
      <link>http://kingjcy.github.io/blog/2016/07/28/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 28 Jul 2016 15:39:45 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/07/28/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;redis项目的源码一直是备受赞扬的，其规模小而功能强大以及一些巧妙的技巧，都注定了它是一个值得学习的项目，今天起，我开始阅读redis源码，redis是用c写成的，对于我来说还是比较适合的。但是对于一百多个文件，怎么下手比较好，上网参考了别人的源码解析，最终决定按以下模块顺序阅读：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;struct:（结构体）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;adlist.c 用于对list的定义，它是个双向链表结构&lt;/li&gt;
&lt;li&gt;dict.c 主要对于内存中的hash进行管理&lt;/li&gt;
&lt;li&gt;sds.c 用于对字符串的定义&lt;/li&gt;
&lt;li&gt;sparkline.c 一个拥有sample列表的序列&lt;/li&gt;
&lt;li&gt;t_hash.c hash在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_list.c list在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_set.c  set在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_string.c string在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;t_zset.c zset在Server/Client中的应答操作。主要通过redisObject进行类型转换。&lt;/li&gt;
&lt;li&gt;ziplist.c  ziplist是一个类似于list的存储对象。它的原理类似于zipmap。&lt;/li&gt;
&lt;li&gt;zipmap.c  zipmap是一个类似于hash的存储对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;data:（数据操作）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;aof.c 全称为append only file，作用就是记录每次的写操作,在遇到断电等问题时可以用它来恢复数据库状态。&lt;/li&gt;
&lt;li&gt;config.c 用于将配置文件redis.conf文件中的配置读取出来的属性通过程序放到server对象中。&lt;/li&gt;
&lt;li&gt;db.c对于Redis内存数据库的相关操作。&lt;/li&gt;
&lt;li&gt;multi.c用于事务处理操作。&lt;/li&gt;
&lt;li&gt;rdb.c  对于Redis本地数据库的相关操作，默认文件是dump.rdb（通过配置文件获得），包括的操作包括保存，移除，查询等等。&lt;/li&gt;
&lt;li&gt;replication.c 用于主从数据库的复制操作的实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tool:（工具）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;bitops.c 位操作相关类&lt;/li&gt;
&lt;li&gt;debug.c 用于调试时使用&lt;/li&gt;
&lt;li&gt;endianconv.c 高低位转换，不同系统，高低位顺序不同&lt;/li&gt;
&lt;li&gt;help.h  辅助于命令的提示信息&lt;/li&gt;
&lt;li&gt;lzf_c.c 压缩算法系列&lt;/li&gt;
&lt;li&gt;lzf_d.c  压缩算法系列&lt;/li&gt;
&lt;li&gt;rand.c 用于产生随机数&lt;/li&gt;
&lt;li&gt;release.c 用于发步时使用&lt;/li&gt;
&lt;li&gt;sha1.c sha加密算法的实现&lt;/li&gt;
&lt;li&gt;util.c  通用工具方法&lt;/li&gt;
&lt;li&gt;crc64.c 循环冗余校验&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;event:（事件）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ae.c 用于Redis的事件处理，包括句柄事件和超时事件。&lt;/li&gt;
&lt;li&gt;ae_epoll.c 实现了epoll系统调用的接口&lt;/li&gt;
&lt;li&gt;ae_evport.c 实现了evport系统调用的接口&lt;/li&gt;
&lt;li&gt;ae_kqueue.c 实现了kqueuex系统调用的接口&lt;/li&gt;
&lt;li&gt;ae_select.c 实现了select系统调用的接口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;baseinfo:（基本信息）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;asciilogo,c redis的logo显示&lt;/li&gt;
&lt;li&gt;version.h定有Redis的版本号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;compatible:（兼容）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;fmacros.h 兼容Mac系统下的问题&lt;/li&gt;
&lt;li&gt;solarisfixes.h 兼容solary下的问题&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;main:（主程序）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;redis.c redis服务端程序&lt;/li&gt;
&lt;li&gt;redis_cli.c redis客户端程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;net:（网络）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;anet.c 作为Server/Client通信的基础封装&lt;/li&gt;
&lt;li&gt;networking.c 网络协议传输方法定义相关的都放在这个文件里面了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;wrapper:（封装类）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;bio.c background I/O的意思，开启后台线程用的&lt;/li&gt;
&lt;li&gt;hyperloglog.c 一种日志类型的&lt;/li&gt;
&lt;li&gt;intset.c  整数范围内的使用set，并包含相关set操作。&lt;/li&gt;
&lt;li&gt;latency.c 延迟类&lt;/li&gt;
&lt;li&gt;migrate.c 命令迁移类，包括命令的还原迁移等&lt;/li&gt;
&lt;li&gt;notify.c 通知类&lt;/li&gt;
&lt;li&gt;object.c  用于创建和释放redisObject对象&lt;/li&gt;
&lt;li&gt;pqsort.c  排序算法类&lt;/li&gt;
&lt;li&gt;pubsub.c 用于订阅模式的实现，有点类似于Client广播发送的方式。&lt;/li&gt;
&lt;li&gt;rio.c redis定义的一个I/O类&lt;/li&gt;
&lt;li&gt;slowlog.c 一种日志类型的，与hyperloglog.c类似&lt;/li&gt;
&lt;li&gt;sort.c 排序算法类，与pqsort.c使用的场景不同&lt;/li&gt;
&lt;li&gt;syncio.c 用于同步Socket和文件I/O操作。&lt;/li&gt;
&lt;li&gt;zmalloc.c 关于Redis的内存分配的封装实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;others:（存放了一些我暂时还不是很清楚的类,所以没有解释了）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;scripting.c&lt;/li&gt;
&lt;li&gt;sentinel.c&lt;/li&gt;
&lt;li&gt;setproctitle.c&lt;/li&gt;
&lt;li&gt;valgrind.sh&lt;/li&gt;
&lt;li&gt;redisassert.h&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;test:（测试）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;memtest.c 内存检测&lt;/li&gt;
&lt;li&gt;redis_benchmark.c 用于redis性能测试的实现。&lt;/li&gt;
&lt;li&gt;redis_check_aof.c 用于更新日志检查的实现。&lt;/li&gt;
&lt;li&gt;redis_check_dump.c 用于本地数据库检查的实现。&lt;/li&gt;
&lt;li&gt;testhelp.c 一个C风格的小型测试框架。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些都是参考网上人家的阅读经验来的，去阅读吧！后续的源码解析直接放在我的github上[&lt;a href=&#34;https://github.com/kingjcy&#34;&gt;https://github.com/kingjcy&lt;/a&gt;]&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>redis cluster</title>
      <link>http://kingjcy.github.io/blog/2016/07/21/redis-cluster/</link>
      <pubDate>Thu, 21 Jul 2016 17:12:36 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/07/21/redis-cluster/</guid>
      <description>&lt;p&gt;自从研究了redis的监控工具之后，对于redis的集群实现方案又回头做了一个系统的研究。
首先，先说一下redis，是一个高性能的key-value类型的NoSQL数据库，支持较为丰富的数据类型，
可以满足一般公司的需求，所以使用比较多，但是随着数据的越来越多，也迫切需求支持分布式集群。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;redis集群&#34;&gt;&lt;strong&gt;redis集群&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;目前redis集群已经有了较大的应用，包括官方也推出的redis3.0版本的集群部署方案。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis集群解决的问题&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;redis单线程特性，集群可以并发处理，更高效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单机内存有限&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单点问题，缺乏高可用性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不能动态扩容&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;目前集群主要有四种部署方案&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端分片&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理分片：twenproxy代理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;codis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;redis cluster&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;四种部署方案&#34;&gt;&lt;strong&gt;四种部署方案&lt;/strong&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;客户端分片&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就是通过客户端来实现到不同的主机上的redis实例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-client.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;客户端分片是不用经过中间件，但是缺点太多了,所有的逻辑都在客户端，这样就导致了可运维性很差，首先，客户端存在着语言的差异，还有逻辑过分依赖于客户端，升级应用和扩展业务都依赖于客户端的开发，还存在着客户端版本和故障问题难以排查的问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;代理分片&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这边主要介绍的是曾被广泛使用的twenproxy作为中心代理的集群部署方案（twemproxy是twitter开源的一个redis和memcache代理服务器，只用于作为简单的代理中间件，目前twitter内部已经不再使用）。&lt;/p&gt;

&lt;p&gt;该集群主要是通过中间件twenproxy来实现，客户端只要通过中间件twenproxy提供的api和端口来进行操作，然后twenproxy提供路由能力（所有的key通过一致性哈希算法分布到集群中所有的redis实例中）到后台redis集群中的不同实例中，实现分布式集群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-twenproxy.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;twenproxy还提供了一些其他保障集群稳定的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;支持无效Redis实例的自动删除&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理与每个redis实例维持长连接，减少客户端和redis实例的连接数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理是无状态的，可以任意部署多套，避免单点问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认启用pipeline，连接复用，提高效率，性能损失在 10% - 20%&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这套部署方案，采用组件分离，升级容易，但是这个部署方案有一个很大的缺陷：无法动态扩容，不能平缓的增减redis实例，而且中间件也会消耗性能，在并发上，要求代理数量和实例一致甚至更多才能更好的发挥并发能力。造成运维工作量很大。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;codis&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;codis是豌豆荚开源一款分布式集群的方案，它是在redis2.8.21的基础上使用go和c改出来的，其实也是类似于twenproxy的代理模式，但是它可以实现平滑的新增实例，也就是动态扩容。&lt;/p&gt;

&lt;p&gt;Codis中采用预分片的形式，启动的时候就创建了1024个slot，1个slot相当于1个箱子，每个箱子有固定的编号，范围是1~1024。slot这个箱子用作存放Key，至于Key存放到哪个箱子，可以通过算法“crc32(key)%1024”获得一个数字，这个数字的范围一定是1~1024之间，Key就放到这个数字对应的slot。例如，如果某个Key通过算法“crc32(key)%1024”得到的数字是5，就放到编码为5的slot（箱子）。1个slot只能放1个Redis Server Group，不能把1个slot放到多个Redis Server Group中。1个Redis Server Group最少可以存放1个slot，最大可以存放1024个slot。因此，Codis中最多可以指定1024个Redis Server Group。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-codis.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这边对codis四大组成部分&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;codis-proxy 是客户端连接的 Redis 代理服务, codis-proxy 本身实现了 Redis 协议, 表现得和一个原生的 Redis 没什么区别 (就像 Twemproxy), 对于一个业务来说, 可以用Keepalived等负载均衡软件部署多个 codis-proxy实现高可用, codis-proxy 本身是无状态的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;codis-config 是 Codis 的管理工具, 支持包括, 添加/删除 Redis 节点, 添加/删除 Proxy 节点, 发起数据迁移等操作. codis-config 本身还自带了一个 http server, 会启动一个 dashboard, 用户可以直接在浏览器上观察 Codis 集群的运行状态，可以完善运维。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;codis-server 是 Codis 项目维护的一个 Redis 分支, 基于 2.8.21 开发, 加入了 slot 的支持和原子的数据迁移指令. Codis 上层的 codis-proxy 和 codis-config 只能和这个版本的 Redis 交互才能正常运行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ZooKeeper：Codis依赖于ZooKeeper存储数据路由表的信息和Codis Proxy节点的元信息。另外，Codisconfig发起的命令都会通过ZooKeeper同步到CodisProxy的节点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依然有中间件的性能消耗问题，但是解决了动态扩容问题。这个思路是目前大多数公司在用的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis3.0&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;redis3.0集群部署方案是官方在发布redis3.0版本的时候提供的，它采用了p2p模式，完全去中心化。依然采用预分片的模式，Redis把所有的Key分成了16384个slot，每个Redis实例负责其中一部分slot。slot 和 server 的映射关系存储每一个 server 的路由表中，集群中的所有信息（节点、端口、slot等），都通过节点之间定期的数据交换而更新。Redis客户端在任意一个Redis实例发出请求，如果所需数据不在该实例中，通过重定向命令引导客户端访问所需的实例。在存储时，根据 CRC16(key) mod 16384 的值，决定将一个key放到哪一个slot中。当数据迁移时就是调整 slot 的分布。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kingjcy.github.io/image/redis-cluster-3.0.jpg&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无中心化结构，每个节点都保存数据和整个集群的状态。&lt;/li&gt;
&lt;li&gt;采用 gossip 协议传播信息以及发现新节点（最终一致性）。gossip协议要求每个节点和其他节点保持连接，会利用PING/PONG来发送节点相关的数据，更新节点的路由表，如果设置的时间较短或者节点较多的话，还是比较客观的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而且目前官方只提供了一个ruby程序 redis-trib 完成集群的所有操作，缺乏监控管理工具，很难清楚目前集群的状态。目前并没有得到大规模的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Installation_of_some_applications</title>
      <link>http://kingjcy.github.io/blog/2016/07/21/installation_of_some_applications/</link>
      <pubDate>Thu, 21 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/07/21/installation_of_some_applications/</guid>
      <description>&lt;p&gt;最近安装了好多应用，这边也做了一个整合和思考：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我的安装规则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.一般用yum,rpm安装的都是在root权限下&lt;/p&gt;

&lt;p&gt;2.源码安装，可以全局使用命令的，放在root下，还有需要root权限的放在root下&lt;/p&gt;

&lt;p&gt;3.其他的只要给用户自己安排就好，root用于管理和维护，最好不要开发。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;go&#34;&gt;go&lt;/h2&gt;

&lt;h3 id=&#34;go安装&#34;&gt;go安装:&lt;/h3&gt;

&lt;p&gt;1 下载安装包 go1.5.linux-amd64.tar.gz&lt;/p&gt;

&lt;p&gt;2 在linux下找一个目录进行解压 tar zxf go1.5.linux-amd64.tar.gz&lt;/p&gt;

&lt;p&gt;3 编辑文件/etc/profile，在结尾添加环境变量&lt;/p&gt;

&lt;p&gt;export GOROOT=/home/test/Go/go&amp;mdash;-源码安装路径&lt;/p&gt;

&lt;p&gt;export PATH=$GOROOT/bin:$PATH&amp;mdash;&amp;mdash;声明应用&lt;/p&gt;

&lt;p&gt;export GOPATH=/home/test/Go/go-project&amp;mdash;你的项目路劲&lt;/p&gt;

&lt;p&gt;4 执行source /etc/profile，使修改生效&lt;/p&gt;

&lt;p&gt;5 执行go version，查看是否安装成功。&lt;/p&gt;

&lt;h3 id=&#34;godep-go包管理工具-安装&#34;&gt;godep(go包管理工具)安装：&lt;/h3&gt;

&lt;p&gt;1.确保已经有go语言的环境并且设置好了 GOPATH 环境变量。&lt;/p&gt;

&lt;p&gt;2.使用 go get -u github.com/tools/godep 下载 godep 包并自动安装。&lt;/p&gt;

&lt;p&gt;3.godep 可执行程序会放在 $GOPATH/bin 目录下。所以想直接用 godep 执行命令的话需要将该路径加入到全局的环境变量 PATH 中，可以将export PATH=&amp;ldquo;$PATH:$GOPATH/bin&amp;rdquo;加入到系统启动脚本中。&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;java:&lt;/h2&gt;

&lt;p&gt;人们常说的Java X=Java SE X=JDK1.X，都是一回事。&lt;/p&gt;

&lt;h3 id=&#34;jdk的安装&#34;&gt;jdk的安装：&lt;/h3&gt;

&lt;p&gt;1.上网下载安装包 jdk-7u72-linux-x64.tar.gz 解压&lt;/p&gt;

&lt;p&gt;2.设置环境变量***
    vim /etc/profile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/java/jdk1.7.0_55
export PATH=.:$JAVA_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.检查版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -version
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;maven的安装&#34;&gt;maven的安装：&lt;/h3&gt;

&lt;p&gt;1.首先到Maven官网下载安装包：apache-maven-3.0.3-bin.tar.gz&lt;/p&gt;

&lt;p&gt;2.进入下载文件夹，找到下载的文件，运行如下命令解压&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -zxvf  apache-maven-2.2.1-bin.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压后的文件夹名为apache-maven-3.0.3&lt;/p&gt;

&lt;p&gt;3.使用mv命令将apache-maven-3.0.3文件夹拷贝到自己指定的文件夹，比如/usr/local/下&lt;/p&gt;

&lt;p&gt;mv -rf apache-maven-3.0.3 /usr/local/&lt;/p&gt;

&lt;p&gt;4.配置环境变量，编辑/etc/profile文件，添加如下代码&lt;/p&gt;

&lt;p&gt;MAVEN_HOME=/usr/local/apache-maven-3.0.3
   export MAVEN_HOME
   export PATH=${PATH}:${MAVEN_HOME}/bin&lt;/p&gt;

&lt;p&gt;5.保存文件，并运行如下命令使环境变量生效&lt;/p&gt;

&lt;p&gt;source /etc/profile&lt;/p&gt;

&lt;p&gt;6.在控制台输入如下命令，如果能看到Maven相关版本信息，则说明Maven已经安装成功&lt;/p&gt;

&lt;p&gt;mvn -v&lt;/p&gt;

&lt;h3 id=&#34;zookeeper的安装&#34;&gt;zookeeper的安装：&lt;/h3&gt;

&lt;p&gt;1.从官网下载 zookeeper，解压。&lt;/p&gt;

&lt;p&gt;使用默认配置启动 zookeeper sh ./bin/zkServer.sh start，监听地址为 2181。&lt;/p&gt;

&lt;h2 id=&#34;redis&#34;&gt;redis&lt;/h2&gt;

&lt;h3 id=&#34;redis的安装&#34;&gt;redis的安装：&lt;/h3&gt;

&lt;p&gt;1、下载解压包 tar -zxf redis-3.0.7.tar.gz 到安装目录解压&lt;/p&gt;

&lt;p&gt;2、make&lt;/p&gt;

&lt;p&gt;3、make install&lt;/p&gt;

&lt;p&gt;4、用 redis-server 配置文件 启动&lt;/p&gt;

&lt;h3 id=&#34;gem-ruby第三方插件管理器-的安装&#34;&gt;gem（ruby第三方插件管理器）的安装：&lt;/h3&gt;

&lt;p&gt;1、首先具备ruby的解释器，ruby是类似于shell，python的脚本语言&lt;/p&gt;

&lt;p&gt;2、下载安装包 rubygems-1.8.7.tgz 解压&lt;/p&gt;

&lt;p&gt;3、进入目录，执行ruby setup.rb安装&lt;/p&gt;

&lt;p&gt;4、用gem安装ruby的插件&lt;/p&gt;

&lt;p&gt;比如安装redis的ruby插件&lt;/p&gt;

&lt;p&gt;先下载插件文件 redis-3.2.2.gem&lt;/p&gt;

&lt;p&gt;然后执行gem install -l redis-3.2.2.gem本地安装即可。&lt;/p&gt;

&lt;p&gt;在线可以用yum安装&lt;/p&gt;

&lt;p&gt;安装基本的包:&lt;/p&gt;

&lt;p&gt;prompt$ yum install -y ruby&lt;/p&gt;

&lt;p&gt;安装额外的Ruby包和文档:&lt;/p&gt;

&lt;p&gt;prompt$ yum install -y ruby-devel ruby-docs ruby-ri ruby-rdoc&lt;/p&gt;

&lt;p&gt;安装RubyGems:&lt;/p&gt;

&lt;p&gt;prompt$ yum install -y rubygems&lt;/p&gt;

&lt;p&gt;然后一样使用&lt;/p&gt;

&lt;h2 id=&#34;lamp&#34;&gt;LAMP&lt;/h2&gt;

&lt;h3 id=&#34;apache的安装&#34;&gt;Apache的安装：&lt;/h3&gt;

&lt;p&gt;下载安装包&lt;/p&gt;

&lt;p&gt;下载安装 apache 依赖关联包（共四个：apr，apr-iconv，apr-util，pcre）&lt;/p&gt;

&lt;p&gt;正常的解压(tar -zxvf package)，配置（./configure），编译（make），安装（make install）&lt;/p&gt;

&lt;h3 id=&#34;mysql的安装&#34;&gt;mysql的安装：&lt;/h3&gt;

&lt;p&gt;1、源码安装，不用传统的configure，用cmake&lt;/p&gt;

&lt;p&gt;2、二进制文件&amp;ndash;我没有找，直接可执行的&lt;/p&gt;

&lt;p&gt;3、rpm安装，下载rpm包，用rpm -ivh  &amp;ndash;nodeps &amp;ndash;force  安装时不再分析包之间的依赖关系而直接安装,对于本机器来说，由于libgc版本过低需要更新，所以还是直接有源安装比较好，用yum/rpm。&lt;/p&gt;

&lt;h3 id=&#34;php的安装&#34;&gt;php的安装&lt;/h3&gt;

&lt;p&gt;1、安装PHP&lt;/p&gt;

&lt;p&gt;（1）获得PHP源码：php-5.4.1.tar.gz。&lt;/p&gt;

&lt;p&gt;（2）解压缩源码文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #tar -zvxf php-5.4.1.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（3）安装libxm12以及libxml2-devel，不然编译源码时会出现“Configure: error: xml2-config not found. Please check your libxml2 installation.”问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #yum install -y libxml2 libxm12-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4)编译源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cd /usr/local/php-5.4.1
#./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql

#make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(5)安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#make install 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、配置PHP&lt;/p&gt;

&lt;p&gt;(1)将PHP源码包（/usr/local/php-5.4.1）中的php.ini-development文件复制到/usr/local/lib/下，更名为php.ini。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cp /usr/local/php-5.4.1/php.ini-development /usr/local/lib/php.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)修改Apache配置文件（gedit /usr/local/apache2/conf/httpd.conf）以支持对PHP的解析。如果httpd.conf中没有下列语句，就将它们分别添加到LoadModule和AddType项的后面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule php5_module modules/libphp5.so

AddType application/x-httpd-php .php

在DirectoryIndex index.html index.html.var一行后加入index.php，即改为：

DirectoryIndex index.html index.html.var index.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启Apache服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#/usr/local/apache2/bin/apachectl restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3)测试PHP：&lt;/p&gt;

&lt;p&gt;在Apache服务器的文件根目录（/usr/local/apache2/htdocs/）下新建一个PHP文件test.php，并输入以下内容：&lt;/p&gt;

&lt;p&gt;&amp;lt;?php
    phpinfo();
?&amp;gt;&lt;/p&gt;

&lt;p&gt;在浏览器中输入&lt;a href=&#34;http://localhost/test.php，如果看到下图，则表示已成功安装了PHP。&#34;&gt;http://localhost/test.php，如果看到下图，则表示已成功安装了PHP。&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;python的安装&#34;&gt;python的安装：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;                                                                                                                                                                                           1、在官方网站下载python安装包，这里注意python.org/download路径被屏蔽，需要使用http://www.python.org/页面上的中文“下载”链接进行下载。

                                                                                                                                                                                           这里下载了python最新的3.2.2版本：Python-3.2.2.tgz

                                                                                                                                                                                           下载后，文件目录在/home/python/下，这也是我python的安装目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、解压：&lt;/p&gt;

&lt;p&gt;[root@www python]# tar zxvf    Python-3.2.2.tgz&lt;/p&gt;

&lt;p&gt;3、打开安装目录，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@www python]# cd Python-3.2.2

[root@www Python-3.2.2]#./configure

[root@www Python-3.2.2]# make

[root@www Python-3.2.2]# makeinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值此，安装完成。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;以上都是我对这些应用的一个安装过程，其实再联网的情况下，用yum/rpm是最好的，但是要搞懂安装的过程可以用源码安装，编译安装，其实就是变成可以执行文件，然后放到我们的可执行文件环境变量所指的路劲下
，也可以直接下载可执行文件的包，解压安装。linux下大体就是这些方式，还有一些特殊的方式，具体看安装步骤.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>life experience</title>
      <link>http://kingjcy.github.io/blog/2016/05/10/life-experience/</link>
      <pubDate>Tue, 10 May 2016 15:03:35 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/05/10/life-experience/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;人生课堂&amp;mdash;交通事故&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这次的交通事故教会我不少。。。社会也需要我不断的学习&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;首先描述一下，事情是这样的，5月8号晚上，我开车由北向南直行，对方的车由东向南左转弯，当我车到十字路口的时候，他的车方向还没有打过来，我向右打了一个方向，还是没有躲过，最后被撞了一下。
第一次发生车祸，我不知道该怎么处理，只能通知家人，他说留个电话明天处理，我肯定不让，我没有办法就这么相信别人，所以也就没有答应，最后家里人过来，他却没有任何交代，只留下他的朋友走了，
后来打电话然他回来，他却没有回来，依稀记得，他很叫嚣：要么明天处理，要么你就报警，我不可能信任他，我只有报警。其实我是第一次遇到这种事情，现在才知道交通事故是要报警的，要是知道我当场就报警了，
当然我现在也知道也可以私了，只有谈妥赔钱就好，不然你要是走保险，那必须报警，需要驾驶证，行驶证，和保单。这个切记切记，以后就知道怎么做了。&lt;/p&gt;

&lt;p&gt;还有一点描述，关于他酒驾，我知道酒驾问题很严重的，所以看他态度比较好，就好心帮了他一把，就说不确定他有没有酒驾，确实我也不能拿出证据说明他有没有酒驾，然后交警那边说现场说酒驾，事后没有说酒驾，
还说和我商量好的（尽管我录笔录的时候说他并没有经过我同意就走了，），说我不配合，而且现在就不一定是他全责了，这个不是我们说了算的，必须交警来判定，所以最后的结果 还不得而知，真是好心办坏事啊，
这也是我一开始时候最担心的，所以其实做笔录的时候，我说的都是真话，不然真有做伪证的麻烦，这点以后也要切记切记。&lt;/p&gt;

&lt;p&gt;现在事情已经这样，我也就这样吧，本来想快点解决的，现在才知道这不是急的事情，现在我同意和他私了，他说交警同意他也可以私了，如果不成的话，我就去物价局开物价单，按规矩来，至于他的问题怎么解决，和我无关，
以后千万不要想太多去发律面前随便帮助别人，帮助他就像一开始那样，给他机会回来解决问题，但是放弃了。&lt;/p&gt;

&lt;p&gt;现在想想，我一没有肇事逃逸，二没有做伪证，最后的结果可能就是我要为事故本身担责，就算这样，我也认了，吃一亏长一智，最后还是由交警判定，坚持自己的说法，在交警队不是想怎么说就能怎么说的，这点依然要切记切记。&lt;/p&gt;

&lt;p&gt;中午百度了一下，肇事逃逸分为尚不构成犯罪的，和构成犯罪的，离开现场就是逃逸，损失较小的尚不构成犯罪，但是一般是需要承担全责，并处以处罚的，这个事情现在依旧可以私了，是允许的，如果不私了，那就走法律。
所以目前对我来说是没有什么问题的，等待结果吧！！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>My Future Direction</title>
      <link>http://kingjcy.github.io/blog/2016/05/06/my-future-direction/</link>
      <pubDate>Fri, 06 May 2016 17:24:35 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/05/06/my-future-direction/</guid>
      <description>&lt;p&gt;今天写下这个也许有点早了，就像我之前想的Linux c/c++ 服务端就是并发编程的一样，并不是你看到那样，只是你还没有深入，没有达到要求，但是也写下来吧！对我以后的发展方向与结果也有一个印证。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;大数据和云计算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;云是网络、互联网的一种比喻说法。这句话是在知乎上看到的，我觉得比较贴切，比较好理解。&lt;/p&gt;

&lt;p&gt;云计算也即是互联网计算模式，目前数据已成为技术的中心，围绕着数据，总的来说大数据有5个部分。数据采集，数据存储，数据清洗，数据挖掘，数据可视化。
数据采集有硬件采集，如OBD，有软件采集，如滴滴，淘宝。数据存储就包括NOSQL，hadoop等等。数据清洗包括语议分析，流媒体格式化等等。数据挖掘包括关联分析，相似度分析，距离分析，聚类分析等等。数据可视化就是WEB的了。&lt;/p&gt;

&lt;p&gt;这个充分体现了以数据为中心的计算和存储的模式，已然是一个趋势。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我目前的想法与规划&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之前一直致力于Linux c/c++服务端方向出发，希望搞服务器，而服务无外乎大规模的访问并发，强大的数据处理能力，以及快速的响应时间。
所以一直在研究并发和处理逻辑，随着服务器通信的面纱被一步步解开，越来越发现，现在的服务端已然很强大，支持其现在的规模完全没有问题。
而且在前人的努力下，大量的库完美的支撑着各方面的功能，已然无用武之地。一个公司不可能没事让你自己搞一套不成熟的服务器，那样用别人现成的，也就只剩下维护了。
这是相当不爽的事情，不是说好的在前人的基础上可以看的更远吗？做的更多吗？忘记了公司存在的根本是赚钱。&lt;/p&gt;

&lt;p&gt;这也是没有办法的事情，但是后端的强大远远不是我想的那样，服务器就只是哪些吗？不是，所以我看到了大数据和云计算技术，是啊，现在是互联网时间，数据才是中心，每天都有海量的数据产生。
它的价值就不是能说出来的了，可以体会，所以开始研究大数据和云计算，今天是玩hadoop的第二个星期，我又纠结了，成功的搭起框架，玩起分布式存储和mr分布式计算框架。我又发现，这个生态系统已经很强大，看样子我又要进入到ops的角色了。
前几天听一个朋友说，现在的大数据和云计算技术，大部分只是极限于，部署集群，解决问题。我擦，这不是ops的任务吗？
而且感觉这样肯定用不到我学习服务器端的知识，那不是重头开始，完全转了方向。所以我就研究一下别人是怎么想的。&lt;/p&gt;

&lt;p&gt;终于还是有了自己的想法，和更加明确的方向：
以前学的服务端的网络通信编程，进程，线程等等相关的知识都是基础。那是完全没有错的，没有这些就入不了门，现在是相当于入门了，在想想，hadoop公司是只要用就好，而你就必须当运维吗？你就不可以研究hadoop底层的东西，你想想节点和节点之间不是用的你那些并发通信还能是什么？
所以方向还是对的，就看你怎么做了，所以朋友说的对，你想的太多了，看到的太少了，所以现在就研究hadoop的底层实现，这些都是一个经典的架构，对于以后的发展都是有很大作用的，你想想，你可以动手部署集群，解决问题，还了解底层架构。你会没有工作。&lt;/p&gt;

&lt;p&gt;哈哈，所以以后好好学习，目前，基础已经打下，还不是太牢，但是都是知道的，这样已经入门，所以我现在可以研究hadoop以及底层开源架构，还有其他很多的开源热点项目，总算跟上了一点时代的步伐。&lt;/p&gt;

&lt;p&gt;目标是：&lt;code&gt;研究开源，实战生产，团队开发，可以去nb的工作，拿高工资。&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;摘抄知乎：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不去盲目的追求任何一种技术，而是通过自己的实践观察，在实际的体验和业务中将技术融会贯通，旧的是基石，新的是提炼，hadoop也不过是Google论文下的一只小虾米，仅此而已，认清楚自己和技术的关系才最为重要，技术永远是你用来提升对这个社会理解的小工具，情商永远比智商重要。&lt;/p&gt;

&lt;p&gt;Hadoop说到底只是一项分布式系统的工具，学习的本质是：理解分布式系统设计中的原则以及方法，例如负载均衡，故障恢复，并发程序设计，并发数据结构，等等。理解这些设计原理，并走入底层读懂每一行Hadoop的源码更加的重要。最近在改Hadoop的源码，坦白说Hadoop作为一个复杂的开源项目有着太多的局限，许多实现对于效率和并发缺乏考虑。&lt;/p&gt;

&lt;p&gt;持续更新中。。。。。。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2016.08.11&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近一直在苦恼linux下java客户端的接入使用，这样就涉及到语言之分，需要使用java的一套东西，慢慢了解java的机制，发现了java的可以快速之道，都是部署现成的jar包，都自动加载机制，所以很便捷也是有道理的，这让我想起了最近的go很火，也是使用包的管理机制，可以各种包管理，这样可以让我们这些偏好c/c++的人重最底层的生产力中解放出来，可以更快速的开发，所以一样的道路，但是对我来说，以后的发展方向怎么说，其实都是一样的，我需要搞后端，服务端，是开发并不是运维，需要搞分布式，大数据，云计算，这样不可能只是一门语言完成的，现在只是知道自己要做什么，然后需要用到什么都要学习，我想我是走在一条去架构师的路上。。。。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>觉得很有想法，也许对以后的道路会有影响。</title>
      <link>http://kingjcy.github.io/blog/2016/04/29/%E8%A7%89%E5%BE%97%E5%BE%88%E6%9C%89%E6%83%B3%E6%B3%95%E4%B9%9F%E8%AE%B8%E5%AF%B9%E4%BB%A5%E5%90%8E%E7%9A%84%E9%81%93%E8%B7%AF%E4%BC%9A%E6%9C%89%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Fri, 29 Apr 2016 16:25:18 +0800</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/04/29/%E8%A7%89%E5%BE%97%E5%BE%88%E6%9C%89%E6%83%B3%E6%B3%95%E4%B9%9F%E8%AE%B8%E5%AF%B9%E4%BB%A5%E5%90%8E%E7%9A%84%E9%81%93%E8%B7%AF%E4%BC%9A%E6%9C%89%E5%BD%B1%E5%93%8D/</guid>
      <description>&lt;p&gt;觉得很有想法，也许对以后的道路会有影响。虽然在国内也许不适用，但是总是有个梦。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;很高兴看到阿里云的成立。这意味着阿里已经把对互联网技术的投入提高到了的战略高度。过去经常听工程师抱怨阿里不是一家技术公司。现在再没有理由可以这样抱怨了。但是要实现这个战略，没有技术储备是不行的。招聘和培养工程师显然是目前集团各子公司同时面临的一个令人头痛的难题。由于曾经在硅谷工作过，我常想，为什么硅谷有这么多40岁以上的工程师，而国内30岁以上的就已经寥寥无几了？为什么硅谷的工程师的技术寿命可以这么长？为什么他们可以不浮躁，不急功近利呢？阿里要走102年，阿里的工程师可以一起走多远呢？在国内，有2-3年工作经历的工程师就可以算有经验的了。工作了5年以上的工程师往往会考虑向管理岗位转型，或者向业务转型。中国目前处于高度发展的阶段。很多企业缺乏管理人才，工作5年就被提吧为干部很正常。但留下的后遗症是30岁以上的优秀技术人才极度缺乏。在硅谷，5年以下工作经验的人都算是初级的。一般高级工程师需要5年以上的工作经验，架构师一般需要10年以上的工作经验。这还不算上大部分硅谷的工程师都有计算机硕士学位。毕业的时候一般已经是24，25岁了。再工作10年，35岁才升为架构师是非常正常的。然而，公司里的架构师有限。其实大部分40岁的工程师仍然在一线工作，比如写程序，做测试，进行项目管理等。美国硅谷是计算机人才集中的地方，也是创业公司群集的地方。在硅谷，从只有几个人到几十个人的创业公司比比皆是。他们的共同梦想就是经过几年的奋斗，通过技术的创新，再次缔造像英特尔, 苹果，思科，甲骨文，雅虎，Google，Facebook等这样的神话。即使创造不了神话，也可以通过IPO或者被收购的途径创造财富。在这样的环境中，公司对管理人才的需求同样是非常大的，但为什么仍然有大量的工程师“无动于衷”，仍然从事着技术活儿呢？我认为有两个主要原因。一个是外因。在美国，管理岗位的待遇和技术岗位待遇相差不大。特别在崇尚技术的硅谷，经理的地位并不比工程师高，甚至更低。比如架构师在公司里的重要性往往要超过经理。因此管理岗位的“诱惑”并不大。在这样一种技术氛围中，走技术路线很正常。但是即使在这样一个技术环境中，硅谷对管理人才依然需要。当工程师表现出色时，也有很多机会转成管理岗位。然而相当一部分工程师会主动放弃这样的机会，而继续干他们的技术活儿。这就是内因在驱动了。技术工作和管理工作的本质区别是，前者面对的是系统（软件，硬件等），而后者面对的是人。系统问题再难，只要有足够的时间和资源，一般都可以解决。越难的问题，解决之后越有成就感。而人的问题，有时候看似很简单，却解决不了。是人，总要有头疼脑热，生病的时候。是人，免不了产生情绪，从而影响工作。有人的地方，就会有矛盾，就会有摩擦。简单地讲，系统会按照事先设定的逻辑运行，是死的，因此往往可控，可规划。而人是活的，不是输入几条命令就可以控制的，而是需要沟通，需要感情的。因此，大部分硅谷的工程师很“聪明”。他们主动选择“简单”地工作。白天好好地工作，晚上好好地生活。何必去“自寻烦恼”，转做管理呢。其实不光是硅谷的，其它地区的工程师都有一个共同的性格特点，追求简单，追求完美，思维方式上比较理性和逻辑性，看问题比较趋向于非黑即白。这样的性格非常适合做技术工作，可是我们中国的工程师有时候偏偏看不到自己的这个特点。不想当元帅的士兵不是好士兵。工程师希望向管理方向发展是非常正常的。但问题是为什么和怎样？我碰到过不只一个工程师告诉我，希望转做管理的原因是担心今后年级大了，技术能力跟不上了。我觉得非常可笑。这就好比是一个士兵说：我杀敌本领不行，不适合上战场，那就让我做军官吧。一个没做过士兵的元帅肯定不是好元帅。其实做技术和当兵毕竟不同，不是靠体力吃饭的。年级大点往往是优势。我觉得走技术路线对工程师性格的人是一条捷径。如果能静下心来仔细钻研技术，一定能在某个方面做得比别人好。这里的关键是好奇心和耐心。在今天这样的信息时代，找到答案并不是一件难事。难就难在有没有好奇心和耐心去找。比如，Java程序员天天都用到String这个类型。但有没有想过为什么Java语言里有String和StringBuffer两种字符串类型，而不是一种？有没有去看过String和StringBuffer的源代码？再例如，天天做网站和HTTP打交道，有没有看过HTTP协议？有没有尝试过不用浏览器，wget等工具，而用最原始的telnet方式来访问网站？看看这HTTP的头里到底是什么东东？在我面试过的工程师中，做过这几件事的人不到5%。一旦了解得比别人深，就容易看到问题本质，产生信心，激发乐趣。这时候你的解决方案就比别人漂亮，逐渐建立起了影响力，成为了“专家”。因此公司里的疑难杂症会主动找上门来。你就比别人得到了更多的解决问题的机会，从而更快地提升能力。一旦进入良性循环，你的进步就比别人快，但付出的却不一定比别人多。这时候你已经走上了捷径。在技术人才极度缺乏的中国，在众人盲目追求管理岗位的那点虚荣的今天，如果你的性格是工程师类型的，走技术路线其实是非常适合的。如果你才毕业，那你是最幸福的。你可以给自己制定3个甚至4个五年计划。例如5年打基础，10年变专家，15年国内知名，20年世界闻名。如果你已经奔三或者三十出头，那你快成熟了，但离开花结果还早呢。不信你看看下面几位我们都熟悉的人。拉里-沃尔（Larry Wall）33岁时出版了《Perl语言编程》一书。之前他是一个系统管理员。互联网之父温特-瑟夫（Vint Cerf）在发明TCP/IP时，已经35岁。万维网之父蒂姆·伯纳斯—李（Tim Berners-Lee）在37岁时才发明了万维网（WWW）。丹尼斯-里奇（Dennis Ritchie）的《C程序设计语言》一书出版时，他37岁。Java之父詹姆斯·戈士林（James Gosling）40岁时才因为发明Java而成名。苹果公司创始人之一史蒂夫•沃兹尼艾克（Steven Wozniak）在今年年初以首席科学家的身份加入一家创业公司，研发基于高速闪存技术的存储。他如今已经59岁了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/Anker/archive/2013/01/04/2844834.html&#34;&gt;http://www.cnblogs.com/Anker/archive/2013/01/04/2844834.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用hugo&#43;github构建自己的blog</title>
      <link>http://kingjcy.github.io/blog/2016/04/19/%E7%94%A8hugo&#43;github%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84blog/</link>
      <pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://kingjcy.github.io/blog/2016/04/19/%E7%94%A8hugo&#43;github%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84blog/</guid>
      <description>&lt;h3 id=&#34;使用hugo-github搭建属于自己的blog网站&#34;&gt;使用hugo+github搭建属于自己的blog网站&lt;/h3&gt;

&lt;p&gt;这个是我用hugo+github搭建起个人blog写的第一篇文章，有点小兴奋。。。首先把搭建测过程写起来和大家分享一下吧。&lt;/p&gt;

&lt;p&gt;首先，作为一个程序员，不拥有自己搭建的blog，而去用别人搭建好的去注册一下，我是无法接受的！！搭建个人blog需要两个东西：&lt;/p&gt;

&lt;p&gt;1、静态网页生成器，有jekyll，hexo，hugo等，由于最近在玩go语言，所以就选择了hugo，其他的也没有深入了解，后面搭建起来，发现hugo还是比较简单。&lt;/p&gt;

&lt;p&gt;2、github pages 这个是github提供的一个托管工作，相当好用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;hugo&#34;&gt;hugo&lt;/h2&gt;

&lt;p&gt;这个比较方便的静态页面生成器，首先需要安装，我的系统是centos 64位的.&lt;/p&gt;

&lt;h3 id=&#34;install&#34;&gt;install&lt;/h3&gt;

&lt;p&gt;2、直接下载二进制文件，这也是我说的方便的地方。&lt;/p&gt;

&lt;p&gt;Hugo二进制下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载下来后，首先要生成自己的站点：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new site mysite&lt;/code&gt;&amp;ndash;这边hugo的二进制文件不一定是这个名字，可以起个别名alias来用&lt;/p&gt;

&lt;p&gt;这时会在mysite目录下生成一些目录和文件，这边简单的介绍一下，config.toml是网站的配置文件，这是它的作者GitHub联合创始人Tom Preston-Werner 觉得YAML不够优雅，捣鼓出来的一个新格式。如果你不喜欢这种格式，你可以将config.toml替换为YAML格式的config.yaml，或者json格式的config.json。hugo都支持。content目录里放的是你写的markdown文章，layouts目录里放的是网站的模板文件，static目录里放的是一些图片、css、js等资源。&lt;/p&gt;

&lt;p&gt;然后进入站点目录mysite，新建文档&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cd mysite&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new about.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这边新建一个md文件会出现在content目录下，一般这个about.md文件是一个关于本站的介绍或者blog个人介绍，在这边将一下md文件的编辑，其实就是MarkDown格式文件的编写，具体的格式可以参考本文的编辑，或者去网上去搜索一下就ok,这边我说几点，我经常记错&lt;/p&gt;

&lt;p&gt;1、就是&amp;rdquo;+++&amp;ldquo;内的赋值用&amp;rdquo;=&amp;ldquo;，&amp;rdquo;&amp;mdash;&amp;ldquo;内的用&amp;rdquo;:&amp;ldquo;。&lt;/p&gt;

&lt;p&gt;2、&lt;code&gt;###&lt;/code&gt;后面必须有空格。&lt;/p&gt;

&lt;p&gt;3、有空行才能换行。&lt;/p&gt;

&lt;p&gt;一般我们写博文，会放在content/post下，正如我这边编写的第一篇文&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new post/first.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后用vim编辑器进行编辑，编辑好后，就可以将你编辑的文字生成静态网页了，当然你肯定需要一个模板，这样可以使你的网页根据美观，这边在讲一下模板的使用&lt;/p&gt;

&lt;p&gt;1、模板放在站点的themes下，一般木有这个文件夹，我们需要新增一个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkdir themes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cd themes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2、模板可以到hugo官网上去找,那边可以showcase预览一下自己喜欢的，具体的安装方式也有介绍，就是用&lt;code&gt;git clone&lt;/code&gt;把源码下到themes目录下就好&lt;/p&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、编辑模板的配置文件，这个视具体模板，可以参考我的配置&lt;a href=&#34;https://github.com/kingjcy/&#34;&gt;https://github.com/kingjcy/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面就是生成我们需要的静态网页了，也就是前端的html文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo --theme=hyde --baseUrl=&amp;quot;http://kingjcy.github.io/&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不出意外的话，应该在站点目录下生成一个public文件夹，这个就是我们需要的所有文件了，至此第一步已经完成了。&lt;/p&gt;

&lt;h2 id=&#34;github-pages&#34;&gt;github pages&lt;/h2&gt;

&lt;p&gt;这个就简单了，因为本身就是github提供现成的东西，首先新增一个repo，命名为：&lt;code&gt;kingjcy.github.io&lt;/code&gt; （kingjcy替换为你的github用户名）。&lt;/p&gt;

&lt;p&gt;然后将第一步的public加入git版本，上传到这个项目，就可以访问你的个人blog：&lt;code&gt;http://kingjcy.github.io/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;至于git版本控制和github直接的传输，这边就不多讲了，如果需要可以参考我的另外一篇博文《git和github的使用》。&lt;/p&gt;

&lt;p&gt;终于搭建完了，欢迎指正,tks。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>